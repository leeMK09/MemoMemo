## [카프카] 파티션, 세그먼트에 대해

### 파티션

- 파티션은 기본적으로 삭제가 불가능하고 추가는 가능한 로그성 파일이다 
- 기존 파티션을 수정할 수 없음 
- 매우 단순한 Append Only 방식 → 카프카 성능에 비결 
    - 디스크에 데이터를 순차적으로 쓰는 작업은 헤드를 여러번 움직이며 사용하는 작업(랜덤 IO)에 비해 성능이 높음 
- **파티션은 사실 여러개의 세그먼트로 구성되어져 있다**
- **아래 이미지대로 Broker 의 파일 시스템은 안에 Partition 이라는 폴더가 존재하게 되고 그 안에 Segment 라는 파일이 여러개 존재한다**

![partition_segment](./img/partition_segment.png)

- 파티션이 단 하나의 파일이라면 파일 크기도 커지며 관리가 어려움 
    - 데이터 삭제하는 과정 또한 어려움 

</br>
</br>

### 세그먼트(segment)

- 파티션은 여러개의 segment 로 구성 
- Producer 가 보내는 메시지는 active segement 의 끝에 보내진다 
- 그외의 일반적인 segment 는 현재 데이터가 아닌 과거 데이터를 가지고 있다 
- active segment 는 특정 크기에 도달하게 되면 닫고 새로운 active segment 가 생성 및 변경되는 작업을 수행한다- segment 의 파일 이름은 첫번째 오프셋으로 시작되는 오프셋이 파일 이름이 된다 
- segment 도 사실 하나의 파일이 아닌 한쌍의 파일들로 구성되어 있다

![segment_architecture](./img/segment_architecture.png)

- 세그먼트의 내부 구조 
- 3가지의 파일이 존재 
- log 확장자 파일 
    - 프로듀서가 보낸 메시지의 본문, 헤더, 키, 타임스탬프 등의 실제 데이터가 순서대로 저장되는 파일 
- 인덱스 확장자 파일 
    - 카프카는 빠른 성능의 읽기를 위해 컨슈머가 메시지를 소비하는 요청을 보낼때 카프카는 모든 로그 파일을 보는 것이 아닌 인덱스 파일을 먼저 참고하고 참고한 정보 기반으로 로그 파일을 조회한다 → 인덱스 처리 같은 역할을 수행 
    - 일정 간격마다 메시지의 오프셋과 로그 파일에서의 물리적인 파일 위치 쌍을 저장한다 → 계속 저장하는 것은 아니다 
    - 메시지 조회 시
        - 카프카는 먼저 메시지의 오프셋을 기준으로 segment 의 파일을 찾음 → segment 의 파일 이름은 처음 시작되는 오프셋이 바로 파일 이름이다 
        - 인덱스 파일을 먼저 확인 → 이진 탐색을 통해 실제 물리적 위치를 찾음 (해당 범위 안에 있구나 인지) → 로그 파일 스캔, 데이터 읽기 
    - 타임에 대한 파일 
        - 오프셋이 아닌 시간을 기준으로 메시지를 읽을 때 사용 → 자주 사용되진 않음 

</br>
</br>

### OS 페이지 캐시, Zero 카피 전략 

- 카프카의 또 다른 성능 비결 
- 운영체제의 기능을 적극적으로 활용 
- OS 페이지 캐시 
    - 카프카는 JVM 엔진을 사용, 데이터를 힙 메모리에 두지 않고 OS 의 페이지 캐시 영역에 의존하며 동작하게 됨    - 페이지 캐시 : 물리적 RAM 의 일부를 디스크 데이터의 캐시로 사용하는 영역 
        - 한 번 읽은 데이터는 페이지 캐시에 남김으로써 디스크 접근없이 RAM 의 속도로 데이터를 제공하게 된다 
    - 이를 통해 카프카는 큰 힙에 메모리 할당없이 GC 의 부담을 줄여주는 대표적인 캐싱 처리 
- **Zero 카피 전략**([Zero Copy](https://ego2-1.tistory.com/34))
    - 메시지를 소비하는 컨슈머는 데이터를 다룰 때 OS 의 sendFile 이라는 시스템 콜을 사용해서 데이터의 커널영역에서 바로 네트워크로 복사하게 된다 
    - 이 과정에서 애플리케이션 영역에서 데이터를 복사하는 과정은 불필요하므로 이 과정을 생략하게 된다 
    - 불필요한 CPU 낭비와 메모리 복사를 줄여준다 

</br>
</br>

### 오래된 데이터의 관리 

- 모든 데이터의 저장과 관리를 세그먼트 단위로 관리한다 
- 세그먼트는 일종의 로그파일 
- 로그 리텐션 정책을 사용 
- 카프카를 구동할 때 설정하는 환경변수에 따라 달라진다 
    - 시간 기반 리텐션 정책 사용 → 7일로 설정하면 7일이 지난 세그먼트 파일을 물리적으로 삭제 
    - 크기 기반 리텐션 정책 사용 → 파티션의 전체 크기가 특정 용량을 초과한다면 가장 오래된 세그먼트를 물리적으로 삭제 
- 중요한 건 카프카는 DB 와 같은 개념이 아닌 이벤트 버스의 역할을 수행한다 
    - 오래된 데이터는 따로 영속화 처리 구성을 하는 것이 올바르다 
