## 절차지향은 뭘까?

객체지향에 관해 이야기하기 전에 먼저 절차지향에 대해 이해할 필요가 있습니다

그리고 "절차지향(procedure oriented)" 이전에 "순차지향(sequential oriented)" 라는 패러다임도 있었습니다

**그렇다면 절차지향 프로그래밍과 순차지향 프로그래밍의 차이는 뭘까요?**

대부분의 개발자들은 순차지향 프로그래밍을 코드가 위에서 아래로 순차적으로 실행되는 프로그래밍 방식이라고 생각합니다 → 맞습니다!

그런데 상식적으로 "순차" 라는 말과 비슷하게 "절차" 라는 말도 위에서 아래로 순서대로 진행하겠다는 의미와 비슷해보입니다

그렇다면 순차지향과 절차지향은 사실상 같은 말인가요?

어떤 글에서는 순차지향과 절차지향을 똑같이 설명하는 글도 존재합니다

그러나 이는 틀린 설명입니다 → 둘은 엄연히 다른 패러다임 입니다

</br>

순차지향 프로그래밍은 "Sequential" 이 "순차적으로" 라는 뜻이므로 말 그대로 코드를 위에서 아래로 읽겠다는 의미입니다

그런데 절차지향에서 말하는 절차는 "Procedure(절차)" 입니다

"Procedure" 는 컴퓨터 공학에서는 사실상 함수입니다

그래서 절차 지향 프로그래밍은 사실상 "함수" 지향 프로그래밍이라고 볼 수 있습니다

즉, 절차지향 프로그래밍은 함수 위주로 생각하고 프로그램을 만드는 패러다임인 것 입니다

순차지향적 프로그래밍 예시 → 어셈블리어

```bash
add:
	subq $8, %rsp
	leaq 16(%rsp), %rax
	movq %rax, 0(%rsp)
```

어셈블리어로 작성된 코드에는 함수의 개념이 존재하지 않습니다.

그저 코드를 위에서 아래로 순차적으로 읽을 뿐입니다

</br>

절차지향적 프로그래밍 예시 → C언어

```c
int add(int a, int b) {
	return a + b;
}

int main() {
	int a = 2;
	int b = 3;
	return add(a,b);
}
```

절차지향 프로그래밍은 함수를 만들어서 프로그램을 만드는 방식입니다

**복잡한 문제를 개별 "함수"로 분해하고, 여러 함수를 이용해 문제를 해결하는 방식** 입니다

</br>

**만약, 자바 코틀린의 객체지향 언어를 사용하더라도 절차지향적 사고 방식 즉 함수 위주의 사고방식으로 프로그램을 만든다면 여전히 절차지향 패러다임으로 개발을 하고 있는 것 입니다**

**(= 프로그랭 언어가 곧 프로그래밍 패러다임인 것은 아닙니다!)**

그러면 이제부터 예시를 통해 알아보겠습니다

(예시는 음식 체인 관리 시스템이며 절차지향적인 코드를 객체지향적으로 변경하는 예시 입니다)

- 레스토랑 서비스
  - 레스토랑은 여러개의 지점을 관리한다
- 각 지점에서 주문을 등록
  - 주문에는 상품(음식) 이 복수개로 존재한다
- "매출과 순이익을 계산하는 예시"

```java
import java.util.List;

public class RestaurantChain {

    private List<Store> stores;
}

@Getter
class Store {

    private List<Order> orders;
    private long rentalFee; // 임대료
}

@Getter
class Order {

    private List<Food> foods;
    private double transactionFeePercent = 0.03; // 결제 수수료
}

@Getter
class Food {

    private long price;
    private long originCost; // 원가
}
```

위 코드는 클래스 단위의 코드이며 이제 "매출과 순이익을 계산하는 코드" 는 아래와 같습니다

```java
public class RestaurantChain {

    private List<Store> stores;

    // 매출을 계산하는 함수
    public long calculateRevenue() {
        long revenue = 0;
        for (Store store : stores) {
            for (Order order : store.getOrders()){
                for (Food food : order.getFoods()) {
                    revenue += food.getPrice();
                }
            }
        }
        return revenue;
    }

    // 순이익을 계산하는 함수
    public long calculateProfit() {
        long cost = 0;
        for (Store store : stores) {
            for (Order order : store.getOrders()) {
                long orderPrice = 0;
                for (Food food : order.getFoods()) {
                    orderPrice += food.getPrice();
                    cost += food.getOriginCost();
                }
                // 결제 금액의 3%를 비용으로 잡는다
                cost += orderPrice * order.getTransactionFeePercent();
            }
            cost += store.getRentalFee();
        }
        return calculateRevenue() - cost;
    }
}
```

위 코드는 객체지향적으로 작성된 코드라고 할 수 있을까요? → **아닙니다.**

`calculateRevenue`, `calculateProfit` 같은 코드는 모두 절차지향적인 코드입니다

</br>

### 이유는?

- **객체들이 `RestaurantChain` 클래스에 있는 `calculateRevenue`, `calculateProfit` 함수를 실행하기 위한 데이터로서만 존재할 뿐이기 때문입니다!**

</br>

`Store`(각 지점), `Order`(주문), `Food`(음식) 를 클래스로 표현했지만 이 클래스에는 아무런 책임이 존재하지 않습니다.

그냥 데이터를 실어 나르는 역할 정도만 할 뿐 입니다

</br>

**이런식으로 스프링 프로젝트를 할때에도 혹시 모든 비즈니스 로직이 서비스(Service) 컴포넌트에 들어가 있진 않았나요?**

**그리고 사실상 스프링은 서비스에 있는 전지전능한 함수를 실행하기 위한 껍데기처럼 동작하진 않았나요?**

즉, 다음과 같은 코드를 작성해본 적이 있는가요?

```java
@Service
@RequiredArgsConstructor
public class RestaurantChainService {

    private final StoreRepository storeRepository;

    public long calculateRevenue(long restaurantId) {
        List<Store> stores = storeRepository.findByRestaurantId(restaurantId);
        long revenue = 0;
        for (Store store : stores) {
            for (Order order : store.getOrders()){
                for (Food food : order.getFoods()) {
                    revenue += food.getPrice();
                }
            }
        }
        return revenue;
    }
}
```

위 코드 역시 절차지향적인 코드입니다

`RestaurantChainService` 객체의 `calculateRevenue` 메서드를 실행하기 위해 `Store`, `Order`, `Food` 가 존재할 뿐이기 때문입니다

즉, 서비스에 모든 비즈니스 로직이 들어가고 객체들은 그저 데이터를 저장하는 용도로만 사용되고 있습니다

그래서 이제 절차지향 같은 코드를 객체지향적으로 변경해봅시다

```java
public class RestaurantChain {

    private List<Store> stores;

    // 매출을 계산하는 함수
    public long calculateRevenue() {
        long revenue = 0;
        for (Store store : stores) {
            revenue += store.calculateRevenue();
        }
        return revenue;
    }

    // 순이익을 계산하는 함수
    public long calculateProfit() {
        long income = 0;
        for (Store store : stores) {
            income += store.calculateProfit();
        }
        return income;
    }
}

@Getter
class Store {

    private List<Order> orders;
    private long rentalFee; // 임대료

    public long calculateRevenue() {
        long revenue = 0;
        for (Order order : orders) {
            revenue += order.calculateRevenue();
        }
        return revenue;
    }

    public long calculateProfit() {
        long income = 0;
        for (Order order : orders) {
            income += order.calculateProfit();
        }
        return income;
    }
}

@Getter
class Order {

    private List<Food> foods;
    private double transactionFeePercent = 0.03; // 결제 수수료

    public long calculateRevenue() {
        long revenue = 0;
        for (Food food : foods) {
            revenue += food.calculateRevenue();
        }
        return revenue;
    }

    public long calculateProfit() {
        long income = 0;
        for (Food food : foods) {
            income += food.calculateProfit();
        }
        return income;
    }
}

@Getter
class Food {

    private long price;
    private long originCost; // 원가

    public long calculateRevenue() {
        return price;
    }

    public long calculateProfit() {
        return price - originCost;
    }
}
```

**비즈니스 로직을 객체 스스로 처리하도록 변경했습니다**

그러자 `Store`, `Order`, `Food` 클래스가 갖고 있던 데이터를 그대로 전달하기만 하던 객체가 행동을 갖게 되었습니다!

각 객체는 **매출과 순이익을 계산해달라는 요청이 들어왔을 때 "어떻게 처리해야 할지" 알고 있습니다**

어떤 요청이 들어왔을 때 어떤 일을 책임지고 처리한다 라는 책임이 생긴 것 입니다

→ 객체에서 "무엇을 해줘" 라고 이야기했을 때 객체들이 스스로 이 말의 의미를 이해하고 책임지고 일을 한다

</br>

세가지 변화에 주의깊게 확인하시기 바랍니다

1. 객체에 어떤 메시지를 전달할 수 있게 되었다.
2. 객체가 어떤 책임을 지게 되었다.
3. 객체는 어떤 책임을 처리하는 방법을 스스로 알고있다.

더불어 이제 더이상 결제 수수료를 계산하는 로직은 `RestaurantChain` 에서 처리하지 않습니다

</br>

객체지향적으로 만든 코드는 데이터와 비즈니스 로직이 한 곳에 잘 들어가 있습니다

**즉 데이터 측면에서 봤을때도 어떤 행위를 하기 위해 만들어진 행동과 데이터가 한 곳에 잘 응집되어있다고 볼 수 있습니다**

그래서 이런 경우를 가리켜 **응집도(cohesion) 가 높다고 할 수 있습니다**

→ 자신이 가지고 있는 데이터내에서 행동을 수행한다

</br>
</br>

### 가독성은?

</br>

**그러나 객체지향적으로 변한 코드는 가독성이 좋지 않아보입니다**

(가독성의 기준은 사람마다 다릅니다)

절차지향적인 코드는 모든 코드가 온전히 내 손안에 내가 볼 수 있는 영역안에 모두 들어있는 기분이 듭니다

**하지만 이렇게 느낀다고해서 이상한 것이 아닙니다**

</br>

**애초에 객체지향으로 코드를 작성하는 이유가 "가독성을 높이기 위해서" 가 아니기 때문입니다**

그래서 종종 어떤 코드들은 오히려 객체지향으로 바꿨을 때 가독성이 떨어지는 경우도 있습니다

</br>

**객체지향은 가독성보다 책임에 좀 더 집중합니다**

**객체들은 보면 제각기 담당하고 있는 책임에만 집중합니다**

**객체들은 각자 책임을 수행하기 위한 협력 객체가 무엇인지를 알고 있으며, 그 밖에 필요한 값은 모두 각자가 가지고 있습니다**

**본인이 해야할 일을 본인이 제일 잘 알게 된 것 입니다**

</br>

그리고 **협력 객체들의 내부 동작이 어떤지는 알 수 없게 되었습니다**

**하지만 믿고 메시지를 요청하는 것 입니다!**

**내가 어떤 요청을 했을 때 이 객체가 알아서 업무를 잘 처리하고 데이터를 잘 돌려줄 것 이라고요!**

**그리고 믿고 있기 때문에 협력 객체가 "어떻게" 일을 하는지 신경 쓰지 않습니다**

제대로 해왔는지만 신경 씁니다 → 그렇기 때문에 "캡슐화" 인 것 입니다

</br>
</br>

### 책임은 시스템의 계약 명세이다

</br>

더불어 비즈니스 로직에 필요한 데이터가 잘 모여 있어야만 문제가 발생했을 때 추적하기 쉽습니다

책임을 다하지 못한 객체를 특정하기만 하면 되기 때문이죠

즉 책임이 중요합니다. 소프트웨어가 달성하려는 거대한 목적을 위해 객체들이 책임을 나눠 가져야 한다는 말입니다

</br>

더 나아가 업무 효율도 올라갑니다

객체들이 어떻게 협력할지, 어떤 책임을 맡을지 결정하고 나면 작업을 병렬로 처리할 수 있게 됩니다

개개인은 자신이 담당하는 객체의 책임만 제대로 구현하면 됩니다

책임 기반으로 동작하는 것이 객체지향이기 때문입니다

동료가 업무를 제대로 수행했는지 어떻게 확인할 수 있을까요?

분명 A 를 개발하기로 했는데 A' 을 개발하는 경우가 있을 겁니다

또는 어떤 컴포넌트를 개발하고 협력하는 객체가 어떤 책임을 제대로 수행할 것이라고 가정하고 개발했는데 이 가정이 깨지면서 버그로 이어지는 경험도 있을 것 입니다

**책임은 계약입니다**

수많은 객체가 협력하는 객체지향 프로그래밍에서는 협력 객체들이 계약을 제대로 지키는 것을 가정하고 프로그램을 만들게 됩니다

**그리고 그럴 때 사용할 수 있는 것이 "테스트 코드" 입니다**

"최초의 요구사항을 충족하는가?", "기존 요구사항을 여전히 만족하는가?" 를 검사할 수 있는 테스트 코드는 책임을 계약으로 만드는 가장 확실한 방법이자 시스템의 계약 명세입니다
