## 1. 상위 클래스의 변경이 어려움

- 상속은 상위 클래스의 변경을 어렵게 만든다
- 만약 상위 클래스를 변경하게 된다면 이를 구현한 클래스가 영향을 받게 된다.
- 즉, 클래스를 변경한 여파가 계층도를 따라 하위 클래스에 전파된다는 것 이다
- 최악의 경우 상위 클래스의 변화가 모든 하위 클래스에 영향을 줄 수 있다
- 이런 이유 때문에 클래스 계층도가 커질수록 상위 클래스를 변경하는 것은 점점 어려워진다

</br>
</br>

## 2. 클래스의 불필요한 증가

- `Storage` 라는 상위 클래스가 존재하고
- `CompressedStorage`, `EncrytedStorage` 두 개의 하위 클래스가 존재할 때
- 만약 압축 (`Compressed`) 와 암호화 (`Encryted`) 를 동시에 제공해야하는 요구사항이 존재할 경우
- `CompressedEncrytedStorage` 라는 두 기능을 상속하는 클래스를 만들어야 한다
- 이는 필요한 기능의 조합이 증가할수록 클래스의 수도 함께 증가한다

</br>
</br>

## 3. 상속의 오용

- `Container` 라는 수화물을 보관하는 보관소가 있다고 할때
- `ArrayList` 를 통해 구현을 진행했다
- 그리고 `put`, `extract` 등의 수화물 클래스 전용 메서드를 추가했을때
- 만약 사용자가 해당 문서를 보지 않고 `ArrayList.add()` 를 했다면, 문제가 발생한다
- 이건 누구의 잘못일까?
  - 더 큰 잘못은 오용의 여지를 준 `Container` 클래스 작성자이다

</br>
</br>

## 정리

- 위와 같은 "상속 오용의 문제" 가 발생하는 이유는 `Container` 는 사실 `ArrayList` 를 완전히 대체하지 못해서 이다
- 즉, `IS-A` 관계가 성립할 때만 사용해야 하는데 두 클래스는 이 관계가 아니기 때문이다
  - `Container` 는 `ArrayList` 이다 (X)
- `Container` 는 수화물을 보관하는 책임을 가진 반면 `ArrayList` 는 목록을 관리하는 책임을 가진다
- 즉, 둘은 서로 다른 책임을 갖는 것 이며 이렇게 같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속을 받게 되면 잘못된 사용으로 인한 문제가 발생하게 된다
