## 추상화 (abstraction)

- 데이터나 프로세스 등을 "의미가 비슷한 개념이나 표현으로 정의하는 과정" 이다
- 어떤 프로그램을 만드는데 다음과 같이 세 개의 기능이 있다고 가정해보자
  - FTP 에서 파일을 다운로드
  - 소켓에서 데이터 읽기
  - DB 테이블의 데이터를 조회
- 위 세가지 기능은 모두 로그를 수집하기 위한 기능이었다
  - 즉, 각 기능은 로그를 수집하기 위한 여러 방법이며 이 세 기능을 추상화하면 "로그 수집" 이라는 개념으로 정의할 수 있다

</br>
</br>

## 왜 추상 타입을 사용하는 것 일까?

- 구현 클래스를 사용해도 되는데 왜 추상 타입을 사용하는 것 일까?
- 위 예시를 인용하여 이야기해보자
- 어느날 새로운 요구사항이 들어왔다. 파일 뿐 아니라 소켓을 통해서 데이터를 읽어와 암호화할 수 있도록 만들어 달라는 것 이었다

```java
if (useFile) {
    FileDataReader fileReader = new FileDataReader();
    data = fileReader.read();
} else {
    SocketDataReader socketReader = new SocketDataReader();
    data = socketReader.read();
}
```

- 만약 HTTP 로 데이터를 읽어와야 한다면 또 다른 `if-else` 블록이 메서드 내부에 추가될 것 이다
- 데이터를 읽어오는 요구사항이 생길때마다 해당 메서드는 계속 영향을 받는다
- 본연의 책임과 상관없는 데이터 읽기 구현의 변경 때문에 함께 바뀌는 것 이다
- 이를 추상화하면
  - "어떤 곳으로부터 바이트 데이터 읽기" 로 표현할 수 있다

```java
public interface ByteSource {
    public byte[] read();
}
```

```java
public class FileDataReader implements ByteSource {
    public byte[] read() {
        ...
    }
}

public class SocketDataReader implements  ByteSource {
    public byte[] read() {
        ...
    }
}
```

- 추상화 뿐 아니라 추가로 "데이터 읽기" 라는 객체를 생성하는 과정 또한 분리해야 한다 (= `ByteSourceFactory`)

</br>
</br>

## 재사용

- 암호화 알고리즘이 바뀌거나 데이터를 읽고 쓰는 대상이 바뀌어도
- 상위 수준의 로직은 바뀌지 않고 재사용되므로, 재사용의 중요성으로 봤을때 하위 수준의 상세 구현보다는 변하지 않는 상위 수준의 로직을 재사용할 수 있도록 설계하는 것이 중요하다
- "핵심 로직은 재사용할 수 있도록 설계해야 한다"

</br>
</br>

## 변화되는 부분을 추상화

- 추상화는 많은 경험이 필요한데
- 경험하지 않은 분야라도 추상화할 수 있는 방법이 있다
- "변화하는 부분을 추상화" 하는 것 이다
  - 추상화 되어 있지 않은 코드는 주로 동일 구조를 갖는 `if-else` 블록으로 드러난다

</br>
</br>

## 인터페이스에 대고 프로그래밍 하기

- 즉 이말은 실제 구현을 제공하는 구현 클래스를 사용해서 프로그래밍하지 않고, 기능을 정의한 인터페이스를 사용해서 프로그래밍하라는 뜻이다
- 그런데, 인터페이스는 최초 설계에서 바로 도출되기 보다는 요구 사항의 변화와 함께 점진적으로 도출된다
  - 즉, 인터페이스는 새롭게 발견된 추상 개념을 통해서 도출되는 것 이다
- 그러나 모든 곳에서 인터페이스를 사용하는 것이 아닌 "변화 가능성이 높은 경우"에 한해서 사용해야 한다

</br>
</br>

## 인터페이스는 인터페이스 사용자 입장에서 만들기

- 만약 `ByteSource` 대신 `FileDataReader` 라고 이름을 명시한다면
- 사용자 입장에서는 구현한 클래스는 모두 파일로부터 데이터를 읽어온다고 착각하기 쉽다
- "따라서 인터페이스를 작성할 때는 그 인터페이스를 사용하는 코드 입장에서 작성 해야 한다"

</br>
</br>

## 구현하지 않은 것에 대한 테스트

- 만약 각각 작업을 나눠가지게 된다면
- 실제 클래스가 구현되지 않는 한 테스트는 못하게 될 것 이다
- 이를 `ByteSource` 와 같은 추상화된 인터페이스에 의존한다고 한다면

```java
public class FlowController {
    private ByteSource byteSource;

    public FlowController(ByteSource byteSource) {
        this.byteSource = byteSource;
    }
}
```

- `Mock` 객체를 통해 구현이 완료되지 않더라도 테스트할 수 있게 된다
- 이때 별도로 분리되는 인터페이스는 테스트 대상이 되는 클래스와 구분되는 책임을 갖게 되는 경우가 많으며
- 이는 곧 새로운 책임을 갖는 객체를 도출하도록 유도한다
