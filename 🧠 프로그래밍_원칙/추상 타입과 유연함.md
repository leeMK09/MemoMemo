## 지하철 노선도의 추상화

해리 백이 창조한 지하철 노선도는 지도가 당현히 가져야 한다고 생각되는 "정확성"을 버리고 "목적"에 집중한 결과이다

지하철 노선도를 사용하는 승객이 꼭 알아야 하는 사실만 정확하게 표현하고 몰라도 되는 정보는 무시함으로써 이해하기 쉽고 단순하며 목적에 부합하는 지하철 노선도를 창조해낼 수 있었다 → 지하철 노선도를 추상화한 것 이다

</br>
</br>

## 추상화 (abstraction)

현실에 존재하는 다양한 현상 및 사물과 상호작용하기 위해서는 우선 현실을 이해해야 한다

문제는 복잡성의 총체인 현실이라는 것을 그대로 수용하기에는 인간이 지니고 있는 인지 능력과 저장 공간이 너무나도 보잘것없다는 점이다

따라서 사람들은 본능적으로 이해하기 쉽고 예측 가능한 수준으로 현실을 분해하고 단순화하는 전략을 따른다

진정한 의미에서 추상화란 현실에서 출발하되 불필요한 부분을 도려내가면서 사물의 놀라운 본질을 드러나게 하는 과정이라고 할 수 있다

추상화의 목적은 불필요한 부분을 무시함으로써 현실에 존재하는 복잡성을 극복하는 것 이다

어떤 추상화도 의도된 목적이 아닌 다른 목적으로 사용된다면 오도될 수 있다. 추상화의 수준, 이익, 가치는 목적에 의존적이다

- 데이터나 프로세스 등을 "의미가 비슷한 개념이나 표현으로 정의하는 과정" 이다
- 어떤 프로그램을 만드는데 다음과 같이 세 개의 기능이 있다고 가정해보자
  - FTP 에서 파일을 다운로드
  - 소켓에서 데이터 읽기
  - DB 테이블의 데이터를 조회
- 위 세가지 기능은 모두 로그를 수집하기 위한 기능이었다
  - 즉, 각 기능은 로그를 수집하기 위한 여러 방법이며 이 세 기능을 추상화하면 "로그 수집" 이라는 개념으로 정의할 수 있다

복잡성을 다루기 위해 추상화는 두 차원에서 이루어진다

1. 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것
2. 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것

</br>
</br>

## 왜 추상 타입을 사용하는 것 일까?

- 구현 클래스를 사용해도 되는데 왜 추상 타입을 사용하는 것 일까?
- 위 예시를 인용하여 이야기해보자
- 어느날 새로운 요구사항이 들어왔다. 파일 뿐 아니라 소켓을 통해서 데이터를 읽어와 암호화할 수 있도록 만들어 달라는 것 이었다

```java
if (useFile) {
    FileDataReader fileReader = new FileDataReader();
    data = fileReader.read();
} else {
    SocketDataReader socketReader = new SocketDataReader();
    data = socketReader.read();
}
```

- 만약 HTTP 로 데이터를 읽어와야 한다면 또 다른 `if-else` 블록이 메서드 내부에 추가될 것 이다
- 데이터를 읽어오는 요구사항이 생길때마다 해당 메서드는 계속 영향을 받는다
- 본연의 책임과 상관없는 데이터 읽기 구현의 변경 때문에 함께 바뀌는 것 이다
- 이를 추상화하면
  - "어떤 곳으로부터 바이트 데이터 읽기" 로 표현할 수 있다

```java
public interface ByteSource {
    public byte[] read();
}
```

```java
public class FileDataReader implements ByteSource {
    public byte[] read() {
        ...
    }
}

public class SocketDataReader implements  ByteSource {
    public byte[] read() {
        ...
    }
}
```

- 추상화 뿐 아니라 추가로 "데이터 읽기" 라는 객체를 생성하는 과정 또한 분리해야 한다 (= `ByteSourceFactory`)

</br>
</br>

## 재사용

- 암호화 알고리즘이 바뀌거나 데이터를 읽고 쓰는 대상이 바뀌어도
- 상위 수준의 로직은 바뀌지 않고 재사용되므로, 재사용의 중요성으로 봤을때 하위 수준의 상세 구현보다는 변하지 않는 상위 수준의 로직을 재사용할 수 있도록 설계하는 것이 중요하다
- "핵심 로직은 재사용할 수 있도록 설계해야 한다"

</br>
</br>

## 변화되는 부분을 추상화

- 추상화는 많은 경험이 필요한데
- 경험하지 않은 분야라도 추상화할 수 있는 방법이 있다
- "변화하는 부분을 추상화" 하는 것 이다
  - 추상화 되어 있지 않은 코드는 주로 동일 구조를 갖는 `if-else` 블록으로 드러난다

</br>
</br>

## 인터페이스에 대고 프로그래밍 하기

- 즉 이말은 실제 구현을 제공하는 구현 클래스를 사용해서 프로그래밍하지 않고, 기능을 정의한 인터페이스를 사용해서 프로그래밍하라는 뜻이다
- 그런데, 인터페이스는 최초 설계에서 바로 도출되기 보다는 요구 사항의 변화와 함께 점진적으로 도출된다
  - 즉, 인터페이스는 새롭게 발견된 추상 개념을 통해서 도출되는 것 이다
- 그러나 모든 곳에서 인터페이스를 사용하는 것이 아닌 "변화 가능성이 높은 경우"에 한해서 사용해야 한다

</br>
</br>

## 인터페이스는 인터페이스 사용자 입장에서 만들기

- 만약 `ByteSource` 대신 `FileDataReader` 라고 이름을 명시한다면
- 사용자 입장에서는 구현한 클래스는 모두 파일로부터 데이터를 읽어온다고 착각하기 쉽다
- "따라서 인터페이스를 작성할 때는 그 인터페이스를 사용하는 코드 입장에서 작성 해야 한다"

</br>
</br>

## 구현하지 않은 것에 대한 테스트

- 만약 각각 작업을 나눠가지게 된다면
- 실제 클래스가 구현되지 않는 한 테스트는 못하게 될 것 이다
- 이를 `ByteSource` 와 같은 추상화된 인터페이스에 의존한다고 한다면

```java
public class FlowController {
    private ByteSource byteSource;

    public FlowController(ByteSource byteSource) {
        this.byteSource = byteSource;
    }
}
```

- `Mock` 객체를 통해 구현이 완료되지 않더라도 테스트할 수 있게 된다
- 이때 별도로 분리되는 인터페이스는 테스트 대상이 되는 클래스와 구분되는 책임을 갖게 되는 경우가 많으며
- 이는 곧 새로운 책임을 갖는 객체를 도출하도록 유도한다
