객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라고 한다.

객체가 협력에 참여하기 위해 수행하는 로직은 책임이라고 부른다.

객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다.

</br>
</br>

## 협력

- 두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다
- 메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니테이션 수단이다
  - 객체 사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다

</br>

## 협력이 설계를 위한 문맥을 결정한다

- 객체가 가질 수 있는 상태와 행동을 어떤 기준으로 결정해야하는가?
- 객체를 설계할 때 어떤 행동과 상태를 할당했다면 그 이유는?
  - 결론적으로 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다
  - 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 한다
  - 또한 객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다
  - 객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다

결과적으로 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정한다. 따라서 협력은 객체를 설계하는 데 필요한 일종의 문맥(Context)을 제공한다

</br>
</br>

## 책임

- 협력에 참여하기 위해 객체가 수행하는 행동을 책임이라고 부른다
- 분류 체계에 따라 객체의 책임을 크게 "하는 것(doing)" 과 "아는 것(knwing)" 의 두 가지 범주로 나누어 세분화하고 있다
- 객체지향 설계에서 가장 중요한 것은 책임, 객체에게 얼마나 적절한 책임을 할당하느냐가 설계의 전체적인 품질을 결정한다
- 객체의 구현 방법은 상대적으로 책임보다 덜 중요하며 책임을 결정한 다음에 고민해도 늦지 않다
  - 책임할당
    - 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것
    - 이를 책임 할당을 위한 정보 전문가 (Information Expert) 패턴이라고 부른다
    - 객체들 역시 협력에 필요한 지식과 방법을 가장 잘 알고 있는 객체에게 도움을 요청한다
    - 요청에 응답하기 위해 필요한 이 행동이 객체가 수행할 책임으로 이어지는 것, 따라서 객체에게 책임을 할당하기 위해서는 먼저 협력이라는 문맥을 정의해야 한다
    - 객체지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이루어진다

</br>

## 책임 주도 설계

- 책임을 갖고 책임을 수행할 객체를 찾아 책임을 할당하는 방식
- 협력을 설계하는 방법을 책임 주도 설계 (Responsibility-Driven Desing, RDD) 라고 부른다

> 예시
>
> - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다
> - 시스템 책임을 더 작은 책임으로 분할한다
> - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다
> - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다
> - 해당 객체 또는 역할에게 책임을 할당함으로서 두 객체가 협력하게 한다

</br>

## 메시지가 객체를 결정한다

- 객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택한다
- 객체가 최소한의 인터페이스를 가질 수 있게 된다
  - 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문
- 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다
  - 객체의 인터페이스는 무엇을 하는지는 표현해야 하지만 어떻게 수행하는지를 노출해서는 안된다

</br>
</br>

## 행동(method) 이 상태(state) 를 결정한다

- 객체가 협력에 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동이다
- 캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다
- 상태는 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료일 뿐이다

</br>
</br>

## 역할

- 객체가 어떤 특정한 협력안에서 수행하는 책임의 집합을 역할이라고 부른다
- 협력 안에서 여러 종류의 객체를 교대로 바꿔 끼울 수 있는 일종의 슬롯
  - 가장 일반적인 방법은 추상 클래스, 인터페이스
  - 추상클래스 구현, 역할을 수행하는 모든 객체들이 공통의 기본 구현, 상태가 필요 → 배우와 배역

</br>
</br>

## 객체지향을 실세계에 반영하여 표현하는 이유

실세계의 커피를 주문하는 과정은 객체지향의 핵심적이고 중요한 개념을 거의 대부분 포함하고 있다

사람을 "객체"로 바꾸고 커피 주문 요청을 "메시지"로, 커피를 만드는 방법을 "메서드"로 바꾸면 대부분의 설명을 객체지향이라는 문맥으로 옮겨올 수 있다

</br>
</br>

## 역할과 책임을 수행하며 협력하는 객체들

객체들은 (사람들은) 커피 주문과 같은 특정한 목표를 이루기 위해 서로 협력한다

협력의 핵심은 특정한 책임을 수행하는 역할들 간의 연쇄적인 요청과 응답을 통해 목표를 달성한다는 것 이다

협력에 참여하는 각 개인은 책임을 수행하기 위해 다른 객체(사람) 에게 도움을 요청하기도 하며, 이를 통해 연쇄적인 요청과 응답으로 구성되는 협력 관계가 완성된다

</br>
</br>

## 상태와 행동을 함께 지닌 자율적인 객체

흔히 객체를 "상태(state)" 와 "행동(behavior)" 을 함께 지닌 실체라고 정의한다

이말은 객체가 협력에 참여하기 위해 어떤 행동을 해야 한다면 그 행동을 하는 데 필요한 상태도 함께 지니고 있어야 한다는 것을 의미한다

커피를 제조하는 바리스타가 제조 방법을 모른다는 것이 말이 되지 않는 것 처럼 객체가 어떤 행동을 하기 위해 필요한 상태를 알지 못한다는 것 역시 말이 되지 않는다

**객체가 협력에 참여하는 과정 속에서 스스로 판단하고 스스로 결정하는 자율적인 존재로 남기 위해서는 필요한 행동과 상태를 함께 지니고 있어야 한다**

객체는 행동을 위해 필요한 상태를 포함하는 동시에 (바리스타는 커피 제조 방법을 기억하고 있다) 특정한 행동을 수행하는 방법을 스스로 결정할 수 있어야 한다 (바리스타는 자신이 알고 있는 방법에 따라 커피를 제조한다)

따라서 객체는 상태와 행위를 하나의 단위로 묶는 자율적인 존재이다

</br>
</br>

## 객체의 자율성

객체의 자율성은 객체의 내부와 외부를 명확하게 구분하는 것으로부터 나온다

객체의 사적인 부분은 객체 스스로 관리하고 외부에서 일체 간섭할 수 없도록 차단해야 하며, 객체의 외부에서는 접근이 허락된 수단을 통해서만 객체와 의사소통해야 한다

객체는 다른 객체가 "무엇(what)" 을 수행하는지는 알 수 있지만 "어떻게(how)" 수행하는지에 대해서는 알 수 없다

</br>
</br>

## 메시지와 메서드

객체지향의 세계에서는 오직 한 가지 의사소통 수단만이 존재한다. 이를 메시지라고 한다

객체가 수신된 메시지를 처리하는 방법을 메서드(method) 라고 부른다

메시지와 메서드의 분리는 객체의 협력에 참여하는 객체들 간의 자율성을 증진시킨다

커피를 주문하는 협력 과정에서 커피 제조를 요청받은 바리스타는 커피 머신을 이용해 커피를 제조할 수도 있지만 커피머신을 사용하지 않고 수작업만으로 커피를 제조할 수도 있다

커피를 제조하는 구체적인 방법에 관해서는 관여하지 않는다. 따라서 바리스타는 커피 제조라는 메시지에 응답하기위해 자신만의 자율적인 방법에 따라 커피를 제조할 수 있다

외부의 요청이 무엇인지를 표현하는 메시지와 요청을 처리하기 위한 구체적인 방법인 메서드를 분리하는 것은 객체의 자율성을 높이는 핵심 매커니즘이다

이것이 캡슐화(encapsulation) 라는 개념과도 깊이 관련되어 있다

</br>
</br>

## 객체지향에서의 클래스 (class)

객체지향의 세계에서 클래스 (class) 는 다른 사람들이 보기에 객체지향의 전부인 것처럼 이야기한다

객체지향 선구자들의 초기 의도와 달리 대부분의 사람들이 객체지향을 클래스를 지향하는 것으로 생각한다

클래스의 중요성은 프로그래밍 언어라는 다리를 건너면서 조금씩 부풀려졌다

그 결과 사람들은 객체지향의 중심에 있어야 할 객체로부터 조금씩 멀어져 갔다

클래스가 객체지향 프로그래밍 언어의 관점에서 매우 중요한 구성요소인 것은 분명하지만 객체지향의 핵심을 이루는 중심 개념이라고 말하기에는 무리가 있다

자바스크립트 같은 프로토타입(prototype) 기반의 객체지향 언어에서는 클래스가 존재하지 않으며 오직 객체만이 존재한다

</br>

널리 알려진 미신과 달리 객체지향의 핵심은 클래스가 아니다

핵심은 적절한 책임을 수행하는 역할 간의 유연하고 견고한 협력 관계를 구축하는 것이다

클래스는 협력에 참여하는 객체를 만드는 데 필요한 구현 메커니즘일 뿐 이다

객체지향의 중심에는 클래스가 아니라 객체가 위치하며, 중요한 것은 클래스들의 정적인 관계가 아니라 메시지를 주고받는 객체들의 동적인 관계이다

</br>

객체지향 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 새로운 세계를 창조하는 것이다

따라서 소프트웨어 세계에서 살아가는 객체는 현실 세계에 존재하는 객체와는 전혀 다른 모습을 보이는 것이 일반적이다
