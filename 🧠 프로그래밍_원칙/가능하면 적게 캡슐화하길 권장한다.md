# 객체는 상태에 의해 식별한다

```java
class Cash {
    private Integer digits;

    private Integer cents;

    private String currency;
}
```

- `Cash` 클래스는 3개의 객체를 캡슐화하고 있습니다
- 이 3개의 객체들이 함께 모여 `Cash` 클래스의 객체를 식별합니다
- **즉 동일한 값의 달러, 센트, 통화를 캡슐화하는 `Cash` 클래스의 두 객체는 서로 동일해야 합니다**
  - Java 언어의 관점에서 보자면 기술적으로 올바른 설명은 아니지만 이는 이전 컴퓨터의 의존적인 설계적 결함이라고 생각합니다
  - **객체 패러다임은 순수한 객체지향 언어를 이용해서 상태가 동일하면 동일한 객체로서 바라봐야 한다고 생각합니다**
- 또한 "객체" 는 고수준의 행위를 발행하기 까지는 객체들의 집합체가 이루어져야 합니다
  - **즉 고수준의 행위는 객체들의 집합체(aggregation) 에 의해 발행됩니다**
  - 예시로서
    - 책은 페이지, 표지, ISBN 의 집합체이고
    - 책장은 책과 제목의 집합체
    - 자동차는 바퀴, 엔진, 유리의 집합체
    - 차고는 자동차와 주소의 집합체
  - **다른 객체를 캡슐화하지 않는 객체란 존재하지도 않으며 존재할 수도 없다는 사실을 보여줍니다**
  - **부품이 없는 객체는 의미가 없기 때문입니다**
- 상태 없는 객체는 존재해서는 안되고, 상태는 객체의 식별자여야 합니다

</br>

# 캡슐화는 최대 4개 까지

- 왜 "4" 일까요?
- 객체의 식별자는 기본적으로 세계 안에서 객체가 위치한 좌표입니다
- 나의 자동차는 제조사, 모델, 제조년도 라는 특성으로 구성되어 있습니다
  - 이 세가지 특성을 사용하면 이 세계 안에서 제 자동차를 식별할 수 있습니다
- 요점은 4개 이상의 좌표는 직관에 위배된다는 사실입니다
- **세계 안의 객체를 바라보는 우리의 사고방식으로 4개 이상의 요소로 구성된 좌표를 이해하는 것은 너무나도 어렵습니다**
- 반례
  - 자신과 이웃이 동일한 제조사, 모델, 제조년도의 자동차를 가지고 있지만 두 자동차는 다른 자동차가 아닌것 인가?
- 반례의 내용은 맞는 말 입니다
- 하지만 이것은 단순히 실세계 자동차가 객체지향 세계의 자동차 보다 더 복잡하기 때문입니다
- 물론 객체가 자동차를 참조한다고 한다면,
- **속성의 그룹화를 통해 결과적으로 전체 속성들은 객체들로 구성된 트리(tree) 를 구성하게 됩니다**
- 예를 들어
  - 자동차 객체는 타입과 차량 인식번호 (VIN)
  - 타입은 제조사, 모델, 제조년도 로 캡슐화 할 수 있습니다
  - 결과적으로 자동차 객체는 3개의 작은 객체를 포함하게 됩니다
- 최댓값은 "4" 입니다. 더 많은 객체가 필요하다면 클래스를 더 작은 클래스들로 분해해야 합니다
- 그리고 Java 의 결함을 해결하기 위해 `==` 연산자를 사용하지 말고 항상 `equals()` 메서드를 오버라이드하기 바랍니다
