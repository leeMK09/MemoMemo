## 절차지향적

- 데이터 타입이나 의미를 변경해야 할 때, 함께 수정해야 하는 포르시가 증가한다
- 같은 데이터를 프로시저들이 서로 다른 의미로 사용하는 경우가 발생한다
- 데이터 중심으로 설계하게 된다
  - 여러가지를 고려하지 않고 한쪽 방향으로 치우쳐지게 개발하게 된다
  - 예)
    - 무언가를 찾아서 필터링하는 요구사항이 있다고 가정해보자
    - "인덱스를 사용해야 겠다" 는 생각에 사로잡혀서 나중에는 찾을때 "인덱스" 없이는 찾지 못하는 설계가 나온다

</br>

## 객체

- 소리를 제어하는 객체가 있다고 가정하자
- 이 객체가 내부적으로 소리 크기를 어떤 데이터 값으로 보관하는지는 중요하지 않다
- 또한 실제로 객체가 어떻게 소리 크기를 증가시키거나 감소시키는지는 알 수 없다

</br>

## 메시지

- 오퍼레이션의 실행을 요청(`Request`) 하는 것을 메시지(`Message`) 를 보낸다라고 표현한다
- 객체가 `read()` 오퍼레이션을 실행해 달라는 메시지를 전송한다고 생각하면 된다

</br>

## 객체의 책임

- 객체마다 자신만의 책임(`Responsibility`)이 있다는 의미를 갖는다
- 객체의 책임 할당은 "처음부터 바로 결정된 것이 아니다"

**처음에는 프로그램을 만들기 위해 필요한 기능 목록을 정리해야 한다**

- 이게 가장 어려우면서도 중요한 것이 바로 객체마다 기능을 할당하는 과정이다
- 상황에 따라 객체가 가져야 할 기능의 종류와 개수가 달라지기 때문에 모든 상황에 들어맞는 객체-책임 구성 규칙이 존재하는 것은 아니다

중요한 규칙은 "객체가 갖는 책임의 크기가 작을 수록 좋다"

- 객체가 갖는 책임의 크기가 작을수록 객체가 제공하는 기능의 개수가 적다는 걸 의미할 수 있다
- 한 곳에 모두 넣으면 곧 데이터를 중심으로 개발되는 절차 지향 방식과 동일한 구조로 그 안에 여러 데이터를 공유하는 형식으로 구성될 것 이다

따라서, 객체가 갖는 책임의 크기는 작아질수록 객체 지향의 장점인 변경의 유연함을 얻을 수 있게 된다

</br>

## 의존

- 객체를 생성하든 메서드를 호출하든 또는 파라미터로 전달받든 다른 타입에 의존한다는 것은 "의존하는 타입의 변경이 발생할 때 나도 함께 변경될 가능성이 높다는 것"을 뜻한다
- 만약 `AuthenticationHandler` 가 `Authenticator` 클래스를 생성하여 핸들링 한다면 ?
- 이후 요구사항이 생겼을 때 단순 성공, 실패가 아닌 아이디가 틀렸을떄, 비밀번호가 틀렸을 때 등 요구사항이 추가되면 익셉션을 통해서 인증 실패 이유를 구현해야 한다
- 핵심 로직에 의해서가 아닌 외부에 의해서 변경사항이 발생했을 때 외부에만 대응하는 것이 아니라 핵심적인 비즈니스 로직도 변경해야 한다

이때문에 하나의 객체가 변경되면 다른 객체 또한 변경되어야 한다

</br>

## 캡슐화

- 객체 지향의 장점은 한 곳의 구현 변경이 다른 곳에 변경을 가하지 않도록 해준다는데 있다 → 위에서 본 의존 문제를 해결해준다고 ?
- 객체 지향은 기본적으로 캡슐화를 통해서 한 곳의 변화가 다른 곳에 미치는 영향을 "최소화" 한다
- "객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것" 이다
- 이를 통해 내부의 기능 구현이 변경되더라도 그 기능을 사용하는 코드는 영향을 받지 않도록 만들어 준다

</br>

## Getter

```java
if (
    member.getExpireDate() !== null &&
    member.getExprieDate().getDate() < System.currentTimeMillis()
) {
    ...
}
```

문제 상황

- 만약 요구사항이 변경된다면, 만료 여부를 확인하는 코드는 이미 여러 곳에서 사용되는 중이기 때문에, 그 코드들을 모두 찾아서 변경해주어야 한다
- 실수를 범할 가능성이 높아지고, 이는 프로그램의 버그로 직결된다
- 만약 그 사이에 만료 여부 요구사항이 또 변경된다면 ?
- 더불어 관련 개발자도 바뀌었다면 그 사이의 내역을 모르기 때문에, 많은 시간을 들여서 어딜 바꿔줘야 하는지 찾아야 한다

그렇다면 왜 이런 문제가 발생할까 ?

- 그 이유는 바로 데이터를 중심으로 프로그래밍했기 때문이다
- 데이터를 직접적으로 사용하는 코드는 데이터의 변화에 직접적인 영향을 받기 때문에, 요구사항의 변화로 인해 데이터의 구조나 쓰임새가 변경되면 이로 인해 데이터를 사용하는 코드들도 연쇄적으로 수정해 주어야 한다

**캡슐화를 통해 해결해보자**

```java
if (member.isExpired()) {
    ...
}
```

만약 이번에도 서비스를 잘 운영해왔지만 요구사항이 변경되었을 경우에는 ?

```java
public boolean isExpried() {
    ...
}
```

- 이후 요구사항에서 클라이언트의 코드는 수정하지 않는다, `isExpried()` 메서드만 수정했을 뿐
- 기능 구현을 캡슐화하면 내부 구현이 변경되더라도, 기능을 사용하는 곳의 영향을 최소화할 수 있다

</br>

## 캡슐화를 위한 두 개의 규칙

- 객체 지향을 처음 접하는 사람들은 그 동안 몸에 벤 절차 지향 방식 습관 때문에 무심결에 데이터 중심적인 코드를 만들기 쉽다

1. Tell, Don't Ask
2. 데미테르의 법칙 (Law of Demeter)

</br>

## Tell, Don't Ask

- 규칙은 간단하다
- 데이터를 물어보지 않고, 기능을 실행해 달라고 말하는 규칙이다
- 데이터를 읽는 것 (`getter`)은 데이터를 중심으로 코드를 작성하게 만드는 원인이며, 따라서 절차지향적인 코드를 유도하게 된다
- 데이터 대신에 기능을 실행해달라고 명령을 내리면 된다 → 객체에게 만료 여부를 확인해 달라고 해야한다
- 기능 실행을 요청하는 방식으로 코드를 작성하다 보면, 자연스럽게 해당 기능을 어떻게 구현했는지 여부가 감춰진다. 즉, 기능 구현이 캡슐화된 것 이다

</br>

## 데미테르의 법칙

- "Tell, Don't Ask" 규칙을 따를 수 있도록 만들어 주는 또 다른 규칙이다
- "메서드에서 생성한" **객체의 메서드만 호출**
- "파라미터로 받은" **객체의 메서드만 호출**
- "필드로 참조하는" **객체의 메서드만 호출**

```java
if (member.getDate.getTime() < ...) <--- 데미테르 법칙 위반
```

따라서 데미테르의 법칙을 따르려면 `member` 객체에 대한 한 번의 메서드 호출로 변경해 주어야 한다

</br>

## 신문 배달부와 지갑

- 고객 (`Customer`)
  - 지갑 (`Wallet`)
- 신문배달부는 고객에게 요금을 받기 위해 아래처럼 한다

```java
Wallet wallet = customer.getWallet();
if (wallet.getTotalMoney() >= payment) {
    wallet.substractMoney(payment);
} else {
    ...
}
```

이 코드는 동작에 문제는 없다

대신 아래와 같은 방법으로 요금을 받아간다

1. 고객님 지갑 내놓으세요
2. 지갑에 돈 얼마나 있으세요? 1000원 있으세요?
3. 자 이제 지갑에서 돈 좀 제가 빼갈게요~

강도가 아닌 신문배달부 이다

대신 신문배달부는 직접 지갑을 뒤지지 않고 고객이 돈을 지불하는 방식으로 변경해야 한다

```java
public class Customer {

    public int getPayment() {
        ...

        throw new NotEnoughMoneyException();
    }
}
```

데미테르의 법칙을 지키지 않는 전형적인 증상 두가지가 있다

1. 연속된 `get` 메서드 호출
2. 임시 변수의 `get` 호출을 담아서 다시 `get`

</br>
</br>

# ⭐ 객체설계란 ⭐

아래 작업의 반복 과정을 연속적으로 해나가야 한다

1. 제공해야할 기능을 세분화, 그 기능에 알맞은 객체를 찾아나선다
2. 그림 혹은 pseudo code 등 눈에 보이도록 해본다
3. 객체 간에 어떻게 메시지를 주고 받을지 결정한다
4. 개발을 하던 중 막힌다면 다시 1번을 반복한다

기능을 찾으면 이들 기능을 제공할 객체의 후보군을 찾고

각 객체가 어떻게 연결되는지 그려본다 (중요!)

이 과정에서 객체가 기능을 제공할 때 사용할 인터페이스가 도출된다

중요한 사항은

- 객체의 크기는 한 번에 완성되기 보다는 구현을 진행하는 과정에서 점진적으로 명확해진다
- 구현 과정에서 한 클래스에 여러 책임이 섞여 있다는 것을 알게 된다면, 객체를 새로 만들어서 책임을 분리하게 된다

결국 책임이 크다 라는 것의 목적은 변경이다

"변경이 있을때 파급효과가 적으면 책임을 잘 분리한 것 이다"
