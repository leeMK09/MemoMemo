**역할과 추상은 같은 말이 아니다**

</br>

## 역할의 일반적인 의미

- 의미
  - **역할은 특정 컨텍스트나 상황에서 객체나 개체가 수행해야 하는 책임과 행동을 정의합니다**
  - 역할은 일반적으로 인터페이스나 책임의 집합으로 이해될 수 있으며, 특정 실행 가능성을 제공합니다
- 주요 특징
  - 특정 상황에서 객체가 수행해야 할 책임
  - 동적인 개념 → 객체가 여러 역할을 가질 수 있음

예시

```java
interface Worker {
    void work();
}

class Developer implements Worker {
    @Override
    public void work() {
        System.out.println("Writing code.");
    }
}

class Tester implements Worker {
    @Override
    public void work() {
        System.out.println("Testing software.");
    }
}

// 역할 사용
Worker worker = new Developer();
worker.work(); // Output : Wrting code.
```

- 여기서 `Worker` 는 **역할을 정의하며** `Developer` 와 `Tester` 는 **각각 역할을 수행하는 객체입니다**

</br>

## 추상의 일반적인 의미

- 의미
  - **추상은 복잡한 시스템에서 핵심적인 요소나 개념만을 드러내고, 불필요한 세부사항을 숨기는 과정입니다.**
  - 객체 지향 프로그래밍에서는 주로 **추상 클래스나 인터페이스** 로 표현됩니다
- 주요 특징
  - 핵심적인 개념만 표현
  - 세부 구현은 숨기고 상위 수준의 설계를 제공

예시

```java
abstract class Animal {
    abstract void makeSound();
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow");
    }
}

// 추상화 사용
Animal animal = new Dog();
animal.makeSound(); // Output : Bark
```

</br>

## 역할과 추상의 차이점

| **구분**      | **역할**                                                | **추상**                                                    |
| ------------- | ------------------------------------------------------- | ----------------------------------------------------------- |
| **의미**      | 특정 컨텍스트에서 객체가 수행해야 할 행동과 책임.       | 시스템의 복잡성을 줄이고 핵심 개념을 드러내는 설계 원칙.    |
| **목적**      | 객체의 책임을 명확히 하고, 객체 간 협력을 설계.         | 시스템의 세부 구현을 숨기고 상위 수준에서 공통 동작을 정의. |
| **구현 방법** | 인터페이스나 특정 책임을 정의.                          | 추상 클래스 또는 인터페이스를 통해 구현.                    |
| **사용 사례** | 객체가 여러 역할을 가질 수 있는 동적인 시스템에서 활용. | 공통된 개념을 공유하는 객체들의 그룹을 설계.                |

</br>

### 정리

**역할**은 객체가 상황에 따라 수행해야 할 책임과 행동을 정의하는 개념입니다

**추상**은 시스템 설계에서 핵심개념만 드러내고 세부구현을 숨기는 정적 설계 원칙 입니다.

둘은 역할에 따라 연결될 수 있지만 본질적으로 다른 목적을 가지고 사용됩니다.

</br>

---

</br>

**2025.08.20 추가**

</br>

## 객체지향의 추상화

객체지향을 현실 세계의 모방이라고 보는 관점은 객체지향 분석/설계 란 현실 서계에 존재하는 다양한 객체를 모방한 후 필요한 부분만 취해 소프트웨어 객체로 구현하는 과정이라고 설명한다

그 안에는 현실 세계를 모방해서 단순화한다는 의미가 숨어져 있다

여기서 "추상화(abstraction)" 란 실제의 사물에서 자신이 원하는 특성만 취하고 필요 없는 부분을 추려 핵심만 표현하는 행위를 말한다

객체지향 애플리케이션을 분석 및 설계, 구현하기 위해서는 현실 서계를 면밀히 관찰하고 그 안에 존재하는 실제 객체들의 특징을 간추리고 요약해서 소프트웨어 객체로 추상화할 수 있는 능력이 중요하다는 생각이 자리 잡고 있다

**하지만 객체지향 설계는 현실 세계의 단순한 모방이 아니다**

소프트웨어의 상품은 실제 세계의 상품이 하지 못하는 가격 계산과 같은 행동을 스스로 수행할 수 있다

이것은 소프트웨어 객체가 실제 객체를 단순화하거나 추상화한 것이 아니라 특성이 전혀 다른 어떤 것임을 의미한다

</br>
</br>

## 의인화

그렇다면 현실 속의 객체와 소프트웨어 객체 사이의 가장 큰 차이점은 무엇일까?

그것은 현실속에서는 수동적인 존재가 소프트웨어 객체로 구현할 때는 능동적으로 변한다는 것 이다

소프트웨어 객체가 현실 객체의 부분적인 특징을 모방하는 것이 아니라 현실 객체가 가지지 못한 추가적인 능력을 보유하게 된다

현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 의인화(anthropomorphism) 이라고 부른다

소프트웨어 안에 구축되는 객체지향 세계는 현실을 모방한 것이 아니다

현실의 모습을 조금 참고할 뿐 궁극적인 목적은 현실과 전혀 다른 새로운 세계를 창조하는 것 이다

또한 객체지향의 세계는 현실의 추상화가 아니다

오히려 객체지향 세계의 거리는 현실 속의 객체보다 더 많은 특징과 능력을 보유한 객체들로 넘쳐난다

</br>
</br>

## 은유

여러 조언 중 현실 세계의 객체를 자세히 관찰하고 그 중에서 소프트웨어 객체에 적합한 속성만을 추려내는 것 이 객체지향의 설계 특징이라고 이야기하는 조언이 존재한다

안타깝게도 이 조언은 소프트웨어를 개발하는 데 실제적인 도움을 주지 못한다

현실 세계와 객체지향 세계 사이의 관계를 좀 더 정확하게 설명할 수 있는 단어는 "은유(metaphor)" 이다

비록 현실 속의 전화기는 스스로 전화를 걸 수 없다고 하더라도 우리가 익히 알고있는 현실의 전화기라는 개념을 이용해 소프트웨어 객체를 묘사하면 그 객체가 전화를 걸 수 있다는 사실을 쉽게 이해하고 기억할 수 있게 된다

은유는 "표현적 차이(representational gap)" 또는 "의미적 차이(sematic gap)" 라는 논점과 관련성이 깊다

은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 표현적 차이를 줄여 소프트웨어의 구조를 쉽게 예측할 수 있다

따라서 소프트웨어 객체에 대한 현실 객체의 은유를 효과적으로 사용할 경우 표현적 차이를 줄일 수 있으며, 이해하기 쉽고 유지보수가 용이한 소프트웨어를 만들 수 있다

바로 이러한 이유로 모든 객체지향 지침서에서는 현실 세계인 도메인에서 사용되는 이름을 객체에게 부여하라고 가이드하는 것 이다

</br>

> 이상한 나라를 창조하라
>
> 객체지향 설계자로서 우리의 목적은 현실을 모방하는 것이 아니다
>
> 단지 이상한 나라를 창조하기만 하면 된다
>
> 현실을 닮아야 한다는 어떤 제약이나 구속도 없다.
>
> 자신이 창조한 객체의 특성을 상기시킬 수 있다면 현실 속의 객체의 이름을 이용해 객체를 묘사하라
>
> 그렇지 않다면 깔끔하게 현실을 무시하고 자유롭게 자신만의 새로운 세계를 창조하라

> by 객체지향의 사실과 오해
