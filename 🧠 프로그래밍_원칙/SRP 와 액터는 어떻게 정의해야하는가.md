# 객체의 책임에 대해

- 책임이란 단순히 변경가능성을 연관지어 책임을 생각하라고 이야기한다.
- 그러나 책임은 포함하는 문맥에 따라 보는 책임의 관점이 다르다.
  - 일반인의 시점 : 개발자는 프론트도 하고 백엔드도 하고 CI/CD 도 해야하는게 개발자 아닌가 ?
  - 개발자의 시점 : 백엔드는 백엔드 개발자가 프론트는 프론트 개발자가 CI/CD 는 데브옵스가 하는거지 !
- 이를 위해 책임을 좀 더 설명해야할 새로운 개념이 등장하게 된다
- 바로 액터(actor) 이다

</br>

## 🤔 그렇다면 액터 란 ?

어느 책에서 보면

> 단일 책임 원칙에서는 책임이 무엇인지를 이해하려는 노력보다 오히려 액터에 집중해야 한다

라고 이야기한다

여기서 의미하는 액터는..?

**액터**

- "액터 (Actor)"는 **책임의 수혜자나 영향을 받는 주체**를 의미합니다.
- 즉, 어떤 클래스나 모듈이 제공하는 기능이
  1. 누구를 위해 존재하고
  1. 누가 그 기능을 필요로 하거나
  1. 영향을 받는지를 나타내는 개념입니다.
- 이를 통해 책임을 명확히 정의하고 구분하는 데 도움을 줍니다.

즉, SRP에서 책임은 모호하게 정의될 수 있지만, 책임의 대상(액터) 을 생각하면 더 명확해집니다.

예를 들어, "사용자 데이터 처리"라는 책임이 있다면, 이 책임의 액터는 "사용자"가 될 것입니다.

더불어 "모듈화의 기준" 과 "변화의 원인" 을 파악할 수 있습니다.

1. **모듈화의 기준**

   - 특정 액터에 영향을 미치는 기능들은 하나의 클래스나 모듈에 집중되어야 합니다.
   - 서로 다른 액터가 요구하는 기능은 다른 모듈로 분리되어야 합니다.

1. **변화의 원인**
   - 액터는 또한 "변화의 원인"으로 작용합니다. 특정 액터의 요구사항이 변경되면, 그 액터와 관련된 책임만 영향을 받아야 합니다.
   - SRP는 각 클래스나 모듈이 단일한 이유(즉, 단일 액터)에 의해 변경되어야 한다고 주장합니다.

</br>

### 예시로 이해해보기 ❗

**사용자 관리 시스템**

사용자 관리 시스템에서 액터는 크게 두 분류로 생각할 수 있다

1. 관리자

   - 하는일 : "사용자 생성", "사용자 권한 수정", "사용자 삭제"

1. 일반 사용자

   - 하는일 : "자신의 정보 수정", "자신의 정보 조회"

```java
// 관리자용 클래스
class AdminUserService {

    void createUser() {
       /* 사용자 생성 */
    }

    void deleteUser() {
       /* 사용자 삭제 */
    }
}

// 일반 사용자용 클래스
class RegularUserService {

    void viewProfile() {
       /* 계정 보기 */
    }

    void updateProfile() {
       /* 계정 수정 */
    }
}
```

---

## 🤔 그렇다면 액터 == 클라이언트 인건가 ?

액터를 해당 클래스를 사용하는 클라이언트라고 해석할 수도 있습니다.
하지만 액터는 조금 더 넓은 개념으로 코드를 호출하는 클라이언트 뿐 아니라 **그 클래스의 존재와 책임에 영향을 받는 모든 주체를 포함** 합니다

### 액터와 클라이언트의 차이

1. **클라이언트**
   - 클래스의 메서드를 호출하거나 데이터를 소비하는 **직접적인 사용자**입니다.
   - 예를 들어, API 요청을 보내는 사용자나 다른 클래스가 클라이언트에 해당합니다.
2. **액터**
   - 클래스가 제공하는 책임에 의해 **직접적 혹은 간접적 영향을 받는 주체**입니다.
   - 직접 사용하는 클라이언트뿐 아니라, 요구사항을 정의하는 사용자, 비즈니스 도메인, 혹은 시스템 내 다른 구성요소도 포함될 수 있습니다.

### SRP 관점에서 클라이언트 vs 액터

- **클라이언트:** 클래스의 **메서드를 호출하거나 직접적으로 상호작용**하는 대상.
- **액터:** 클래스의 책임으로 인해 **설계, 유지보수, 변화의 영향을 받는 모든 주체**.

즉 액터 == 서비스 사용자 라고 생각하는 것, 우리의 서비스를 사용하는 실질적인 사용자나 비즈니스 요구사항의 주체로 이해하는 것이 더 정확합니다.

더불어 각 액터가 요구하는 기능은 동일하더라도 변경하는 이유가 서로 다르다면 책임을 분리하는 것이 유지보수 측면에서는 더 좋은 설계 방안입니다

반대로, 미래에도 크게 분리될 가능성이 없다면 굳이 클래스를 나눌 필요는 없습니다.
