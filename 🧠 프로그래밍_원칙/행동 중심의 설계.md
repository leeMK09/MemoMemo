</br>

객체지향에서 이야기하는 메시지의 핵심은 "구현(How)"보다 "행동(What)"과 "사용성"에 우선 순위를 두고 객체를 설계하라는 것 이다

이를 단계별로 풀어서 설명하자면 다음과 같다

</br>

## 1. 행동 줌심 설계의 이유

- 객체는 "무엇을 할 수 있는지(행동)"가 가장 중요하다
- 행동 중심으로 설계하면 객체의 역할과 책임이 명확해지고, 재사용성과 유지보수가 쉬워진다
- 예를들어, "User" 객체는 "회원가입"이나 "로그인" 같은 동작을 수행할 수 있다는 식으로, 객체가 어떤 행동을 담당하는지가 설계의 중심이 된다

</br>
</br>

## 2. 구현을 고민하지 말라는 의미

"행동을 설계할때 구현을 고민하지 말라"는 말은 설계 단계에서는 **구체적인 알고리즘이나 기술적 세부사항**에 얽매이지 말라는 뜻 이다

- 이 시점에서는 "이 클래스가 어떤 동작을 할 수 있을까?"라는 큰 그림에만 집중해야 한다
- 예를들어 `register`(회원가입) 메서드를 설계할 때는 **회원정보를 어디에 저장할지**나 **어떤 암호화 알고리즘을 쓸지** 같은 세부사항을 생각하지 않고, 단순히 "회원가입이 가능하다"는 동작을 정의하는 데 집중한다

</br>
</br>

## 3. 구현은 언제 하는가?

구현은 설계가 끝난 후, 행동(인터페이스)이 명확히 정의된 다음 단계에서 한다. 구체적으로 다음과 같은 순서를 따른다

</br>

### (1) 인터페이스 정의

먼저 행동을 정의한다

이것은 "클래스가 어떤 행동을 제공해야 하는지"를 기술하는 작업이다

```java
public interface UserActions {
    void register(String username, String password);

    void login(String username, String password);
}
```

</br>

### (2) 구현 클래스 작성

행동이 정의되었으니, 이제 구현을 작성한다

이때는 행동을 구현하는 데 필요한 알고리즘과 구체적인 기술을 고민해야한다

```java
public class User implements UserActions {

    @Override
    public void register(String username, String password) {
        // 구현: DB에 저장 및 비밀번호 암호화 등
    }

    @Override
    public void login(String username, String password) {
        // 구현: 사용자 인증 로직
    }
}
```

</br>

### (3) 구현은 설계와 분리하여 관리

구현은 어디까지나 인터페이스를 기반으로 작성된다

이렇게 하면 "행동(What)" 과 "구현(How)" 이 분리되어 추후 요구사항이 변경되어도 인터페이스는 그대로 두고 구현만 수정할 수 있다

</br>

### (4) 구현 단계에서의 고민

구현 단계에서는 다음과 같은 질문을 스스로 던지며 작업해야한다!

1. **행동의 목적을 충족하는 가장 효율적인 알고리즘은 무엇인가?**

   - 예시) 회원정보를 저장할 때 해시 테이블을 사용할지, DB를 사용할지

2. **행동이 제공하는 서비스는 안전하고 확장가능한가?**

   - 예시) 로그인 로직에 인증 실패 시도를 제한하는 기능이 필요한가?

3. **추후 변경 가능성을 고려했는가?**

   - 예시) 암호화 방식이 변경될 경우를 대비해 전략 패턴을 사용할까?

</br>
</br>

## 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다

1. 상태를 먼저 결정할 경우 캡슐화가 저해된다

   - 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출되버릴 확률이 높아진다

2. 객체를 협력자가 아닌 고립된 섬으로 만든다

   - 객체가 필요한 이유는 애플리케이션의 문맥 내에서 다른 객체와 협력하기 위해서다
   - 불행하게도 상태를 먼저 고려하는 방식은 "협력하는 문맥" 에서 멀리 벗어난 채 객체를 설계하게 함으로써 자연스럽게 협력에 적합하지 못한 객체를 창조하게 된다

3. 객체의 재사용성이 저하된다

   - 객체의 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나온다 (여러 역할을 가진 객체)
   - 상태에 초점을 맞춘 객체는 다양한 협력에 참여하기 어렵기 때문에 재사용성이 저하될 수밖에 없다

</br>

협력에 참여하는 훌륭한 객체를 양성하기 위한 가장 중요한 덕목은 상태가 아닌 행동에 초점을 맞추는 것 이다

객체는 다른 객체와 협력하기 위해 존재한다

객체의 행동은 객체가 협력에 참여할 유일한 방법이다

설계자로서 우리는 협력의 문맥에 맞는 적절한 행동을 수행하는 객체를 발견하거나 창조해야 한다

결과적으로 우리가 애플리케이션 안에서 "어떤 행동을 원하는가?" "어떤 객체가 적합한가" 를 결정한다

협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야 하는 책임을 의미한다

따라서 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도하게 된다

</br>
</br>

## 행동이 우선이다

객체의 내부 표현 방식이 다르더라도 어떤 객체들이 동일하게 행동한다면 그 객체들은 동일한 타입에 속한다

결과적으로 동일한 책임을 수행하는 일련의 객체는 동일한 타입에 속한다고 말할 수 있다

이것은 객체를 타입으로 분류할 때 사용해야 하는 기준을 명확하게 제시한다

어떤 객체를 다른 객체와 동일한 타입으로 분류하는 기준은 무엇인가?

그 객체가 타입에 속한 다른 객체와 동일한 행동을 하기만 하면 된다. 그 객체가 어떤 데이터를 가지고 있는지는 우리의 관심사가 아니다

그 객체가 다른 객체와 동일한 데이터를 가지고 있더라도 다른 행동을 한다면 그 객체들은 서로 다른 타입으로 분류되어야 한다

결론적으로 객체의 타입을 결정하는 것은 객체의 행동뿐이다

같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다

여기서 동일한 행동이란 동일한 책임을 의미하며, 동일한 책임이란 동일한 메시지 수신을 의미한다

따라서 동일한 타입에 속한 객체는 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 수신하고 이를 처리할 수 있다

다만 내부의 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를 수밖에 없다

이것은 "다형성"에 의미를 부여한다

다형성이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 뜻한다

동일한 메시지를 서로 다른 방식으로 처리하기 위해서는 객체들은 동일한 메시지를 수신할 수 있어야 하기 때문에 결과적으로 다형적인 객체들은 동일한 타입 (또는 타입 계층) 에 속하게 된다

데이터의 내부 표현 방식과 무관하게 행동만이 고려 대상이라는 사실은 외부에 데이터를 감춰야 한다는 것을 의미한다

따라서 훌륭한 객체지향 설계는 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다

이 원칙을 흔히 "캡슐화"라고 한다. 공용 인터페이스 뒤로 데이터를 캡슐화하라는 오래된 격언은 객체를 행동에 따라 분류하기 위해 지켜야 하는 기본적인 원칙이다

데이터가 캡슐의 벽을 뚫고 객체의 인터페이스를 오염시키는 순간 객체의 분류 체계는 급격히 위험에 노출되고 결과적으로 유연하지 못한 설계를 낳는다

"객체를 결정하는 것은 행동이다"

</br>
</br>

## 정리

- **설계 단계**에서는 "행동(What)"에만 집중한다. 이때는 "이 객체가 어떤 동작을 할 수 있을까?"만 고민한다
- **구현 단계**에서는 설계된 행동을 기반으로 효율적이고 안전한 알고리즘과 기술을 선택한다
- 설계와 구현을 분리하면, 역할과 책임이 명확해지고, 유지보수와 확장이 쉬워진다

행동 중심 설계는 객체 지향의 본질을 강조하는 방법으로, 설계 단계에서 구현의 복잡성을 배제함으로써 더 명확하고 재사용 가능한 코드를 작성하는 데 초점을 둔 것 이다
