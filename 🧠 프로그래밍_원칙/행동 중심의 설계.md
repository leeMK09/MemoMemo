</br>

객체지향에서 이야기하는 메시지의 핵심은 "구현(How)"보다 "행동(What)"과 "사용성"에 우선 순위를 두고 객체를 설계하라는 것 이다

이를 단계별로 풀어서 설명하자면 다음과 같다

</br>

## 1. 행동 줌심 설계의 이유

- 객체는 "무엇을 할 수 있는지(행동)"가 가장 중요하다
- 행동 중심으로 설계하면 객체의 역할과 책임이 명확해지고, 재사용성과 유지보수가 쉬워진다
- 예를들어, "User" 객체는 "회원가입"이나 "로그인" 같은 동작을 수행할 수 있다는 식으로, 객체가 어떤 행동을 담당하는지가 설계의 중심이 된다

</br>
</br>

## 2. 구현을 고민하지 말라는 의미

"행동을 설계할때 구현을 고민하지 말라"는 말은 설계 단계에서는 **구체적인 알고리즘이나 기술적 세부사항**에 얽매이지 말라는 뜻 이다

- 이 시점에서는 "이 클래스가 어떤 동작을 할 수 있을까?"라는 큰 그림에만 집중해야 한다
- 예를들어 `register`(회원가입) 메서드를 설계할 때는 **회원정보를 어디에 저장할지**나 **어떤 암호화 알고리즘을 쓸지** 같은 세부사항을 생각하지 않고, 단순히 "회원가입이 가능하다"는 동작을 정의하는 데 집중한다

</br>
</br>

## 3. 구현은 언제 하는가?

구현은 설계가 끝난 후, 행동(인터페이스)이 명확히 정의된 다음 단계에서 한다. 구체적으로 다음과 같은 순서를 따른다

</br>

### (1) 인터페이스 정의

먼저 행동을 정의한다

이것은 "클래스가 어떤 행동을 제공해야 하는지"를 기술하는 작업이다

```java
public interface UserActions {
    void register(String username, String password);

    void login(String username, String password);
}
```

</br>

### (2) 구현 클래스 작성

행동이 정의되었으니, 이제 구현을 작성한다

이때는 행동을 구현하는 데 필요한 알고리즘과 구체적인 기술을 고민해야한다

```java
public class User implements UserActions {

    @Override
    public void register(String username, String password) {
        // 구현: DB에 저장 및 비밀번호 암호화 등
    }

    @Override
    public void login(String username, String password) {
        // 구현: 사용자 인증 로직
    }
}
```

</br>

### (3) 구현은 설계와 분리하여 관리

구현은 어디까지나 인터페이스를 기반으로 작성된다

이렇게 하면 "행동(What)" 과 "구현(How)" 이 분리되어 추후 요구사항이 변경되어도 인터페이스는 그대로 두고 구현만 수정할 수 있다

</br>

### (4) 구현 단계에서의 고민

구현 단계에서는 다음과 같은 질문을 스스로 던지며 작업해야한다!

1. **행동의 목적을 충족하는 가장 효율적인 알고리즘은 무엇인가?**

   - 예시) 회원정보를 저장할 때 해시 테이블을 사용할지, DB를 사용할지

2. **행동이 제공하는 서비스는 안전하고 확장가능한가?**

   - 예시) 로그인 로직에 인증 실패 시도를 제한하는 기능이 필요한가?

3. **추후 변경 가능성을 고려했는가?**

   - 예시) 암호화 방식이 변경될 경우를 대비해 전략 패턴을 사용할까?

</br>
</br>

## 정리

- **설계 단계**에서는 "행동(What)"에만 집중한다. 이때는 "이 객체가 어떤 동작을 할 수 있을까?"만 고민한다
- **구현 단계**에서는 설계된 행동을 기반으로 효율적이고 안전한 알고리즘과 기술을 선택한다
- 설계와 구현을 분리하면, 역할과 책임이 명확해지고, 유지보수와 확장이 쉬워진다

행동 중심 설계는 객체 지향의 본질을 강조하는 방법으로, 설계 단계에서 구현의 복잡성을 배제함으로써 더 명확하고 재사용 가능한 코드를 작성하는 데 초점을 둔 것 이다
