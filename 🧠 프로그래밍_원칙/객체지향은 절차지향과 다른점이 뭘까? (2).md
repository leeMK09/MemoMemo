## 책임과 역할

그런데 절차지향적이라서 책임을 제대로 구분할 수 없는걸까요? → **아닙니다.**

절차지향적 코드를 통해서도 책임을 분할할 수 있습니다 → 함수 단위로 책임을 지면 됩니다

일반적인 함수에도 책임은 존재합니다 → 반드시 객체를 통해서만 책임을 설명할 수 있는 것은 아닙니다

</br>

**그러므로 단순히 책임이 있다고 해서 객체지향적인 코드가 되는 것이 아닙니다!**

**그보다는 책임을 어떻게 나누고 어디에 할당하느냐가 더 중요합니다**

</br>

그렇다면 "책임을 객체에 할당한다" 이 한마디로 객체지향을 설명할 수 있게 되었을까요? → **아닙니다.**

C 언어도 구조체를 만들고 함수를 넣으면 구조체 단위로 책임을 할당할 수 있게 됩니다

따라서 C 언어도 객체지향 언어라고 부를 수 있어야 합니다 → 그런데 우리는 C 언어를 객체지향 언어라고 부르지 않습니다

</br>

C 언어는 왜 객체지향 언어가 아닐까요?

C 언어를 객체지향 언어로 부를 수 없는 이유는 단순히 "class 를 문법적으로 지원하지 않으니까" 같은 이유로 설명할 수 없습니다

</br>

레스토랑 예시에 인터페이스를 추가해보도록 하겠습니다

(예시는 음식 체인 관리 시스템이며 절차지향적인 코드를 객체지향적으로 변경하는 예시 입니다)

- 레스토랑 서비스
  - 레스토랑은 여러개의 지점을 관리한다
- 각 지점에서 주문을 등록
  - 주문에는 상품(음식) 이 복수개로 존재한다
- "매출과 순이익을 계산하는 예시"

```java
interface Calculable {
    long calculateRevenue();

    long calculateProfit();
}
```

```java
public class RestaurantChain implements Calculable { // 역할 구현

    // 역할에 의존하도록 변경
    private List<Calculable> stores;

    @Override
    public long calculateRevenue() {
        long revenue = 0;
        for (Store store : stores) {
            revenue += store.calculateRevenue();
        }
        return revenue;
    }

    @Override
    public long calculateProfit() {
        long income = 0;
        for (Store store : stores) {
            income += store.calculateProfit();
        }
        return income;
    }
}

@Getter
class Store implements Calculable { // 역할 구현

    // 역할에 의존하도록 변경
    private List<Calculable> orders;
    private long rentalFee; // 임대료

    @Override
    public long calculateRevenue() {
        long revenue = 0;
        for (Order order : orders) {
            revenue += order.calculateRevenue();
        }
        return revenue;
    }

    @Override
    public long calculateProfit() {
        long income = 0;
        for (Order order : orders) {
            income += order.calculateProfit();
        }
        return income;
    }
}

@Getter
class Order implements Calculable { // 역할 구현

    // 역할에 의존하도록 변경
    private List<Calculable> foods;
    private double transactionFeePercent = 0.03; // 결제 수수료

    @Override
    public long calculateRevenue() {
        long revenue = 0;
        for (Food food : foods) {
            revenue += food.calculateRevenue();
        }
        return revenue;
    }

    @Override
    public long calculateProfit() {
        long income = 0;
        for (Food food : foods) {
            income += food.calculateProfit();
        }
        return income;
    }
}

@Getter
class Food implements Calculable { // 역할 구현

    private long price;
    private long originCost; // 원가

    public long calculateRevenue() {
        return price;
    }

    public long calculateProfit() {
        return price - originCost;
    }
}
```

주석의 "역할 구현" 과 "역할에 의존하도록 변경" 을 확인

객체에 할당되어 있던 책임을 인터페이스로 분할해서 역할을 만들었습니다

**그리고 객체들이 인터페이스라는 역할을 구현하게 했습니다**

즉 객체지향에서 흔히 말하는 추상화의 원리를 이용해서 "다형성"을 지원하게 한 것 입니다

</br>

여기서 "역할" 의 개념이 나옵니다

엄밀히 말하자면 **객체지향에서는 책임을 객체에 할당하지 않습니다**

**객체를 추상화한 역할에 책임을 할당합니다**

→ 그리고 이는 분명히 C 언어 같은 언어에서는 지원하지 못하는 기능입니다

그래서 객체지향 언어의 특징 중 하나로 다형성이 있는 것 이지요

</br>

**구현과 역할을 분리하고 역할에 책임을 할당하는 과정은 객체지향에서 정말 중요한 부분입니다!**

역할을 이용해서 통신하면 실제 객체가 어떤 객체인지 상관하지 않아도 됩니다

따라서 확장에도 유연해집니다

새로운 요구사항이 생기면 그 역할을 다하는 새로운 구현체만 만들어 주면 되기 때문입니다

</br>

위 예제를 확장해서 이제는 음식점에 추가로 브랜드 상품 (`BrandProduct`) 를 주문할 수 있게 되었습니다

```java
@Getter
class Order implements Calculable {

    // 앞으로 다양한 제품이 들어올 수 있으므로 이름을 변경
    private List<Calculable> items;
    private double transactionFeePercent = 0.03; // 결제 수수료

    @Override
    public long calculateRevenue() {
        long revenue = 0;
        for (Calculable item : items) {
            revenue += item.calculateRevenue();
        }
        return revenue;
    }

    @Override
    public long calculateProfit() {
        long income = 0;
        for (Calculable item : items) {
            income += item.calculateProfit();
        }
        return income;
    }
}

class BrandProduct implements Calculable {

    private long price;
    private double profitPercent = 0.03;

    @Override
    public long calculateRevenue() {
        return price;
    }

    @Override
    public long calculateProfit() {
        return (long) (price * profitPercent);
    }
}
```

역할에 집중하니 코드를 크게 변경하지 않고도 기능을 확장할 수 있게 된 것 입니다

**이는 곧 구체적인 것(객체) 이 아닌 추상적인 것(역할, 인터페이스) 에 집중할 때 유연한 설계를 얻을 수 있게 된다는 뜻** 입니다

객체지향의 본질은 언어나 문법의 특징이 아닌 "역할", "책임", "협력" 이 더 중요합니다

더불어 추상화, 다형성, 상속, 캡슐화도 본질이 아닙니다

이러한 문법적 기능들은 역할, 책임, 협력을 잘 다루기 위해 존재하는 프로그래밍 언어적 기능일 뿐 입니다

따라서 추상적, 다형성, 상속, 캡슐화가 객체지향을 대표하는 기능적인 특징은 될 수 있지만 핵심이 될 수는 없습니다

</br>

더 나아가 객체지향에서 말하는 객체는 **실세계를 반영하지 않습니다**

음식이 스스로 가격을 계산하는 것은 이상하기 때문입니다

따라서 객체지향은 실세계를 반영하는 패러다임이 아닙니다

그보다 오히려 자아를 가진 객체들이 서로 협력하는 방식으로 개발되는 것에 가깝습니다

</br>

더불어 절차지향은 절대 객체지향에 비해 뒤떨어진 방법론이 아닙니다

각 패러다임에는 저마다 장단점이 있으므로 이를 이해하고, 문제를 해결하는 데 어떤 방법을 사용해야 할지는 그때마다 정하는 것 입니다

</br>
</br>

## TDA 원칙

개발자들이 객체지향적인 사고를 하도록 만들 수 있는 가장 쉬운 방법은 TDA 원칙을 지켜가며 개발하는 것 입니다

여기서 TDA 원칙이란 "Tell, Don't Ask" 의 줄임말 입니다 → 말그대로 "물어보지 말고 시켜라" 라는 원칙 입니다

"객체에게 값에 관해 물어보지 말고 일을 시켜라 라는 의미"

```java
long price = product.getPrice();
long mileage = account.getMoney();
if (mileage >= price) {
		account.setMoney(mileage - price);
}
```

위 코드를 TDA 원칙에 적용한다면

```java
if (account.canAfford(product.getPrice()) {
		account.withdraw(product.getPrice());
}

class Account {
		private long money;

		public boolean canAfford(long amount) {
				return money >= amount;
		}
}
```

이렇게 하는 것만으로도 `Account` 클래스로부터 만들어진 객체는 훨씬 능동적으로 바뀝니다

`Account` 클래스는 더 이상 수동적인 데이터 덩어리가 아니며, 이 클래스로 만들어진 객체는 어떤 책임을 가진 객체가 된 것 입니다

"객체를 데이터 덩어리로 보지 말고 객체에게 책임을 위임하라"

그렇다고 객체에게 모든 일을 시킬 수만은 없습니다

Getter 는 분명 필요한 메서드이며, 객체에게 일을 최대한 시키려 해도 어딘가에서 협력을 위해 Getter 를 사용해야 하는 상황이 분명히 나옵니다

`Product` 의 `getProduct()` 메서드는 그 자체로 `Product` 가 가진 "너 (상품) 를 알려줘" 라는 책임 입니다

따라서 이 메서드는 상황에 따라 지울 수 없습니다
