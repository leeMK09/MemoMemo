## Redis Cluster 필요성

- 단일 Redis 는 메모리/CPU/네크워크 한계가 명확하다
    - 트래픽과 데이터가 커지면 스케일 업으로는 비용 대비 효율이 급격히 떨어진다
- Redis Cluster 가 해결하려는 문제들
    - 데이터 용량 한계를 넘기기 위해 키 공간을 분할
    - 쓰기 처리량을 여러 마스터로 분산
    - 장애 시 레플리카 승격으로 가용성을 유지
    - 프록시 없이 클라이언트 리다이렉션(`MOVED`, `ASK`) 으로 고성능을 유지
- Redis Cluster 는 항상 16,384 개의 고정 슬롯만 사용, 확장하여도 슬롯 개수는 늘리지 않음
- 키 해시 후 샤드 수 나눔은 개념을 단순화한 표현이고 실제 Cluster 는 슬롯 추상화를 두어 키 배치 와 키 관리를 분리
- Cluster 는 확장성 + 가용성이 목표이며 강한 일관성은 목표가 아님
- 키 설계는 단순 네이밍 문제가 아닌 원자성 범위, 장애 복구, 리샤딩 내성, 키 접근 패턴을 함께 고려하여 결정해야 하는 작업

**Cluster 키 배치의 동작 원리**

- 키의 슬롯은 `CRC16(key) mod 16384` 로 계산된다
    - `CRC16(key)` 로 키를 16비트 해시값으로 만듦 → 그 값을 16384 로 나눈 나머지를 구함 → 그 결과는 0 ~ 16383 사이의 슬롯 번호가 된다
- 각 마스터는 슬롯 구간 일부를 담당한다
    - 각 마스터는 `0 ~ 16384` 중 일부 슬롯의 소유자 개념
    - 보통 균등 분배를 목표로 하지만 꼭 16384 / 샤드 수 로 딱 맞게 고정되는 건 아님
- 클라이언트는 슬롯 맵을 캐시하고 해당 노드로 직접 요청한다
    - 해당 소유 정보는 클러스터 노드들이 공유, 클라이언트 또한 조회/캐시 하여 맵처럼 사용
- 맵이 오래되면 노드가 `MOVED` (영구 재배치), `ASK` (이동 중 임시) 로 안내한다

**슬롯 존재 이유**

- 단순 `hash(key) mod N(샤드 수)` 는 노드 수가 바뀌면 대부분 키가 재배치되어야 한다
- 반면 Redis Cluster 는 슬롯 수(16384) 가 고정이므로 확장 시 슬롯 일부만 이동시키면 된다
    - 새로운 마스터 추가 → 기존 마스터들이 가진 슬롯 일부를 새 마스터에게 소유권 이전 → 해당 슬롯에 속한 실제 키 데이터도 함께 마이그레이션 → 클라이언트는 `MOVED` / `ASK` 응답을 받고 새 소유자에게 요청
    - 즉 이미 있는 16,384 슬롯 중 일부를 재할당하는 개념
- 노드 수 변화 와 키 해시 공간을 분리해서 리샤딩, 키 재배치 비용을 낮춘 설계

**멀티키 제약과 Hash Tag**

- Cluster 에서 멀티키 연산 (MGET, 트랜잭션, Lua 일부)은 기본적으로 같은 슬롯의 키끼리만 안전하게 처리된다
- 그래서 Redis Cluster 는 키 전체를 해싱하지 않고 키 이름 안에 `{` 와 `}` 가 있으면 그 사이 문자열만 해시한다 → 이를 Hash Tag 라고 부른다
    - `user:{42}:profile` → 해시 태그는 `42`
    - `cart:{42}:items` → 해시 태그는 `42`
    - 두 키 모두 `42` 로 슬롯을 계산하므로 같은 슬롯에 들어간다
    - 그래서 `MGET`, `MULTI` / `EXEC` , Lua 멀티키 접근이 필요한 키들을 같은 태그로 묶어 처리할 수 있다
    - 반대로 `user:42:profile` , `cart:42:item` 같이 중괄호가 없는 형태라면 키 전체가 각각 해시되어 서로 다른 슬롯일 가능성이 크다

</br>

### 트레이드 오프

- 장점
    - 읽기/쓰기 병렬성이 올라가고 수평 확장이 쉽다
    - 노드 장애 시 자동 장애조치로 서비스 지속성이 올라간다
    - 프록시 레이어 없이 직접 라우팅하여 지연을 줄일 수 있다
- 비용/제약
    - 데이터 모델이 슬롯 친화적으로 설계되지 않으면 `CROSSSLOT` 에러가 난다
        - `CROSSSLOT` 에러 : Redis Cluster 에서 한 번의 명령이 서로 다른 슬롯의 키들을 동시에 다루려고 할 때 발생하는 오류
        - `MGET key1 key2` 를 보냈을 때 `key1` , `key2` 슬롯이 다를 때 → 요청한 키들의 슬롯이 다르면 에러
    - 리샤딩 중 `ASK` / `TRYAGAIN` 같은 일시 오류를 클라이언트가 처리해야 한다
    - 복제가 비동기라 장애 시 ACK 된 쓰기 손실 윈도우가 존재하게 된다
    - 운영 복잡도(슬롯 밸런싱, 핫키, 모니터링 등)가 단일 인스턴스보다 크게 증가한다

</br>

### 효율적인 키 관리

**키 네이밍 스키마를 고정**

- `<service>:<entity>:<id>:<field>` 같은 규칙을 선행해야 관측 및 관리, 이관이 쉬워진다

**같이 읽고 같이 쓰는 키만 Hash Tag 로 묶기**

- 무분별한 `{tenantId}` 태깅은 한 슬롯 집중(핫 샤드) 위험을 키운다
- 원칙은 원자성 필요한 최소 단위만 같은 태그로 묶기

**TTL 설계**

- 캐시성 키에는 TTL 을 두고 대량 만료, 캐시 스탬피드를 막기 위해 Jitter 를 추가
- 예: EX 300 + random(0, 30)

**Big Key 회피**

- 한 키에 너무 큰 컬렉션을 몰면 이동/복제/삭제 비용이 비싸지고 지연 발생
- 분할 규칙 (예: 월 단위, 파티션 suffix) 을 두고 키 크기를 제한

**Hot Key**

- 읽기시 트래픽이 몰리는 키는 클러스터 전체가 아니라 한 샤드만 적용한다
    - 앱 로컬 캐시/근접 캐시를 두고 Redis 요청 빈도를 줄임
    - 읽기 전용 복제 노드(`READONLY`) 활용 검토 → stale 허용 필요
    - 값 복제를 의도적으로 여러 키에 분산 저장하여 읽기를 분산 → 쓰기 복잡도 증가

</br>

### 문제 시나리오 해결 전략

**리샤딩 중 주문 결제 멀티키 실패시**

- 간헐적 `TRYAGAIN` 또는 `CROSSSLOT` 발생
- 이유는 키가 이동 중이거나 동일 슬롯 보장이 깨짐
- 해결 방안
    - 결제 트랜잭션 키를 같은 hash tag 로 고정
    - 클라이언트 재시도 시 지수 백오프 + 멱등키 형태로 구현
    - 중요한 작업의 경우 큐 + 아웃박스 형태로 재처리 가능하게 설계

**네트워크 분할 후 일부 쓰기 연산 유실**

- 성공 응답을 받은 데이터가 장애 발생 후 유실
- 이유는 비동기 복제 특성상 승격된 레플리카에 쓰기가 미전파될 수 있음
- 해결 방안
    - 강한 내구성이 필요한 구간의 경우 `WAIT` 또는 `WAITAOF` 를 적용
    - `min-replicas-to-write` 의 설정으로 위험 구간을 줄임
    - 금전 및 정산 데이터는 Redis 단독 처리가 아닌 DB + 이벤트 로그 구조를 검토

**특정 샤드만 CPU 90%**

- 전체 평균은 여유있으나 한 샤드만 지연 급증
- 이유는 hot key, big key, 연산이 오래걸리는 명령
- 해결 방안
    - `--hotkeys`, `--bigkeys`, SLOWLOG 로 원인 키 및 명령을 먼저 특정해야 함
    - 키 분해 및 복제, 접근 패턴 변경으로 집중도를 낮춤
    - 샤드 수를 늘리기 전에 먼저 키 패턴을 고려
