## 리더 기반 복제

### 복제

- 복제(Replication) 는 네트워크로 연결된 여러 노드에 동일한 데이터의 복사본을 유지하는 것을 의미한다

**목적**

- 사용자와 지리적으로 가까운 위치에서 데이터 제공
- 일부 노드 장애에도 서비스를 지속가능하도록 제공
- 읽기 처리량을 확장 및 분산하여 부하 분산 제공

**복제가 어려운 이유**

- 데이터는 계속해서 변경되기 때문에 복제는 어렵다
- 정적인 데이터라면 복제는 쉽지만 쓰기(write) 가 발생하면 복제는 복잡해진다

> 분산 데이터 시스템이 필요한 이유
>
> - 확장성
>   - 데이터 볼륨 증가 / 읽기 및 쓰기 트래픽 증가 / 단일 장비로 감당 불가능한 부하를 여러 장비로 분산
> - 내결함성 & 고가용성
>   - 노드 하나가 장애가 나도 서비스는 지속되어야 한다 / 단일 장애 지점을 제거
> - 지연 시간 감소
>   - 사용자와 지리적으로 가까운 노드를 통해 데이터 전송

</br>

### 리더 기반 복제 (Leader-based Replication) 시 문제점들

- 리더 기반 복제는 가장 널리 사용되는 복제 방식이다
- 리더 (Leader)
  - 마스터(Master) / Primary 라고도 불리며 모든 쓰기 요청을 담당하는 DB 노드를 의미한다
- 팔로워 (Follower)
  - 슬레이브(Slave) / Secondary / Read Replica 라고도 불리며 리더의 변경 로그를 수신받아 데이터를 복제하며, 읽기 요청만 처리하도록 구성할 수 있다
- 흐름
  - 클라이언트 쓰기 요청 → 리더
  - 클라이언트 읽기 요청 → 리더 or 팔로워

**동기식과 비동기식 복제**

- 복제는 크게 동기식 복제와 비동기식 복제가 존재한다
- 동기식 복제
  - 리더가 팔로워의 응답을 기다리는 구조
  - 팔로워가 모두 반영 완료되면 다시 클라이언트에게 성공 응답을 보낸다
  - 강한 일관성을 보장하지만 팔로워 장애가 발생하면 전체 쓰기 작업이 불가능하다 더불어 가용성이 좋지않다
- 비동기식 복제
  - 리더는 팔로워 응답을 기다리지 않고 클라이언트에게 응답을 보낸다
  - 빠른 응답 과 높은 가용성을 가져갈 수 있지만 리더 장애 시 복제되지 못한 쓰기 연산들은 데이터 유실 가능성이 존재한다

**반동기식 (Semi-synchronous)**

- 최소 1개의 팔로워만 리더와 동기식으로 동작하는 구조
- 나머지 팔로워는 모두 비동기로 데이터를 복제
- 현실에게 자주 차용하는 구조이며 이를 통해 최소 2개의 노드에서 최신 데이터가 존재한다는 것을 보장할 수 있다 → 가용성과 내구성의 절충안

**새로운 팔로워 추가시**

- 단순 파일 복사의 경우 쓰기 중 발생한 변경이 누락될 수 있다
- DB 를 모두 잠금하여 팔로워를 추가한다면 고가용성 목표에 위배된다
- 중단 없는 팔로워 설정이 중요한 목표이다
  - 리더의 스냅샷을 생성 → mysql 의 경우 추가 라이브러리 구성필요
  - 스냅샷을 팔로워에게 복사
  - 스냅샷 이후 변경 로그 요청
  - 로그를 모두 적용하면 복제 완료

**장애 복구(failover)**

- 팔로워 장애시
  - 마지막으로 처리된 로그 이후부터 다시 요청하여 복제
  - 일반적으로는 로그 기반으로 빠르게 복구 가능
- 리더 장애시
  - 새로운 리더 선출
  - 클라이언트 쓰기 대상 변경
  - 다른 팔로워들은 새롭게 선출된 리더를 따라가도록 변경
- 자동 장애 복구 구조의 위험성
  - 비동기 복제시 데이터 유실 가능성이 존재한다
  - 리더가 두개 생기는 Split Brain 발생 가능성 존재 → 이전 리더가 새롭게 선출된 리더를 인지하지 못하며 장애 복구시에도 자신이 리더인 것으로 착각
  - 리더 장애 시 일반적으로 타임아웃을 통해 인지하게 되는데 잘못된 타임아웃 설정은 불필요한 장애 복구 과정이 생길 수 있음
  - 그래서 실무에서는 수동 장애 복구 구조를 구성하기도 한다

**복제 로그 구현 방식의 문제점**

- 구문 기반 복제
  - SQL 문 자체를 전파하여 복제를 구성
  - 비결정성 함수 (NOW(), RAND()) 등 사용시 복제된 DB 와 리더 DB 의 데이터가 다를 수 있음
  - 현재는 거의 사용되지 않음
- WAL (Write-ahead log) 기반 복제
  - 디스크 레벨에서 변경 로그를 전송
  - 특정 저장소 엔진과 강한 결합이 발생함
  - 만약 팔로워와 리더의 저장소 엔진 버전이 불일치하다면 문제가 발생할 수 있음
- 논리적 (로우 기반) 복제
  - 행 단위 변경 로그를 전송
  - WAL 과 다르게 논리적으로 로그를 분리하므로 특정 저장소 엔진에 결합이 생기지 않음 → 저장소 엔진과 분리
  - CDC 에 적합한 복제 방식
- 트리거 기반 복제
  - 애플리케이션이 개입할 수 있는 구조로 동작, DB 트리거 혹은 프로시저를 통해 복제 수행
  - 유연하지만 오버헤드가 크다

**복제 지연과 일관성 문제 → 최종적 일관성 구조시**

- 최종적 일관성
  - 잠시 불일치를 허용하는 구조 → 결국 동일한 상태로 수렴됨
- **쓰기 후 읽기 불일치 문제**
  - 내가 쓴 데이터가 바로 보이지 않음
  - 쓰기 직후는 리더 DB 로 데이터 읽기를 수행하도록 해결 혹은 타임스탬프 기반으로 읽을 DB 노드를 판단
- **단조 읽기 (Monotonic Read)**
  - 시간이 거꾸로 흐르는 현상 방지 → 여러번 읽기를 수행하면 고정된 팔로워 DB 에서 읽지 않을 경우가 존재하며 아직 복제되지 못한 팔로워 DB 로 읽기를 수행할 수 있음, 이 경우 첫 번째 요청은 데이터를 조회하지만 두 번째 요청 시 복제되지 않은 팔로워를 읽으면 데이터 조회 실패
  - 한 사용자는 항상 같은 팔로워로 읽도록 변경하여 해결 → 사용자 ID 해싱 및 팔로워 매핑
- **일관된 순서로 읽기**
  - 인과 관계가 있는 순서인 경우 해당 순서를 보장해야 한다 → 채팅의 경우 질문 이후 답변의 순서가 보장되어야 하지만 반대로 순서가 꼬이면 문제가 발생
  - 파티셔닝 환경에서 발생할 수 있는 문제 → 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법을 고려

</br>

참고) 데이터 중심 애플리케이션 설계 5장 - 리더 기반 복제
