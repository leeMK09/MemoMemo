## 파티셔닝

- 파티셔닝의 핵심은 확장성, 데이터 셋의 효율적인 관리를 위한 개념이다
- 데이터 셋이 너무 커졌거나 처리해야할 질의가 너무 많아서 복제만으로는 한계가 생길 때 사용하는 분해 기법 → 파티셔닝 or 샤딩
  - 데이터의 총량 자체를 여러 디스크 혹은 여러 노드에 쪼개어 저장
- 이때 보통은 한 레코드가 정확히 하나의 파티션에만 속한다는 규칙을 둔다 → 그렇게 해야 해당 키가 어디에 있는지를 빠르게 결정할 수 있기 때문

**확장성, 데이터 관리**

- 확장성
  - 파티션을 나누면 파티션별로 데이터를 저장하며 데이터가 여러 디스크로 분산, 질의 부하도 여러 노드로 분산된다
  - 중요한 건 단일 파티션만 읽거나 쓰는 질의가 많을수록 파티셔닝의 효과가 커진다
  - 각 노드는 자기 파티션에 해당하는 요청에만 독립적으로 처리하며 노드를 늘리면 처리량이 비교적 선형적으로 늘어나는 경향있 ㅇ음
  - 반대로 여러 파티션을 동시에 건드리는 조인/집계 같은 질의는 설계가 어려워진다
- 데이터 관리
  - 로그처럼 짧은 기간에 폭발적으로 데이터가 쌓이지만 일정 기간이 지나면 필요없어지는 데이터는 삭제가 정말 비싸다
    - 대량 DELETE 는 인덱스 정리, MVCC 정리, replication log 증가 같은 문제가 발생
  - 파티셔닝은 낡은 범위의 파티션을 통째로 DROP 하는 방식으로 삭제를 대체할 수 있다 → 정리/보관/백업 전략이 단순해진다

</br>

### 키 범위 파티셔닝

- 각 파티션에 연속된 범위의 키를 할당하여 각 값의 범위 사이의 경계를 쉽게 알 수 있고 어떤 키가 어느 파티션에 속해있는지 쉽게 찾을 수 있다

```mysql
PARTITION BY RANGE(YEAR(hired)) (
  PARTITION p0 VALUES LESS THAN (2000),
  PARTITION p1 VALUES LESS THAN (2010),
  PARTITION p2 VALUES LESS THAN (2020),
  PARTITION p3 VALUES LESS THAN MAXVALUE
);
```

1. 클라이언트가 `(hired=2011-03-09, ...)` 로우를 INSERT
2. DB 는 파티션 키 함수를 적용, `YEAR(hired)` 가 2011 이므로 2011 년 구간에 해당하는 파티션을 찾음
3. 실제 저장은 `p2` 라는 물리 파티션(테이블 조각)에만 기록
4. 2011년 데이터만 조회하는 질의는 `p2` 만 읽도록 최적화 가능(파티션 프루닝), 특정 파티션에 모여 관리가 쉬워짐

**장점**

- 정렬된 범위가 유지된다 → 기간 조건이 있는 조회가 매우 효율적

**단점**

- 핫스팟 문제
  - 2025년 데이터가 상대적으로 훨씬 많다면 2025년 파티션으로 트래픽이 몰림
  - 특정 파티션만 쓰기 경쟁이 극심해짐

</br>

### 해시 파티셔닝

- 키를 해시 함수에 넣어 나온 값을 기준으로 파티션을 결정
  - 파티셔닝용 해시 함수는 암호학적으로 강할 필요는 없음 → 보안이 아닌 고르게 섞는 것이 핵심

![hash_partitioning](./img/hash_partitioning.png)

- 레코드의 기본키(또는 파티션 키) 문자열을 해시 함수를 적용해 큰 정수 공간에 매핑
- 그 정수 값을 특정 알고리즘(ex. 파티션 개수로 나눈 나머지) 방식으로 p0 ~ 07 중 하나로 매핑
- 입력 키들을 전체 파티션에 고르게 분산하는 것이 목적

**단점**

- 인접한 키를 분산하는 것이 목적이며 균등 분산은 얻을 수 있지만 범위 질의의 효과적이지 못하다
- 해시 파티셔닝이면 2011년 레코드 데이터 조회시 모든 파티션에 데이터가 흩어져 있을 수 있으므로 결국 모든 파티션을 조회해야 한다

**카산드라 복합 기본키**

- 카산드라는 복합 키를 두고 첫번째 컬럼으로 파티션을 정하는 부분은 해시로 처리하여 분산의 장점을 얻고 나머지 컬럼은 파티션 내부에서 정렬되도록 하여 범위 스캔을 일부 회복한다
- `(user_id, timestamp)` 조회시 먼저 사용자(user_id) 기준으로 데이터가 한 파티션에 모임
- 해당 파티션 안에 `timestamp` 범위로 정렬되어 범위 조회를 빠르게 수행할 수 있음

> 핫스팟 완화 → 키에 랜덤 접미사 붙이기
>
> - 하나의 키로 몰리는 쓰기를 여러 키로 암묵적으로 쪼개는 방식
> - 예를 들어 `hello_user_id` 하나에 쓰기가 몰리면 실제 저장 키를 `hello_user_id_00` ~ `hello_user_id_99` 까지 100개로 쪼개는 식
> - 해시 파티셔닝은 키가 다르면 해시 결과도 달라지므로 다른 파티션으로 갈 가능성이 크기 때문 → 데이터 분산
> - 문제점
>   - 조회시 `..._00` ~ `..._99` 까지 전부 조회한 뒤 합쳐야 하므로 읽기 비용이 커짐
>   - 시스템은 원본 키가 몇 조각으로 쪼개졌는지 알기 위해 메타데이터가 필요함
> - **따라서 모든 키에 적용하는 것이 아닌 정말로 핫 스팟 문제가 발생하는 소수의 키에만 제한적으로 적용하는 것이 현실적**

</br>

### 문서 기준(로컬) 보조 색인 파티셔닝

- 보조 색인과 파티셔닝이 만나면 복잡해진다
  - 기본키로만 접근한다면 특정 키는 어느 파티션에 속한다 라는 것이 명확해지지만 보조 색인(secondary index) 은 기본키처럼 유니크하지 않을 가능성이 있고 속성으로 찾기를 수행하므로 파티션 경계와 잘 맞지 않는다 → 보조 색인은 보통 레코드를 유일하게 식별하는 용도가 아니므로 깔끔하게 대응되지 않는 문제점이 있다

![local_secondary_index_partitioning](./img/local_sidx_partitioning.png)

- 예를 들어 "color=red" 인 자동차를 찾는 과정은 red 자동차들이 모든 파티션에 흩어져 있을 수 있는 문제가 있다
- 이를 먼저 문서 기준(로컬) 보조 색인 파티셔닝을 수행한다면

1. 데이터는 문서 ID(기본키) 기준으로 파티셔닝, 예를들어 문서 ID 0 ~ 499 는 파티션0, 500 ~ 999 는 파티션1 에 저장
2. 각 파티션은 자기 파티션에 저장된 문서만 대상으로 보조 색인을 유지
3. 즉 파티션0의 `color:red` 목록에는 파티션0의 데이터, 파티션1의 `color:red` 목록에는 파티션1의 데이터만 존재
4. 이후 `color=red` 로 검색 시 클라이언트는 red 가 어느 파티션에 있는지 알 수 없으므로 파티션0, 파티션1 모두 물어봐야함 → 이때 각 파티션에 나온 결과를 모으는 방식이 스캐터/개더(scatter/gather)

- 중요한 포인트는 꼬리 지연 시간 증폭
- 파티션을 20개로 늘렸다면 전체 응답은 가장 늦게 응답한 파티션에 의해 결정되는 경향이 크다
  - 스캐터/개더 질의를 병렬로 수행해도 p99 가 좋지 않은 수치로 나올 가능성이 있다
- 그럼에도 사용하는 이유는 단순하기 때문 → 쓰기가 매우 쉽다
- 문서를 하나 추가/수정하면 해당 문서가 속한 파티션 하나에서만 데이터와 인덱스를 같이 업데이트하면 된다

</br>

### 용어 기준(전역) 보조 색인 파티셔닝

![global_secondary_index_partitioning](./img/global_sidx_partitioning.png)

- 인덱스는 모든 파티션의 데이터를 대상으로 하는 하나의 논리 인덱스이다
- 하지만 인덱스를 한 노드에 몰면 병목이 되므로 인덱스 자체를 다시 파티셔닝해서 여러 노드에 분산
- 이때 인덱스 파티셔닝의 기준은 문서 ID 가 아닌 용어(term) 기준
- 예를 들어 `color` 값의 앞글자 범위로 나누거나 용어를 해시로 나눠서 분산 → 색깔 색인은 a 부터 r 까지의 글자로 시작하는 파티션0, s 부터 z 까지의 글자로 시작하는 파티션1

**장점**

- 읽기에 효율적이다
- `color=red` 를 찾을 때 red 용어를 담당하는 인덱스 파티션으로만 조회하면 되며 모든 데이터 파티션을 조회할 필요가 없음

**단점**

- 쓰기
- 문서 하나를 저장할 때 그 문서가 가진 여러 속성들이 서로 다른 인덱스 파티션으로 흩어질 수 있다
- 즉 문서 하나의 쓰기가 여러 인덱스 파티션 쓰기로 확장
- 이때 인덱스를 항상 최신으로 유지하기 위해 분산 트랜잭션 문제 등이 발생
- 현실적으로는 결국 인덱스 갱신을 비동기로 두고 쓰기 직후 인덱스 조회가 최신을 보장하지 않을 수 있는 형태가 됨

</br>

## 파티션 재균형화

- 운영 중에는 새로운 노드가 추가될 수 있고 기존 노드의 디스크/CPU/RAM 을 늘릴 수도 있고 특정 노드가 장애 발생시 데이터 복구를 해야한다
- 이때 한 노드가 담당하던 파티션을 다른 노드로 옮기는 과정이 재균형화(rebalancing)
- 재균형화가 어려운 이유
  - 부하가 균등하게 이루어져야 한다 → 고르게 분산
  - 서비스는 무중단으로 운영되어야 한다
  - 데이터 이동량은 최대한 줄여야 한다 → 이동 자체가 비용

</br>

### mod N(노드 수로 나머지) 방식

- 재균형화시 가장 위험한 사례 → 사용하면 안된다고도 함
- 단순히 키 해시값 % 노드 수로 노드를 정하는 방식
- 그러나 노드 수가 바뀌면 대부분의 키가 다른 노드로 재배치되며 재균형화 때 데이터 이동량이 폭발함

</br>

### 정적 파티셔닝 (파티션 개수 고정)

- 파티션을 20개로 고정
- 노드가 4개일 때는 각 노드가 5개의 파티션을 담당
- 노드가 1개 추가되어 5개로 늘어나면 각 노드는 4개의 파티션을 맡도록 재배치
- 이때 핵심은 키와 파티션 매핑은 그대로이고 파티션에 대한 노드 할당만 바뀐다는 점이다 → 노드가 늘어나도 모든 키가 다 움직이지 않고 일부 파티션만 이동하면 된다
- 재균형화 비용이 mod N 보다 훨씬 예측 가능해진다
- 다만 파티션 개수를 처음에 잘 고려해야함 → 파티션이 너무 크면 이동이 비싸지고 파티션이 너무 많으면 관리 오버헤드가 커짐

</br>

### 동적 파티셔닝

- 파티션 크기를 제한하여 커지면 분할, 작아지면 병합
- 시스템은 파티션이 일정 크기(키 범위 폭, SSTable 크기 등)를 넘으면 파티션을 둘로 쪼갬
- 반대로 너무 작아지면 두 파티션을 합쳐서 관리 오버헤드를 줄임
- 즉 파티션 개수가 데이터 양에 비례하게 된다 → 데이터가 늘면 파티션이 늘어나고 데이터가 줄면 파티션이 줄어드는 방식
- 이 방식은 데이터 규모 변화가 큰 경우, 정적 파티셔닝의 약점인 초기 파티션 개수를 예상하기 어렵다는 점을 보안

> 초기 파티션을 미리 만들어두기 (pre-splitting)
>
> - HBase 나 MongoDB 에서 지원하는 옵션
> - 처음에 하나의 파티션으로 시작하면 초기 쓰기 핫스팟이 심해질 수 있다
> - 즉 성장 초기에 병목을 피하기 위해 미리 파티셔닝하여 쪼개놓는 선택을 제공

**노드 비례 파티셔닝**

- 노드 수에 비례하도록 파티션을 배분
- 시스템마다 구현이 다르지만 목표는 노드가 늘어나면 자연스럽게 파티션 소유 범위가 줄어들어 부하가 분산되게 만드는 것
- 중요한 건 노드 추가 시 전체 데이터 이동을 최소화, 균등 분배를 달성하게 하는 매핑 구조

</br>

## 요청 라우팅

- 재균형화가 일어나면 파티션의 위치가 변경된다
- 파티션 할당의 변경을 어떻게 최신으로 알 수 있을까?
  - 각 노드가 파티션 할당 정보를 스스로 인지, 요청을 받으면 리다이렉트 하는 방식
    - 이 방식은 외부 코디네이션 서비스 의존이 줄지만 노드 구현이 복잡해짐
  - 라우팅 계층, Service Discovery 구조
    - ZooKeeper 같은 외부 서비스를 통해 파티션 할당 정보를 추적, 라우팅 계층이나 파티션 인지 클라이언트는 ZooKeeper 에 있는 정보 구독
    - 파티션 소유자가 변경, 노드 추가/삭제 시 ZooKeeper 는 클라이언트에게 이를 알려 라우팅 정보를 최신으로 유지
  - 클라이언트가 파티션 할당 정보를 캐싱, 직접 올바른 노드로 붙는 방식
    - 이 방식은 라우팅 계층 병목을 줄일 수 있지만 클라이언트가 변경을 빠르게 따라가야 한다

> 병렬 질의 실행
>
> - 파티셔닝의 목적은 부하 분산, 확장성의 목적이 있지만 데이터가 커지면 결국 조인/집계/그룹화 같은 분석의 요구사항도 생긴다
> - 이때 한 노드에서 해당 요구사항을 모두 처리할 수 없으므로 여러 노드에서 병렬로 실행하여 결과를 합치는 방식이 필요해진다 → MPP (대규모 병렬 처리, massively parallel processing)
> - 파티셔닝을 단지 레코드를 쪼개어 저장하는 것 뿐 아니라 질의 실행 계획도 분산시키는 방향으로 고려할 수도 있음
