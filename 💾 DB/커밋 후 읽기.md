## 커밋 후 읽기 (Read Committed)

- 위 트랜잭션 격리 수준은 아래 두 가지를 보장해준다
    - 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다 → 더티 읽기가 없음
    - 데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 된다 → 더티 쓰기가 없음
- 핵심은 커밋되지 않은 변경은 다른 트랜잭션에서 읽히지 않으며 커밋되지 않은 변경 위에 다른 트랜잭션이 덮어쓰지도 못한다는 점이다

</br>

### 더티 읽기 방지

- 더티 읽기 : 어떤 트랜잭션이 아직 커밋하지 않은 값을 다른 트랜잭션이 읽어버리는 현상
- 더티 읽기가 위험한 이유
    - 트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 다른 트랜잭션이 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있다
        - 즉 부분적으로 갱신된 상태에 있는 데이터베이스를 보는 것은 사용자에게 혼란스러우며 다른 트랜잭션들이 잘못된 결정을 하는 원인이 될 수 있다
    - 더티 읽기를 허용하면 트랜잭션이 나중에 롤백될 데이터(실제로는 데이터베이스에 결코 커밋되지 않을 데이터)를 볼 수 있다
- READ COMMITTED 는 이 상황을 막기 위해 커밋되지 않은 값이 다른 트랜잭션의 조회 결과에 포함되지 않도록 만든다

</br>

### 더티 쓰기 방지

- 더티 쓰기 : 두 트랜잭션이 같은 객체를 갱신하려고 할 때 먼저 쓴 값이 아직 커밋되지 않았는데 다른 트랜잭션이 그 값을 덮어써 버리는 현상
- 더티 쓰기가 위험한 이유와 방지
    - 논리적으로 모순된 데이터가 확정될 수 있다
        - 예시) 앨리스와 밥이 동시에 같은 차를 사려고 한다. 자동차 구매는 두 번의 DB 쓰기가 필요하다. 이후 구매자 목록에 구매자가 반영되고 송장을 발송한다.
        - 결과적으로 밥이 구매자 목록에서 해당 차량을 구매했다고 나오지만 송장은 앨리스에게 전송된다 → 밥이 목록 테이블을 최종 갱신, 앨리스가 송장 테이블을 최종 갱신
    - 나중에 롤백될 값을 읽어버릴 수 있다는 점 → 롤백될 값을 근거로 추가 행동을 수행
- READ COMMITTED 는 더티 쓰기를 막기 위해, 한 트랜잭션이 어떤 객체를 수정하고 있는 동안에는 다른 트랜잭션이 그 객체를 수정하여 커밋하도록 허용하지 않는다
- 즉 충돌하는 쓰기가 발생하면 둘 중 하나가 기다리거나 실패하도록 만들어 섞임을 방지한다 → 쓰기 잠금

</br>

### 커밋 후 읽기 구현

- 더티 쓰기 방지를 위해 데이터베이스는 쓰기 잠금(write lock)을 사용
    - 어떤 트랜잭션이 객체를 수정하기 시작하면 데이터베이스는 그 객체에 대한 잠금을 잡고 그 트랜잭션이 커밋하거나 롤백할 때까지 잠금을 유지
    - 이 잠금이 유지되는 동안 다른 트랜잭션은 같은 객체에 대해 충돌하는 쓰기를 완료할 수 없음
- 더티 읽기 방지를 위해 데이터베이스는 커밋된 이전 값을 읽게 만들거나 커밋된 버전만 보이게 만듦
    - 흔히 사용되는 접근이 객체의 버전을 유지하는 방식이며 조회 시점에 커밋된 버전만 반환하도록 제어한다
    - READ COMMITTED 에서는 각 질의가 보는 스냅숏이 질의 단위로 달라질 수 있다는 점이 있다 → 즉 트랜잭션이 같은 쿼리를 두 번 실행했을 때 그 사이에 다른 트랜잭션이 커밋했다면 두 번째 쿼리의 결과는 첫 번째와 달라질 수 있다

</br>

### 비반복 읽기(nonrepeatable read), 읽기 스큐(read skew)

- READ COMMITTED 는 더티 읽기와 더티 쓰기는 방지한다
- 그러나 일관된 관측을 항상 보장해주지는 않는다
    - 대표적인 현상으로는 비반복 읽기 또는 읽기 스큐
- 예시) 두 계좌의 송금
    - 앨리스는 송금 처리를 수행한다 → 계좌 1에서 100 을 빼는 UPDATE 수행, 이어서 계좌 2에 100을 더하는 UPDATE 수행
    - 이후 앨리스는 계좌 1의 잔고를 읽는다, 이때 아직 송금 트랜잭션이 일부만 커밋된 상태 → 송금이 반영된 계좌 1의 감소된 잔고를 조회함
    - 계좌 2의 잔고를 읽는 시점에는 송금 트랜잭션이 다른 부분까지 반영된 상태라고 한다면 → 계좌 2를 조회하는 순간 송금 트랜잭션 커밋 완료, 앨리스는 계좌 2를 조회할 때는 송금이 반영된 계좌 2의 증가된 잔고를 조회하게 됨
    - 즉 다른 시점의 잔고를 보고 착각할 수 있다 → 한 시점에 존재했던 데이터베이스를 조회해야 함
- 위 예시가 바로 비반복 읽기 또는 읽기 스큐라고 한다

</br>

### 스냅숏 격리

- 스냅숏 격리는 트랜잭션이 시작한 시점에 커밋되어 있던 데이터베이스 상태를 트랜잭션이 끝날 때까지 일관되게 보게 만드는 격리 방식
- 즉 트랜잭션이 읽을 때마다 그때그때 최신 커밋을 반영하여 조회하는 것이 아닌 트랜잭션 전체가 동일한 스냅숏을 기반으로 읽는 것
- 어떤 트랜잭션이 시작한 뒤에 다른 트랜잭션이 데이터를 변경하고 커밋하더라도 현재 트랜잭션은 그 변경을 중간에 끼어들어 볼 수 없다
- 현재 트랜잭션은 처음부터 끝까지 같은 시점의 과거 데이터만 일관되게 관측할 수 있다
- 스냅숏 격리는 READ COMMITTED 와 마찬가지로 쓰기시 더티 쓰기를 방지하기 위해 쓰기 잠금을 수행한다
- 그러나 읽을 때는 아무 잠금도 필요 없다
- 핵심 원리는 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다

</br>

### MVCC (multi-version concurrency control, 다중 버전 동시성 제어)

- 스냅숏 격리를 구현하기 위해 데이터베이스는 흔히 MVCC 를 사용한다
- MVCC 는 객체의 여러 버전을 데이터베이스가 함께 유지하는 방식
- 어떤 트랜잭션이 값을 갱신하면 데이터베이스는 기존 버전을 즉시 파괴하지 않고 새로운 버전을 만들고 읽는 트랜잭션은 자신이 볼 수 있는 버전을 선택해서 읽는다
- READ COMMITTED 와 다른 점은 READ COMMITTED 는 읽기는 수행할 때마다 독립된 스냅숏을 사용하고 스냅숏 격리는 전체 트랜잭션에 대해 동일한 스냅숏을 사용한다는 점이다
- 트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 ID(txid)를 할당받는다
- 트랜잭션이 데이터베이스에 데이터를 쓸 때마다 쓰기를 실행한 트랜잭션의 ID가 함께 붙는다
- 트랜잭션이 로우를 삭제하면 실제로 데이터베이스에서 지우지 않고 `deleted_by` 필드를 삭제 요청 트랜잭션의 ID로 설정함으로써 지워졌다고 표시한다
- 나중에 아무 트랜잭션도 더 이상 삭제된 데이터에 접근하지 않는게 확실해지면 데이터베이스의 가비지 컬렉션 프로세스가 지워졌다고 표시한 로우들을 삭제해서 사용량을 줄인다

</br>

### MVCC 환경에서 인덱스(색인)은 어떻게 동작해야 하는가

- 데이터베이스는 보통 두 가지 중 하나(또는 혼합)을 선택한다
- 첫번째 접근
    - 인덱스가 객체의 모든 버전을 가리키게 만들고 조회 시점에 현재 트랜잭션이 볼 수 없는 버전을 걸러내는 방식
    - 이 방식에서는 시간이 지나 어떤 트랜잭션에서도 더 이상 보지 않는 오래된 버전이 생기므로 가비지 컬렉션(또는 vacuum 같은 정리 작업)이 오래된 버전과 그에 대응되는 인덱스 항목을 제거해야 한다
- 두번째 접근
    - 쓰기 시 복사(copy-on-write) 또는 추가 전요(append-only) 구조를 택하는 방식
    - 예를 들어 CouchDB, LMDB 같은 계열에서는 트리의 페이지를 덮어쓰지 않고 변경된 페이지의 새로운 복사본을 만들며, 그 부모 페이지들도 새 자식 버전을 가리키도록 연쇄적으로 복사를 수행
    - 이 방식에서는 쓰기 트랜잭션이 새로운 B-트리 루트를 만들고, 해당 루트 자체가 그 시점의 일관된 스냅숏을 대표하게 만들 수 있다
    - 트랜잭션 ID로 매번 버전을 필터링하는 부담은 줄일 수 있다
    - 그러나 결국 오래된 페이지, 루트가 쌓이므로 컴팩션(compaction)과 가비지 컬렉션이 백그라운드에서 필요해진다
- 또 PostgreSQL 은 같은 객체의 다른 버전들이 동일한 페이지에 함께 저장될 수 있는 경우 인덱스 갱신을 회피하는 최적화를 수행할 수 있다
