## MongoDB 에서 트랜잭션이 가리키는 범위

- MongoDB 는 보통 다중 문서(또는 다중 컬렉션) 트랜잭션을 의미한다
- 그리고 MongoDB 는 이 기능을 Replica Set 또는 Sharded Cluster 에서 제공한다고 명시되어 있다
- MongoDB 는 오래전부터 단일 문서에 대해서는 단일 연산이 원자적으로 적용되도록 설계되어왔다
- 즉 계좌 하나의 잔액 필드를 1 증가시키는 업데이트 처럼 한 문서 안에서 끝나는 갱신은 standalone (단일 노드) 에서도 원자성이 성립한다

**MongoDB 의 입금/출금 예시**

- 입금과 출금이 한 문서 안에서 원자적으로 끝나도록 모델링할 수 있다면 다중 문서 트랜잭션이 없어도 원자성을 얻을 수 있다
- 입금과 출금이 서로 다른 두 문서(계좌 A 문서, 계좌 B 문서) 를 동시에 갱신해야만 도메인 요구사항이 만족된다면 그때 필요한 것이 다중 문서 트랜잭션이다

**가용성(복제), 원자성(트랜잭션) 을 MongoDB 는 묶어서 이야기하는가?**

- 가용성과 원자성은 개념적으로 분리되어있다
- MongoDB 가 둘을 함께 언급하는 이유는 MongDB 가 구현한 다중 문서 트랜잭션이 복제 메커니즘 위에 올려져서 동작하도록 설계되었기 때문이다
- 즉 MongoDB 는 다중 문서 트랜잭션을 단순히 한 프로세스 내부에서만 처리하는 기능보단 Primary 장애/재선출/재시도/분산 환경에서의 커밋 완료 및 롤백 정합성까지 포함해서 서비스 기능으로 제공하려고 했다
- 위 선택으로 인해 아래 요구사항을 충족한다
    - 어떤 트랜잭션이 커밋되었다고 클라이언트에게 응답한 뒤 Primary 가 죽더라도 새로운 Primary 가 올라와서 해당 커밋 사실을 보존한다
    - 어떤 트랜잭션이 커밋 도중 Primary 가 바뀌면 새로운 Primary 가 해당 트랜잭션을 최종적으로 커밋할지 롤백할지 판단할 수 있다
    - 어떤 트랜잭션이 쓰기가 여러 문서/컬렉션/샤드에 흩어져 적용되기 때문에 시스템은 중간 상태를 남기지 않기 위해 트랜잭션 상태를 지속적으로 추적한다
- MongoDB 는 이 트랜잭션 상태를 추적하기 위해 내부적으로 `config.transactions` 같은 시스템 컬렉션을 사용하며 해당 컬렉션이 Replica Set / Sharded Cluster 에서 트랜잭션을 지원하기 위한 핵심 구성 요소로 등장한다

</br>

## MongoDB 는 단일 노드인 경우 트랜잭션을 지원하지 않는다

- 단일 노드라는 의미를 두 가지로 볼 수 있다
    - Standalone
        - 복제 미구성 단일 mongod
        - 이 상태에서는 MongoDB 가 말하는 다중 문서 트랜잭션 기능을 제공하지 않는다 → MongoDB 가 공식적으로 지원 대상으로 잡지 않는다
        - MongoDB 문서는 트랜잭션 지원 배포 형태를 Replica Set / Sharded Cluster 로 제한해서 지원한다
    - 노드 1대, Replica Set 모드로 구동한 단일 멤버 Replica Set
        - 이 경우 물리적으로는 한 대의 노드이지만 MongoDB 입장에서는 복제 프로토콜이 활성화된 배포이다
        - 즉 oplog/세션/트랜잭션 상태 관리 같은 복제 기반 기능이 켜진 상태이므로 많은 기능이 해당 모드에서 동작한다
- 단일 노드에서 트랜잭션이 지원되지 않는 형태는 아래와 같다
    - standalone 모드 (복제 비활성화) 에서는 MongoDB 가 제공하는 다중 문서 트랜잭션 기능을 사용할 수 없다
- 그러나 단일 멤버 replica set (복제 활성화) 으로 띄운다면 노드 1대여도 replica set 배포로 간주되므로 트랜잭션 기능을 사용할 수 있는 경우가 많다

</br>

### 서로 다른 문서를 동시에 바꿔야 하는 모델 (입금/출금, 이체 A 감소 + B 증가)

- MongoDB 도 RDBMS 와 마찬가지로 두 문서 갱신의 트랜잭션 원자성을 지키려면 하나의 트랜잭션으로 묶어서 수행해야 한다

**트랜잭션 동작 흐름**

1. 애플리케이션(클라이언트)은 세션을 만들고 트랜잭션을 시작한다
2. 애플리케이션은 같은 트랜잭션 안에서 계좌 A 문서를 갱신하는 쓰기와 계좌 B 문서를 갱신하는 쓰기를 실행
3. MongoDB 는 해당 트랜잭션의 진행 상태(어떤 세션의 어떤 트랜잭션이 어떤 단계인지) 를 시스템 컬렉션(`config.transactions`) 에 기록하면서 추적한다
4. 애플리케이션이 `commitTransaction` 을 호출하면 MongoDB 는 트랜잭션의 쓰기들이 한꺼번에 커밋된 것처럼 보이도록 커밋을 완료시키거나, 실패 시에는 트랜잭션 전체를 롤백하여 동작한다
5. 이 과정에서 Primary 가 바뀌거나 장애가 발생하더라도 복제 기반의 상태 저장과 재선출 구조 덕분에 MongoDB는 커밋 완료/롤백 정리를 일관되게 처리할 수 있다

**MongoDB 트랜잭션**

- 정리하자면 MongoDB 는 다중 문서 트랜잭션을 Replica Set / Sharded Cluster 라는 배포 형태에서만 제공하도록 제품 설계를 했고 그 설계는 트랜잭션 상태 추적(`config.transactions` 등)과 같은 복제 기반 내부 메커니즘과 연결되어 있다
- MongoDB 는 트랜잭션 정의를 다른 형태로 정의했다
    - MongoDB 의 트랜잭션 정의는 하나의 쓰기가 논리적으로 하나로 묶였다 가 아닌 해당 커밋은 장애가 나도 사라지지 않는다 까지 포함한 개념이다 → 분산 환경에서도 의미가 보존되는 커밋 단위
    - 그러므로 MongoDB 에서는 장애, 재선출, 재시도까지 포함한 커밋의 안정성을 트랜잭션의 필수 조건으로 설계했고 Replica Set 활성화를 해야지 트랜잭션이 적용된다

**ReplicaSet 이 활성화되면 무엇이 달라지는가?**

- 복제 프로토콜이 활성화된다
    - Primary 는 모든 쓰기를 oplog 에 기록
    - oplog 는 단순 로그가 아닌 복제 가능한 커밋 히스토리 개념
- 트랜잭션 상태가 외부화된다
    - MongoDB 는 다음 정보를 `config.transactions` 시스템 컬렉션에 기록한다
        - `session id` / `transaction number` / `prepare` 여부 / `commit` 여부
    - 이 정보는 Primary 의 프로세스 메모리가 아닌 복제 가능한 스토리지 상태로 남는다
- Primary 장애 시 재선출이 가능해진다
    - Primary가 죽으면 Secondary 가 oplog 를 기준으로 해당 트랜잭션은 commit 되었는가를 판단 혹은 prepare 상태에서 죽은건가 등을 판단한다
