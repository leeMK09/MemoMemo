## Instagram ID 

- 인스타그램에서 구성한 유니크 ID 처리 방법 
- 인스타그램의 Unique ID 의 요구사항 
    - 생성된 ID 는 시간별로 정렬할 수 있어야 한다 
        - 값에 대한 부가정보 없이도 ID 를 가지고 정렬할 수 있어야 한다 
    - ID 는 64 비트가 이상적이다 → 작을수록 Redis 와 같은 시스템에서 사용하기 좋다 
    - 시스템은 복잡하지 않아야 한다 

</br>
</br>

### Instagram ID - 솔루션 탐색 

**어플리케이션에서 생성**

- MongoDB 의 ObjectID 와 같이 애플리케이션에서 생성 가능한 아이디 혹은 UUID 를 사용하는 방법 
- 애플리케이션 레벨에서 아이디를 설정하는 장점 
    - DB 에서는 이를 관여할 필요가 없음 
- 장점 
    - 장애 포인트가 거의 없음 
        - DB 에서 생성시에는 DB 가 단일 장애지점이 됨 
    - 앞의 비트를 타임스탬프로 사용하는 경우는 정렬도 가능함 
- 단점 
    - 합리적인 고유성 보장을 위해 더 많은 스토리지 공간을 요구 
        - ObjectID, UUID 같은 것은 일반적인 ID 사이즈보다 더 많은 사이즈를 요구 

</br>

**유니크 ID 생성에 대한 전용 서비스 생성**

- 트위터의 Snowflake 사용 고려 
- 전용 서비스를 사용하면 비교적 더 작은 사이즈의 아이디를 만들 수 있고 시간순 정렬도 가능
- 분산된 시스템을 구성할 수 있어 가용성도 높일 수 있다
- 그러나 별도의 코디네이터 시스템을 요구함 → 복잡도 증가 

</br>

**티켓 서버**

- DB 의 자동 증가 기능을 사용하여 고유성을 만드는 방법 
    - DB 는 친숙하고 예측 가능하며 확장성을 제공 → 내부 개발자가 DB 에 친숙하여 확장성이 좋다고 함 
- 하지만 인스타그램에서는 이 시스템이 결국 병목 지점이 될 것 이라고 판단 
    - 단일 DB 를 사용할 경우 SPOF
- 복수의 DB 인스턴스의 경우 관리 포인트 증가 
- 복수의 DB 인스턴스를 사용하면 시간이 지나면서 DB 가 전해주는 값이 정렬이 가능한지 보장할 수 없음 

</br>

### snowflake 와 비슷하게 자체적으로 ID 구성 

- 총 64 bit 로 구성 
    - 앞의 41 bits : 타임스탬프 (밀리초)
    - 13 bits : 논리적 샤드 ID 
    - 10 bits : AUTO_INCREMENT 값 
- Snowflake 와 유사하지만 추가적인 컴포넌트 대신 PostgreSQL 내부적으로 동작하는 시스템으로 구성 
    - PostgreSQL 의 코드를 수정하여 개발

</br>
</br>

## MongoDB Object ID 

- 구성 
    - 4 bytes : Unix Timestamp (초단위)
    - 5 bytes : 시스템과 프로세스마다 고유한 랜덤값 
    - 3 bytes : 카운터, 시작점은 랜덤값으로부터 시작 
- 애플리케이션 레벨에서 생성 
    - 분산, 수평확장을 전제로 설계되었기 때문에 DB 자체적으로 ID 고유성을 처리할 수 없음 

