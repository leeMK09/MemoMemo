## 조회 트래픽을 고려한 인덱스 설계

- DB 테이블을 설계할 때는 조회 기능과 트래픽 규모를 고려해야 한다
- 예를들어 "카테고리 별로 나눠서 게시글 목록 조회 API" 를 요청하는 게시판이 있다고 가정하자

게시글 테이블

- `category` : 카테고리 컬럼

</br>

**먼저 category 컬럼에 인덱스가 없다면?**

우선 사내 공지용 게시판을 생각해보자

- 회사마다 차이는 있겠지만 매주 1건씩 공지 사항을 등록한다고 하면 1년에 52개 → 10년간 등록해도 총 게시글 수는 520건에 불과하다
- 트래픽 또한 직원 수가 1,000 명이고 게시글이 올라오면 모든 직원이 5분 이내에 글을 읽는다고 한다면 → 초당 게시글 읽기 요청 트래픽은 `6.67 TPS`
- 10년 동안 쌓인 게시글 수가 520 건에 불과하고, 최대 TPS 가 10 미만인 상황에서 조회 성능을 올리기 위해 `category` 컬럼에 인덱슬르 추가할 필요는 없어보인다.
- 데이터 양이 적고 동시에 접속자도 매우 적기 때문에 테이블을 풀 스캔하더라도 성능 문제가 발생하지 않기 때문이다.

</br>

반면 인기 커뮤니티 사이트에서 특정 카테고리에 속한 게시글 목록을 찾기 위해서라면?

- 하루에 5,000 개의 게시글이 등록되고 약 6년이면 1,000 만 건의 데이터가 쌓인다
- 사용자가 게시글 목록을 조회할 때마다 특정 카테고리에 속한 게시글을 찾기 위해 1,000 만 건의 데이터를 비교해야 한다
  - `category` 컬럼에 인덱스가 없다면 → 풀 스캔이 발생한다
- 풀 스캔이 발생하지 않도록 하려면 조회 패턴을 기준으로 인덱스를 설계해야 한다
- 게시판의 경우, 카테고리 별로 게시글 목록을 조회하는 패턴이 존재하므로 `category` 컬럼에 인덱스를 추가해서 조회 성능을 개선할 수 있다

</br>
</br>

## 단일 인덱스와 복합 인덱스

```sql
CREATE TABLE activityLog (
    id BIGINT AUTO_INCREMENT PRIMARY KEY
    userId BIGINT NOT NULL
    activityDate DATE NOT NULL
    activityType VARCHAR(20) NOT NULL
    activityDatetime TIMESTAMP NOT NULL
)
```

고객 센터에서 특정 사용자의 일자별 활동 내역을 조회하는 목적으로 `activityLog` 테이블을 사용한다고 가정해보자

```sql
SELECT * FROM activityLog
WHERE userId = 123 AND activityDate = '2024-07-31'
ORDER BY activityDatetime DESC;
```

위 쿼리는 성능 문제가 없으려면 `userID` 를 포함한 인덱스가 필요하다

여기서 고민할 점은 `activityDate` 를 포함하느냐 하지 않느냐에 대한 것 이다

- 단일 인덱스 : `userId` 만 인덱스로 사용
- 복합 인덱스 : `(userId, activityDate)` 를 인덱스로 사용

**실제 사용자가 어떻게 사용하는지를 먼저 파악한 뒤 그 패턴에 맞게 인덱스를 고려해야 한다**

- 개별 사용자 기준으로 1주일에 하루 정도 방문
- 평균 활동 데이터가 5건이면 1년 활동해야 260건, 이렇게 5년 꾸준히 활동해야 1,500 건이 쌓인다
- 이정도 데이터 건수면 `userId` 컬럼만 사용하는 단일 인덱스를 사용해도 심각한 문제는 발생하지 않는다
- 몇천 건이 안되는 데이터를 비교하는 시간은 짧기 때문이다
- 회원의 활동성이 좋다면 `(userId, activityDate)` 컬럼을 조합한 복합 인덱스 사용을 고려해야 한다

</br>

**activityLog 테이블을 통계로 추출하기 위한 목적으로도 사용할 수 있다**

```sql
-- 특정 일자의 활동 타입별 개수

SELECT activityDate, activityType, COUNT(activityType)
FROM activityLog
WHERE activityDate = '2024-07-28'
GROUP BY activityType;
```

이 쿼리를 실행할 때 전체 데이터를 풀 스캔하지 않으려면 `activityDate` 컬럼을 인덱스로 사용해야 한다

여기서 고민할 점은 `activityType` 컬럼을 인덱스에 포함시키느냐 여부이다

이 경우에는 쿼리 실행 빈도와 실행 시간을 검토해서 포함 여부를 결정할 수 있다

</br>

해당 쿼리를 하루에 한 번만 실행해서 그 결과를 별도 테이블에 저장한다고 가정한다면

쿼리 실행 시간이 30초가 걸려도 문제 될 게 없다 → 하루에 한 번만 실행하기 때문이다

서비스가 급격하게 성장해서 하루에 쌓이는 데이터가 수백만 개에 달하면 상황이 달라진다

이런 상황이 오면 `activityDate` 컬럼과 `activityType` 컬럼을 포함한 복합 인덱스를 적용해야 한다

즉, "데이터 사용 목적에 따라서도 인덱스를 고려해야 한다"

</br>
</br>

## 인덱스는 필요한 만큼만 만들기

- 만약 `userId` 컬럼과 `activityDate` 컬럼을 이용해서 검색하는 쿼리가 존재하고
- 두번째로 여기에 `activityType` 컬럼을 추가로 이용해서 검색한다면
- 두 쿼리를 빠르게 실행하기 위해 다음과 같이 2개의 복합 인덱스를 만들 수 있다
  - `(userId, activityDate)`
  - `(userId, activityDate, activityType)`
- **여기서 두 번째 인덱스가 효과를 발휘하려면 한 사용자가 하루에 만들어 내는 데이터 개수가 조회 성능에 영향을 줄 만큼 많아야 한다** → 특정 날짜(`activityDate`) 에 활동 내역이 아주 많은 경우
- **효과가 적은 인덱스를 추가하면 오히려 성능이 나빠질 수 있다**
- **인덱스는 조회 속도를 빠르게 해주지만 데이터 추가/변경/삭제 시에는 인덱스 관리에 비용이 추가되기 때문이다**
  - 또한 인덱스 자체도 데이터이기 때문에 인덱스가 많아질수록 메모리와 디스크 사용량도 함께 증가한다
- **혹은 새로 추가할 쿼리가 기존에 존재하는 인덱스를 사용하지 않을 때는 요구사항을 일부 변경할 수 있는지 검토해보자**

</br>
</br>

## 선택도를 고려한 인덱스 컬럼 선택

- 인덱스를 생성할 때는 선택도(selectivity) 가 높은 컬럼을 골라야 한다
  - 선택도 : 인덱스에서 특정 컬럼의 고유값 비율을 나타낸다
  - 선택도가 높으면 특정 값이 선택될 확률이 높다는 의미 → 고유값이 적다는 뜻
    - ex. 성별 컬럼 (남/여 2개 값) → 선택도는 높음 (1/2 = 0.5)
  - 선택도가 낮으면 특정 값이 선택될 확률이 낮다는 의미 → 고유값이 많다는 뜻
    - ex. 주민등록번호 컬럼 (행마다 다름) → 선택도는 낮음 (1/수백만)
  - 선택도가 낮은(= 고유값이 많은) 컬럼이 인덱스 효율이 좋습니다
- `gender` 컬럼이 M,F 이고 M 이 50만 개, F 가 50만개 라고 한다면 F 에 대한 조회시 여전히 50만 개의 데이터를 확인해야 한다 → 선택도가 높아서 인덱스 효율이 떨어진다
- **인덱스를 사용할 컬럼을 고를 때 선택도가 항상 낮아야 하는 것은 아니다 → 선택도가 높아도 인덱스 컬럼으로 적합한 상황이 있다**

```sql
CREATE TABLE jobqueue (
    jobId VARCHAR(16) NOT NULL PRIMARY KEY
    status CHAR(1) NOT NULL
)
```

`jobqueue` 테이블의 `status` 컬럼은 `W(대기)`, `P(처리중)`, `C(완료)` 세 값을 갖는다

작업큐 특성상 대부분의 데이터는 `status` 컬럼 값은 `C` 이고 적은 수의 데이터만 `W` 와 `P` 를 갖는다

고유값이 3개 뿐이므로 선택도가 높은 컬럼이다 → 그러나 실제 사용하는 쿼리를 보면 `status` 컬럼은 인덱스로 사용하기에 좋은 컬럼이다

→ 작업 큐를 처리하는 코드는 `status` 컬럼 값이 `W` 인 데이터를 조회하기 때문이다

작업 실행기는 쿼리를 반복해서 (`status = W`) 실행하므로 해당 쿼리가 오래 걸리면 모든 작업 실행이 지연되는 문제가 발생한다

`status` 컬럼에 인덱스가 걸려 있지 않으면 이 쿼리는 풀 스캔을 발생시키므로, 선택도에 상관없이 `status` 컬럼을 인덱스로 추가해야 한다

</br>

> 카디널리티 (Cardinality)
>
> 컬럼에 존재하는 고유값의 개수
>
> 선택도 → (일반적으로 1 / 카디널리티)
