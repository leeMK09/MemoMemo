## 갭락의 기본 작동 원리

InnoDB 는 클러스터링 인덱스나 보조 인덱스를 이용해서 범위 검색을 할 때 해당 범위에 잠금(락)을 거는데,
이때 존재하는 레코드 뿐 아니라, 레코드 사이 간격(갭)에도 락을 건다

현재 DB 가 아래처럼 구성되어 있다고 가정하자

| id  | age |
| --- | --- |
| 1   | 25  |
| 2   | 30  |
| 3   | 40  |

</br>

**트랜잭션 A 수행**

```sql
SELECT * FROM member WHERE age BETWEEN 30 AND 40 FOR UPDATE;
```

InnoDB 동작시

- `age = 30` 의 조건에 해당하는 레코드 락을 잠금.
- `age = 40` 의 조건에 해당하는 레코드 락을 잠금.
- 그리고 그 사이의 빈 공간 (갭) `30 < age < 40` 에도 Gap Lock 을 건다

즉, 31 살 ~ 39 살 데이터는 `INSERT` 도 못하게 막는다

</br>

---

</br>

## 🤔 실제로 어떤 락이 걸리는가 ?

기존 레코드 (30, 40) 에는 `Record Lock` 그 사이 빈 공간에는 `Gap Lock` 잠금

조합하면 → `Next-Key Lock (Record Lock + Gap Lock)` 이라고 불린다

InnoDB 는 쿼리 실행시 "index tree" 를 타면서 읽는 레코드나 갭에 대해 "Lock" 을 거는 함수를 호출한다

이를 통해 MySQL InnoDB 를 사용한다면 `REPEATABLE READ` 격리 수준에서 발생할 수 있는 "팬텀 리드" 현상을 방지할 수 있다.

<br>

---

<br>

## 🤔 갭락 (Gap Lock) 은 어떤 인덱스 타입에 적용되는가 ?

- 클러스터 인덱스 (Primary Key 기반 인덱스)
- 보조 인덱스 (Secondary Index)
  → 둘 다 갭 락이 걸릴 수 있다

근데 주의점이 있다

**갭락이 걸리는 규칙**

| 구분                    | 갭락 발생 여부 | 설명                                                          |
| ----------------------- | -------------- | ------------------------------------------------------------- |
| 클러스터 인덱스 (PK)    | O              | 기본 테이블 데이터도 관리하는 인덱스                          |
| 보조 인덱스 (Secondary) | O              | 보조 인덱스 조건으로 검색할 때도 걸림                         |
| 인덱스 없는 컬럼        | X              | 테이블 풀스캔이 일어나니까 갭락 대신 레코드 락만 걸릴 수 있음 |

</br>

특히 보조 인덱스 시 범위 검색할때 Gap Lock 이 무조건 걸린다

클러스터 인덱스는 필요한 경우 Gap Lock 이 걸릴 수 있다
