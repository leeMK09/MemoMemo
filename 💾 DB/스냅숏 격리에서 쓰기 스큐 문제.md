## 스냅숏 격리

- 스냅숏 격리를 간단히 정리하자면 트랜잭션이 시작되는 순간에 해당 시점의 데이터베이스 상태 스냅숏을 하나 남겨두고 트랜잭션이 끝날 때까지 항상 해당 스냅숏만 보게 만드는 격리 수준이다
    - 스냅숏 격리는 각 트랜잭션 내부의 일관성 보장
    - 그러나 여러 트랜잭션 사이에서 같은 객체를 보고 있다는 보장은 하지 않는다
- [MVCC, 스냅숏 격리에 대해](https://github.com/leeMK09/MemoMemo/blob/main/%F0%9F%92%BE%20DB/%EC%BB%A4%EB%B0%8B%20%ED%9B%84%20%EC%9D%BD%EA%B8%B0.md#%EC%8A%A4%EB%83%85%EC%88%8F-%EA%B2%A9%EB%A6%AC)

</br>

### 스냅숏 격리 중 쓰기 스큐 문제

- 병원 야간 당직 문제
    - 병원은 야간에 최소 1명의 의사가 대기해야 한다 라는 도메인 필수 요구사항이 존재한다
    - 현재 야간 근무지는 앨리스와 밥 총 2명
    - 데이터베이스에는 현재 야간 근무 중인 의사 목록이 저장되어 있음
    - 데이터베이스는 스냅숏 격리를 사용 중

**문제 흐름(트랜잭션 흐름) - 앨리스의 트랜잭션**

1. 앨리스는 퇴근 버튼을 누른다
2. 데이터베이스는 앨리스의 트랜잭션이 시작된 시점의 스냅숏을 하나 생성한다
3. 해당 스냅숏에는 야간 근무자 = 앨리스, 밥(2명) 이 존재한다
4. 앨리스의 트랜잭션은 아직 밥이 남아 있으니 나는 퇴근해도 된다 라고 판단하고 퇴근한다

**문제 흐름(트랜잭션 흐름) - 밥의 트랜잭션**

1. 밥도 거의 같은 시점에 퇴근 버튼을 누른다
2. 데이터베이스는 밥의 트랜잭션 시작 시점 스냅숏을 별도로 생성한다
3. 이 스냅숏에도 역시 야간 근무자 = 앨리스, 밥(2명) 이 존재한다
4. 밥의 트랜잭션 역시 아직 앨리스가 남아 있으니 나는 퇴근해도 된다 라고 판단하고 퇴근한다

**결과**

- 앨리스 트랜잭션은 앨리스 퇴근을 커밋한다
- 밥 트랜잭션은 밥 퇴근을 커밋한다
- 최종 결과는 야간 근무자 0명이다
- 각 트랜잭션은 자기 기준으로는 논리적으로 맞는 판단을 수행했다
- 하지만 두 판단이 합쳐진 결과는 도메인 요구사항을 위반한다
- 이 현상을 쓰기 스큐(write skew)라고 부른다

**SELECT FOR UPDATE 로도 해결되지 않는가?**

- 여기서 SELECT 할때 명시적 락을 수행하면 되지 않을까 라고 생각할 수 있다
- 위 병원 야간 당직 문제에 경우 명시적 락을 통해 해결할 수 있다
- **문제는 잠글 대상이 존재하지 않을 수도 있다는 점이다**
    - 즉 SELECT 시점에 조건에 부합하는 로우가 반환되지 않아서 아무것도 잠글 수 없다

</br>

### 팬텀 문제

- 요구사항) 특정 조건을 만족하는 로우가 존재하지 않을 때만 새로운 로우를 추가할 수 있다

**트랜잭션 흐름**

1. 트랜잭션 A 가 다음 쿼리를 수행한다

```sql
SELECT * FROM reservations
WHERE room_id = 101 AND date = '2024-10-10'
FOR UPDATE;
```

2. 현재 해당 조건을 만족하는 로우가 존재하지 않는다
3. 따라서 데이터베이스는 잠글 로우가 없다
4. 동시에 트랜잭션 B도 동일한 SELECT 를 실행한다
5. 트랜잭션 A 와 B 는 모두 예약이 없구나라고 판단한다
6. 두 트랜잭션은 각각 INSERT 를 수행한다
7. 결과적으로 같은 조건의 로우가 2개 생긴다

**팬텀**

- 트랜잭션 A가 SELECT 를 실행했을 때는 로우가 없었다
- 그런데 트랜잭션 B의 INSERT 로 인해 나중에 로우가 유령처럼 나타났다
- 이처럼 다른 트랜잭션의 쓰기가 내 검색 결과를 바꿔버리는 현상을 팬텀(Phantom)이라고 부른다
- `SELECT FOR UPDATE` 는 이미 존재하는 로우만 잠글 수 있기 때문에 존재하지 않는 로우에 대해서는 도메인 규칙을 보호하지 못한다

</br>

### 팬텀 문제를 해결하는 방법

**1. Serializable 격리 수준**

- Serializable 은 데이터베이스가 해당 트랜잭션들이 직렬 실행된 것처럼 보이도록 강제한다
- 내부적으로는 읽기/쓰기 충돌을 감지해 한 트랜잭션을 강제로 롤백시킨다
- 병원 예시에서는 두 번째 퇴근 트랜잭션이 커밋 시점에 실패한다
- 장점
    - 도메인 무결성을 가장 안전하게 보장한다
- 단점
    - 충돌 시 재시도가 필요하다
    - 성능 비용이 크다

**2. 명시적 잠금 대상**

- 팬텀 문제의 핵심은 잠글 대상이 없다는 점이다
- 그래서 잠글 수 있는 대상을 인위적으로 만들어버리는 전략
- 병원 야근 근무 예시
    - 야간 근무 상태를 나타내는 별도의 테이블이나 로우를 하나 만든다
        - `night_shift_guard` 테이블에 단 하나의 로우를 둔다
    - 퇴근 트랜잭션은 항상 해당 로우를 `SELECT FOR UPDATE` 로 잠근다
    - 그 후 근무자 수를 확인하고 퇴근 여부를 결정한다
- 이렇게 한다면 퇴근 판단 로직 전체가 하나의 잠금 아래에서 실행된다
- 단점
    - 동시성 제어 로직이 애플리케이션 데이터 모델로 나온다
    - 구조가 인워적이며 최후의 수단에 가까움

**3. 원자적 쓰기 연산으로 모델링 변경**

- 쓰기 스큐는 대부분 읽기 → 판단 → 쓰기 구조에서 발생한다
- 이를 하나의 원자적 연산으로 바꾸는 방법을 사용한다

```sql
UPDATE doctors
SET on_duty = false
WHERE id = 'alice'
AND (SELECT COUNT(*) FROM doctors WHERE on_duty = true) > 1;
```

- 조건이 만족되지 않으면 UPDATE 자체가 실행되지 않는다
- 판단과 쓰기가 분리되지 않는다
- 장점
    - 락을 직접 다루지 않아도 된다
- 단점
    - 쿼리가 복잡해진다
    - 모든 도메인 규칙에 적용하기는 어렵다

**4. 갱신 손실 자동 감지**

- 데이터베이스가 쓰기 충돌이나 스큐를 감지하면 트랜잭션을 롤백시킨다
- 애플리케이션은 실패한 트랜잭션을 재시도한다
- PostgreSQL, Serializable, 일부 MVCC 구현이 이 방식을 사용한다

**5. Compare-and-Set**

```sql
UPDATE schedule
SET status = 'OFF'
WHERE doctor_id = 'alice'
AND version = 3;
```

- 마지막으로 읽은 상태가 바뀌지 않았을 때만 갱신을 허용한다
- 누군가 중간에 상태를 바꾸면 UPDATE 가 실패한다

</br>

### 잠금을 통한 팬텀 문제 해결

**2PL(tow-phase locking, 2PL)**

- 2PL 은 락을 거는 횟수가 아닌 락을 다루는 단계의 구조를 의미한다
- 2PL 은 트랜잭션이 락을 다음과 같은 두 개의 단계로만 다룰 수 있도록 제한하는 규칙
    - 성장 단계 (Growing Phase)
        - 트랜잭션은 락을 획득만 할 수 있고, 한 번 획득한 락을 절대 해제하지 않는다
    - 축소 단계 (Shrinking Phase)
        - 트랜잭션은 락을 해제만 할 수 있고, 새로운 락을 절대 획득하지 않는다
- 즉 락을 해제한 순간부터는 다시 락을 얻을 수 없다
- 락을 잡는 시점이 몰려 있는 구간과 푸는 시점이 몰려 있는 구간, 논리적 두 단계가 있는 개념
- 2PL 을 올바르게 적용하면 항상 Serializable 한 실행 결과가 보장된다

**Shared / Exclusive Lock**

- 2PL 에서는 객체(행, 레코드, 페이지 등)에 대해 두 가지 락 모드를 사용한다
    - Shared Lock (S Lock)
        - 여러 트랜잭션이 동시에 읽어도 된다, 하지만 누군가 쓰기를 하려고 하면 모두 사용할 때까지 기다려야 한다
    - Exclusive Lock (X Lock)
        - 나만 읽고 쓴다, 다른 읽기/쓰기는 모두 차단한다
- 즉 읽기 작업 또한 데이터를 보호해야 하는 행위로 간주한다

> MySQL(InnoDB) 와의 차이점
>
> InnoDB 는 기본적으로 MVCC 기반 스냅숏 읽기를 사용한다
>
> - 일반적인 `SELECT` 수행 시 락을 잡지 않는다
>
> **MySQL 의 Shared Lock 은 선택사항**
>
> - `SELECT ... FOR SHARE;` , `SELECT ... LOCK IN SHARE MODE;`
> - 위 쿼리에만 Shared Lock 을 잡는다
> - 해당 데이터를 읽고 트랜잭션이 끝날 때까지 이 데이터가 바뀌지 않기를 원한다는 의미
>     - 누군가 해당 데이터를 쓰려고 한다면 Lock 을 먼저 기다려야 한다

**서술 잠금(predicate lock)**

- Shared/Exclusive Lock 과 비슷하게 동작하지만 특정 객체에 속하지 않고 어떤 검색 조건에 부합하는 모든 객체에 속한다

```sql
SELECT * FROM bookings
    WHERE room_id = 123 AND
        end_time > '2018-01-01 12:00' AND
        start_time < '2018-01-01 13:00';
```

- 트랜잭션 A 가 위 SELECT 질의처럼 어떤 조건에 부합하는 객체를 읽기 원한다면 질의의 조건에 대한 공유 모드 서술 잠금을 획득해야 한다
    - 다른 트랜잭션 B가 그 조건에 부합하는 어떤 객체에 독점 잠금을 갖고 있으면 A는 질의를 실행하도록 허용되기 전에 B가 잠금을 해제하기를 기다려야 한다
- 트랜잭션 A 가 어떤 객체를 삽입, 갱신, 삭제하길 원한다면 먼저 기존 값이나 새로운 값 중에 기존의 서술 잠금에 부합하는게 있는지 확인해야 한다
    - 부합하는 서술 잠금을 트랜잭션 B가 잡고 있다면 A는 진행하기 전에 B가 커밋되거나 어보트될 때까지 기다려야 한다

**색인 범위 잠금(index-range locking)**

- 팬텀 문제는 트랜잭션이 데이터를 읽을 때 항상 하나의 행만 읽는 것이 아니라는 점에 있다
    - 트랜잭션은 종종 어떤 조건을 만족하는 데이터의 집합을 읽고 그 집합의 존재 여부나 개수를 전제로 로직을 수행한다
- 즉 트랜잭션이 조회한 것은 개별 행이 아닌 조건이 정의하는 결과 집합을 잠금해야 한다
- InnoDB 의 경우 테이블 전체를 잠그는 대신 인덱스를 기준으로 논리적인 검색 범위를 보호한다
- 트랜잭션이 특정 조건으로 데이터를 검색하면 데이터베이스는 그 조건이 인덱스 상에서 차지하는 구간을 계산하고 그 구간 안에서 다른 트랜잭션이 새로운 데이터를 끼워 넣지 못하도록 제약을 둔다

**next-key locking**

- next-key locking 은 색인 범위 잠금을 더 구체화한 방식
- 실제로 존재하는 레코드뿐만 아니라 해당 레코드 앞뒤의 빈 간격까지 함께 보호한다
- 이렇게 함으로써 다른 트랜잭션이 중간에 새로운 레코드를 삽입하여 검색 결과를 바꾸는 것을 막을 수 있다
