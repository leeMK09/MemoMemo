## 스냅숏 격리

- 스냅숏 격리를 간단히 정리하자면 트랜잭션이 시작되는 순간에 해당 시점의 데이터베이스 상태 스냅숏을 하나 남겨두고 트랜잭션이 끝날 때까지 항상 해당 스냅숏만 보게 만드는 격리 수준이다
    - 스냅숏 격리는 각 트랜잭션 내부의 일관성 보장
    - 그러나 여러 트랜잭션 사이에서 같은 객체를 보고 있다는 보장은 하지 않는다
- [MVCC, 스냅숏 격리에 대해](https://github.com/leeMK09/MemoMemo/blob/main/%F0%9F%92%BE%20DB/%EC%BB%A4%EB%B0%8B%20%ED%9B%84%20%EC%9D%BD%EA%B8%B0.md#%EC%8A%A4%EB%83%85%EC%88%8F-%EA%B2%A9%EB%A6%AC)

</br>

### 스냅숏 격리 중 쓰기 스큐 문제

- 병원 야간 당직 문제
    - 병원은 야간에 최소 1명의 의사가 대기해야 한다 라는 도메인 필수 요구사항이 존재한다
    - 현재 야간 근무지는 앨리스와 밥 총 2명
    - 데이터베이스에는 현재 야간 근무 중인 의사 목록이 저장되어 있음
    - 데이터베이스는 스냅숏 격리를 사용 중

**문제 흐름(트랜잭션 흐름) - 앨리스의 트랜잭션**

1. 앨리스는 퇴근 버튼을 누른다
2. 데이터베이스는 앨리스의 트랜잭션이 시작된 시점의 스냅숏을 하나 생성한다
3. 해당 스냅숏에는 야간 근무자 = 앨리스, 밥(2명) 이 존재한다
4. 앨리스의 트랜잭션은 아직 밥이 남아 있으니 나는 퇴근해도 된다 라고 판단하고 퇴근한다

**문제 흐름(트랜잭션 흐름) - 밥의 트랜잭션**

1. 밥도 거의 같은 시점에 퇴근 버튼을 누른다
2. 데이터베이스는 밥의 트랜잭션 시작 시점 스냅숏을 별도로 생성한다
3. 이 스냅숏에도 역시 야간 근무자 = 앨리스, 밥(2명) 이 존재한다
4. 밥의 트랜잭션 역시 아직 앨리스가 남아 있으니 나는 퇴근해도 된다 라고 판단하고 퇴근한다

**결과**

- 앨리스 트랜잭션은 앨리스 퇴근을 커밋한다
- 밥 트랜잭션은 밥 퇴근을 커밋한다
- 최종 결과는 야간 근무자 0명이다
- 각 트랜잭션은 자기 기준으로는 논리적으로 맞는 판단을 수행했다
- 하지만 두 판단이 합쳐진 결과는 도메인 요구사항을 위반한다
- 이 현상을 쓰기 스큐(write skew)라고 부른다

**SELECT FOR UPDATE 로도 해결되지 않는가?**

- 여기서 SELECT 할때 명시적 락을 수행하면 되지 않을까 라고 생각할 수 있다
- 위 병원 야간 당직 문제에 경우 명시적 락을 통해 해결할 수 있다
- **문제는 잠글 대상이 존재하지 않을 수도 있다는 점이다**
    - 즉 SELECT 시점에 조건에 부합하는 로우가 반환되지 않아서 아무것도 잠글 수 없다

</br>

### 팬텀 문제

- 요구사항) 특정 조건을 만족하는 로우가 존재하지 않을 때만 새로운 로우를 추가할 수 있다

**트랜잭션 흐름**

1. 트랜잭션 A 가 다음 쿼리를 수행한다

```sql
SELECT * FROM reservations
WHERE room_id = 101 AND date = '2024-10-10'
FOR UPDATE;
```

2. 현재 해당 조건을 만족하는 로우가 존재하지 않는다
3. 따라서 데이터베이스는 잠글 로우가 없다
4. 동시에 트랜잭션 B도 동일한 SELECT 를 실행한다
5. 트랜잭션 A 와 B 는 모두 예약이 없구나라고 판단한다
6. 두 트랜잭션은 각각 INSERT 를 수행한다
7. 결과적으로 같은 조건의 로우가 2개 생긴다

**팬텀**

- 트랜잭션 A가 SELECT 를 실행했을 때는 로우가 없었다
- 그런데 트랜잭션 B의 INSERT 로 인해 나중에 로우가 유령처럼 나타났다
- 이처럼 다른 트랜잭션의 쓰기가 내 검색 결과를 바꿔버리는 현상을 팬텀(Phantom)이라고 부른다
- `SELECT FOR UPDATE` 는 이미 존재하는 로우만 잠글 수 있기 때문에 존재하지 않는 로우에 대해서는 도메인 규칙을 보호하지 못한다

</br>

### 팬텀 문제를 해결하는 방법

**1. Serializable 격리 수준**

- Serializable 은 데이터베이스가 해당 트랜잭션들이 직렬 실행된 것처럼 보이도록 강제한다
- 내부적으로는 읽기/쓰기 충돌을 감지해 한 트랜잭션을 강제로 롤백시킨다
- 병원 예시에서는 두 번째 퇴근 트랜잭션이 커밋 시점에 실패한다
- 장점
    - 도메인 무결성을 가장 안전하게 보장한다
- 단점
    - 충돌 시 재시도가 필요하다
    - 성능 비용이 크다

**2. 명시적 잠금 대상**

- 팬텀 문제의 핵심은 잠글 대상이 없다는 점이다
- 그래서 잠글 수 있는 대상을 인위적으로 만들어버리는 전략
- 병원 야근 근무 예시
    - 야간 근무 상태를 나타내는 별도의 테이블이나 로우를 하나 만든다
        - `night_shift_guard` 테이블에 단 하나의 로우를 둔다
    - 퇴근 트랜잭션은 항상 해당 로우를 `SELECT FOR UPDATE` 로 잠근다
    - 그 후 근무자 수를 확인하고 퇴근 여부를 결정한다
- 이렇게 한다면 퇴근 판단 로직 전체가 하나의 잠금 아래에서 실행된다
- 단점
    - 동시성 제어 로직이 애플리케이션 데이터 모델로 나온다
    - 구조가 인워적이며 최후의 수단에 가까움

**3. 원자적 쓰기 연산으로 모델링 변경**

- 쓰기 스큐는 대부분 읽기 → 판단 → 쓰기 구조에서 발생한다
- 이를 하나의 원자적 연산으로 바꾸는 방법을 사용한다

```sql
UPDATE doctors
SET on_duty = false
WHERE id = 'alice'
AND (SELECT COUNT(*) FROM doctors WHERE on_duty = true) > 1;
```

- 조건이 만족되지 않으면 UPDATE 자체가 실행되지 않는다
- 판단과 쓰기가 분리되지 않는다
- 장점
    - 락을 직접 다루지 않아도 된다
- 단점
    - 쿼리가 복잡해진다
    - 모든 도메인 규칙에 적용하기는 어렵다

**4. 갱신 손실 자동 감지**

- 데이터베이스가 쓰기 충돌이나 스큐를 감지하면 트랜잭션을 롤백시킨다
- 애플리케이션은 실패한 트랜잭션을 재시도한다
- PostgreSQL, Serializable, 일부 MVCC 구현이 이 방식을 사용한다

**5. Compare-and-Set**

```sql
UPDATE schedule
SET status = 'OFF'
WHERE doctor_id = 'alice'
AND version = 3;
```

- 마지막으로 읽은 상태가 바뀌지 않았을 때만 갱신을 허용한다
- 누군가 중간에 상태를 바꾸면 UPDATE 가 실패한다
