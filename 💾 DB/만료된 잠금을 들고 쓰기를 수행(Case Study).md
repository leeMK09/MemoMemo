## 만료된 잠금, 임차권(lease)를 들고 쓰기를 계속하는 실행자

- TTL 기반 락(임차권 락)의 전형적인 문제 흐름
    - 어떤 클라이언트(프로세스)가 공유 자원에 대한 작업을 시작할 때 Redis 나 ZooKeeper 같은 락 서비스에 락 키를 생성하고 TTL 를 건다 → 임차권 획득
    - 그 다음 클라이언트는 락을 획득했다는 사실을 근거로 도메인 로직을 수행하면서 DB 업데이트, 외부 저장소 쓰기 같은 side effect를 발생
- 락이 만료될 수 있다는 전제가 있는 순간 락 서비스가 보장하는 것은 어떤 시점에 락 키가 존재했는가 정도이며 지금 쓰기를 수행하는 클라이언트가 최신 소유자인지 까지는 보장하지 않는다

**예시 (로직이 오래걸림)**

- 클라이언트 1이 TTL 5초로 락을 잡고 도메인 로직을 수행한다
- 그런데 도메인 로직이 5초를 넘게 걸릴 수도 있고 단순히 로직이 느린 경우도 있고 JVM 이라면 Stop-The-World GC 로 몇 초간 멈출 수 있다
    - 혹은 컨테이너의 CPU 스케줄링이 밀리거나 네트워크가 순간적으로 끊기거나
- 이때 락 TTL 이 먼저 만료되어 락이 풀린다
- 락이 풀렸다는 사실을 본 클라이언트 2가 동일한 자원에 대해 락을 획득하고 도메인 로직을 수행하며 쓰기를 발생시킨다
- 그리고 그 이후에 클라이언트 1이 중단에서 회복되어 쓰기를 수행하려고 하면 클라이언트 1은 여전히 자기 로직의 문맥상 락을 잡고 시작한 소유자가 된다
- 결국 저장소(DB, 파일 스토리지, 외부 서비스 등)관점에서는 서로 다른 두 실행자가 같은 자원에 대해 순서가 뒤집힌 쓰기 혹은 중복 쓰기를 일으킬 수 있다

**해결책은 크게 두 갈래로 나뉨**

- 애초에 임차권이 만료되지 않도록 만들자 (혹은 만료될 가능성을 낮추자)
- 만료가 일어나더라도 저장소가 최신 소유자만 쓰기 가능하도록 혹은 최신 소유자를 인지하여 거부하도록 만들자

</br>

### 펜싱 토큰 (Fencing Token)

- 펜싱 토큰은 락이 풀릴 수 있음을 전제로 받아들이고 대신 누가 최신 락 소유자인지를 단조 증가하는 번호로 증명하게 된다
    - 저장소는 번호를 기준으로 최신 번호보다 작은 번호의 쓰기 요청을 거부한다
- 방어하고자 하는 주요 목표는 동시성 보다는 순서가 역전된 쓰기와 오래된 실행자의 쓰기를 방어하는 해결방안
- 예시)
    - 클라이언트 1이 토큰 33을 발급받아 락을 잡고 로직을 수행하지만 중간에 TTL 이 만료되어 클라이언트 2가 토큰 34로 락을 잡아 쓰기를 먼저 성공시키면 저장소는 이미 34를 기억한다
    - 이후 클라이언트 1이 토큰 33으로 쓰기를 시도하면 저장소가 33 번 토큰을 거부하며 충돌이 사라짐
- ZooKeeper 는 트랜잭션 ID(zxid) 나 znode 의 버전(cversion 같은 버전 필드들)이 단조 증가하기 때문에 펜싱 토큰의 속성을 만족시킬 수 있다

**저장소가 토큰 검증을 수행해야 의미있다**

- 펜싱 토큰은 락 서비스만 바꾼다고 해결되는 것이 아닌 쓰기 대상(저장소)이 토큰을 검증하고 거부하는 기능을 가져야만 효과가 있다
- 즉 락은 Redis 로 잡은 후 DB 업데이트로 UPDATE 를 때리는 구조에서는 펜싱 토큰이 있어도 아무 의미가 없다
    - DB 가 토큰이 더 큰 쓰기만 허용한다는 조건부 업데이트가 존재해야 한다

**트레이드 오프**

- 저장소/도메인 모델이 토큰 개념을 받아들여야 하므로 설계가 복잡해짐
    - 쓰기 경로 전체가 토큰을 전달 및 검증하는 프로세스가 존재한다
- 토큰 발급은 항상 증가해야 하므로 발급 지점이 사실상 순서의 기준점이 된다
    - Redis 라면 `INCR` 같은 원자 연산, ZooKeeper 라면 시퀀셜 노드 같은 강한 순서성이 있는 속성을 사용해야 한다
- 저장소가 여러 종류(예시: DB + S3 + 외부 API)로 나뉘어 있다면 각각에 대해 토큰 검증으로 오래된 쓰기를 거부할 수 있는 방법을 마련해야 한다
    - 외부 API 는 지원이 안될 수 있으며 그 경우 저장소 앞단에 프록시/게이트 서비스를 두고 거기서 토큰 검증

</br>

### 락 자동 연장

- 락이 만료되기 전에 계속 연장해서 애초에 다른 실행자가 락을 잡지 못하게 한다
    - Redis 기반 분산락의 `watchdog` 패턴
- 목적은 정상적으로 살아있는 프로세스가 작업 중인데 TTL 이 짧아서 락이 먼저 풀려버리는 상황을 해결하려는 것
    - 작업이 길어질 수 있는 환경에서 TTL을 보수적으로 길게 잡는 대신에 작업이 진행되는 동안 주기적으로 TTL을 갱신하여 락이 유지되도록 한다

**근본적인 해결책은 아니다**

- 자동 연장은 프로세스가 중간에 멈추는 패턴에는 도움이 되지만 프로세스가 길게 멈추고 (STW, 네트워크 단절, 프로세스 중단 등) 다시 살아나는 경우에는 연장 스레드 자체도 같이 멈추거나 갱신에 실패할 경우가 있다
- 즉 자동 연장은 충돌 확률을 낮춰 주지만 만료 후 뒤늦은 쓰기를 구조적으로 금지하지는 못한다 → 신뢰가 중요한 서비스의 경우 자동 연장 + 펜싱 토큰을 같이 사용하기도 함

**트레이드 오프**

- 자동 연장은 락 갱신 트래픽과 구현 복잡도가 늘어남
- 갱신 주기가 너무 짧으면 Redis 혹은 다른 외부 서비스에 부담을 주고 너무 길면 멈춤 상황에서 만료를 제때 감지하지 못함
- 운영 환경의 프로세스 정지/지연을 완전히 통제할 수 없음

</br>

### 낙관적 동시성 제어 (버전/조건부 업데이트)

- 동시에 두 실행자가 업데이트를 시도할 수 있다는 것을 전제로 저장소에서 내가 읽었던 상태가 아직도 최신일 때만 업데이트를 적용
    - `WHERE id = ? AND version = ?`
- TTL 락에서 문제는 오래된 실행자가 뒤늦게 쓰기를 성공시킬 수 있기 때문이며 버전 기반 업데이트는 오래된 실행자의 업데이트를 저장소가 충돌로 감지하고 실패시킬 수 있다

**트레이드 오프**

- 버전 관리가 중요하다
    - 저장소가 버전 체크를 제공해야 하며 충돌 시 이후 프로세스가 존재해야 한다 (재시도, 실패 등)

</br>

### 단일 작성자로 직렬화

- 구조를 바꿔서 공유 자원에 대한 쓰기를 하나의 직렬 스트림으로 만든다
- 락 기반은 여러 실행자가 동시에 경쟁하는 모델이며 싱글 라이터의 경우 경쟁 자체가 없어지고 특정 키에 대한 업데이트는 항상 같은 소비자(또는 같은 파티션, 같은 컨슈머 그룹)에서만 처리된다 의 구조로 설계
    - Kafka를 사용하면 자원 ID를 키로 해서 같은 키는 같은 파티션으로 가게 만들고 컨슈머 그룹에서 그 파티션을 소비하는 단 하나의 컨슈머가 해당 자원의 쓰기를 전담

**트레이드 오프**

- 지연이 늘어날 수 있다
    - 즉시 쓰기 대신 큐 적재 후 처리의 구조일 수 있으며 실시간 응답이 어려운 구조가 될 수 있음
- 특정 키에 대한 핫스팟이 생기면 파티션 병목

</br>

### 멱등키 + 중복 저장 방지(Idempotency)

- TTL 락 문제는 같은 연산이 두 번 적용되는 것 또한 문제일 수 있다
    - 예를 들어 재고 차감, 포인트 차감, 쿠폰 사용 등
- 이때는 락을 믿기보다 저장소에 해당 요청이 이미 처리되었다를 기록하고 같은 요청이 다시 오더라도 두 번째부터는 무시하는 식의 방식이 효과적이다

**트레이드 오프**

- 멱등키 설계
    - 멱등키를 보고 요청이 동일하다는 것을 판단할 수 있어야 한다
    - 저장소가 해당 키를 기준으로 원자적으로 처리 여부 기록 + 상태 변경을 묶어야 한다
    - DB 라면 유니크 제약조건, Redis 의 SETNX
- 기록 비용과 저장 공간
