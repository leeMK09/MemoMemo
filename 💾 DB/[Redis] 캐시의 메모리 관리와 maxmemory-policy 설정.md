레디스에서 키에 만료 시간을 설정해 데이터가 자동으로 삭제되도록 함으로써 데이터의 수명을 관리할 수 있다

하지만 레디스의 메모리는 제한적이기 때문에 모든 키에 만료 시간을 설정하더라도 너무 많은 키가 저장되면 메모리가 가득 차는 상황이 발생할 수 있다

레디스에서는 데이터의 최대 저장 용량을 설정하는 maxmemory 설정과 이 용량을 초과할 때의 처리 방식을 결정하는 maxmemory-policy 설정값을 사용해 메모리를 관리한다

**maxmemory-policy 의 설정값 과 동작방식**

## Noeviction

- 기본값은 noeviction
- 레디스에 데이터가 가득 차더라도 임의로 데이터를 삭제하지 않고 더 이상 레디스에 데이터를 저장할 수 없다는 에러를 반환하는 설정값
- 데이터의 관리를 캐시에서 맡기지 않고, 애플리케이션 측에서 관리하겠다는 것을 의미한다
- 데이터가 가득 차더라도 캐시 내부적 판단으로 데이터를 삭제하는 것이 위험하다고 판단될 때 이 옵션을 사용할 수 있다
- 일반적으로는 레디스를 캐시로 사용할 때 권장하지 않는 설정값이다

</br>
</br>

## LRU eviction (Least-Recently Used)

- 레디스에 데이터가 가득 찼을때 **가장 최근에 사용되지 않은 데이터부터 삭제하는 정책**
- **최근에 액세스되지 않은 데이터는 나중에도 액세스될 가능성이 낮을 것이라는 가정을 전제하고 있다**
- 캐시는 나중에 사용될 가능성이 있는 데이터를 유지하는 것을 목표로 하기 때문에 효율적인 메모리 관리 방법이다
- LRU 알고리듬을 이용한 두 가지 설정값
  - **volatile-lru**
    - **만료 시간이 설정되어 있는 키에 한해서 LRU 방식으로 키를 삭제** 즉, 이미 만료 시간이 설정되어 있는 키는 언젠가 삭제될 키라는 것을 의미하기 때문에 이런 키 중 가장 오래 사용되지 않은 키를 삭제하는 방식
    - 하지만 이 또한 장애 상황을 유발할 수 있는데, **만약 레디스 내부에 저장된 키에 모두 만료 시간이 지정되어 있지 않다면 이는 `noeviction` 상황과 동일하다** 삭제할 수 있는 키가 하나도 없기 때문에 레디스에 더 이상 데이터를 저장할 수 없어 에러를 반환한다
  - **allkeys-LRU**
    - 이 방식은 **모든 키에 대해 LRU 알고리듬을 이용해 데이터를 삭제하기 때문에 적어도 메모리가 꽉 찼을 때 장애가 발생할 상황은 방지할 수 있다**
    - 레디스 공식 문서에는 레디스를 캐시로 사용할 경우 잘 모르겠다면 allkeys-LRU 방식을 사용하기를 권장한다

</br>
</br>

## LFU eviction (Least-Frequently Used)

- 레디스에 데이터가 가득 찼을 때 **가장 자주 사용되지 않은 데이터부터 삭제하는 정책**이다
- **자주 사용되지 않은 데이터는 나중에도 액세스될 가능성이 낮을 것이라는 가정을 전체하고 있다**
- 키를 액세스하는 패턴에 따라 우선순위가 유동적으로 바뀐다는 점에서 특정 케이스에서는 LRU 보다 더 효율적일 수 있다
  - 키가 오랫동안 사용되지 않았더라도 과거에 자주 액세스했던 키라면 나중에도 자주 사용될 수 있다는 가정하에 우선순위가 높아지게 된다
- LFU 또한 두가지 설정값을 가지고 있다
  - **volatile-lfu**
    - 만료시간이 설정되어 있는 키에 한해서 LFU 방식으로 키를 삭제한다
    - `volatile-lru` 에서와 마찬가지로 특정 상황에서는 장애를 유발할 가능성이 존재한다
  - **allkeys-lfu**
    - 모든 키에 대해 LFU 알고리듬을 이용해 데이터를 삭제한다

> 레디스에서 키를 삭제하기 위해 사용되는 LRU, LFU 알고리듬은 모두 근사 알고리듬으로 구현된다
> 이는 메모리가 가득 찬 상황에서 가장 오래 사용되지 않거나 자주 사용되지 않은 키를 정확하게 찾아내것이 불필요하게 CPU 및 메모리 리소스를 소비할 수 있기 때문이다
> 일반적으로 저장된 데이터는 특정 상황에서 삭제될 수 있다는 가정하에 이 알고리듬이 동작한다
> 따라서 정확한 키를 계산하는 것보다 특정 키를 근사치로 찾아내 효율적으로 데이터를 삭제하는 방법으로 동작한다
>
> LRU → "최근에 사용 안 된 건 앞으로도 당분간 안 쓰일 것 이다" 라는 가정
> LFU → "사용 빈도가 낮은 건 앞으로도 잘 안 쓰일 것이다" 라는 가정
>
> LRU 를 완전히 정확하게 구현하려면 매 접근마다 순서를 업데이트해야 해서 비용이 큼 → 근사치로 알고리듬 구현
> LFU 또한 모든 접근에 대해 정확한 사용 횟수를 유지하면 무거움 → 근사치로 알고리듬 구현

</br>
</br>

## RANDOM eviction

- 레디스에 저장된 키 중 하나를 임의로 골라내 삭제한다
- 삭제될 키 값을 계산하지 않아도 된다는 점에서 레디스의 부하를 줄여줄 수 있는 방법이다
- 하지만 **이 방법은 랜덤으로 데이터를 삭제하기 때문에 나중에 사용될 수도 있는 데이터를 삭제할 가능성이 높아진다**
  - 이럴 경우 데이터 저장소에서 다시 데이터를 갖고 와서 캐시에 넣어주는 작업이 오히려 불필요함을 유발할 수 있다
- 레디스는 LFU, LRU 에 대해 근사 알고리듬을 사용하기 때문에 데이터를 찾는 데에 큰 리소스를 사용하지 않는다
- 따라서 굳이 레디스의 부하를 줄이기 위한다는 이유로 random eviction 을 사용하는 것은 권장하지 않는다
- random eviction 의 두가지 설정값
  - **volatile-random**
    - 만료 시간이 설정되어 있는 키에 한해서 랜덤하게 키를 삭제한다
  - **allkeys-random**
    - 모든 키에 대해 랜덤하게 키를 삭제한다

</br>
</br>

## volatile-ttl

- 만료 시간이 가장 작은 키를 삭제한다
- 즉, 삭제 예정 시간이 얼마 남지 않은 키를 추출해 해당 키를 미리 삭제하는 옵션이다
- 이 알고리듬 또한 앞선 LRU, LFU 한 키를 골라내는 알고리듬과 마찬가지로 근사 알고리듬을 이용한다
- 따라서 저장된 모든 키를 스캔하면서 만료 시간을 비교하지 않아도 되므로 간단하게 키를 찾아낼 수 있다
