## 네임드 락 (MySQL 기준)

```sql
SELECT GET_LOCK('order:123', 10);
```

- 테이블이 아닌 문자열 이름에 락을 건다
- 트랜잭션 락이 아닌 커넥션 단위 락이다
- `RELEASE_LOCK('order:123')` 또는 커넥션 종료 시 해제

</br>

### 커넥션 단위 락

- MySQL 의 네임드 락은 락을 획득한 DB 커넥션(Session)에 귀속된다
- 락의 소유자는 트랜잭션이 아닌 커넥션(Session) 이다 즉, 락의 생명주기는 커넥션의 생명주기이다
- 락을 해제하지 않아도 커넥션이 끊어지면 자동으로 해제된다

**같은 요청인데 락이 걸리지 않은 상황**

```text
요청 A → DB-Connection-1 에서 GET_LOCK → 로직 수행 → DB-Connection-2 에서 RELEASE_LOCK 실행 (다른 커넥션에서 수행하므로 실패)
```

- 락은 DB-Connection-1 에서 선점을 하지만 RELEASE_LOCK 은 DB-Connection-2 에서 수행하므로 실패하며 락은 DB-Connection-1 이 반환될 때까지 유지된다
- 커넥션이 살아있는 동안 락이 계속 유지된다

</br>

## 네임드 락의 범위

- 네임드 락은 DB 인스턴스 전체(Global) 범위이다
- 특정 테이블, 특정 Row, 특정 DB(schema) 와는 상관없다
- 해당 MySQL 인스턴스 전체에서 유일하다
- 즉 같은 MySQL 인스턴스에 커넥션이 있고 락 이름이 같다면 충돌된다

</br>

## 네임드 락은 어디에 저장되는가

- 네임드 락은 InnoDB 테이블에 저장되지 않는다
- MySQL 서버 내부의 메모리 구조에서 관리된다
- **주기적으로 polling 하는 구조가 아니다**
- 락 테이블 스캔 같은건 없고 락 획득 시점에만 내부 mutext 경쟁이 발생한다
- MySQL 네임드 락은 디스크(InnoDB 테이블)에 저장되지 않고 MySQL 서버 프로세스 내부 메모리에서 관리되는 락이다

</br>

## 네임드 락은 어디서 부하가 발생하는가?

- **DB 커넥션 점유**
  - 락을 잡은 동안 커넥션을 붙잡고 있기 때문에 커넥션 풀 고갈의 위험이 존재함
- **단일 MySQL 인스턴스에 집중**
  - 모든 락 요청이 한 DB 로 몰리며 scale-out 불가능
- **동시 경쟁시 mutext**
  - 내부적으로 결국 하나의 동기화 포인트가 필요

</br>

## 네임드 락 특징

- 장점
  - 구현이 간단하며 추가적인 인프라 구성이 필요없다
  - 트랜잭션과 독립적으로 동작한다 → 롤백에 영향이 없음
  - 단일 DB 기반 시스템에서는 안정적
- 단점
  - 글로벌 락 (단일 MySQL 인스턴스라면 같은 이름인 경우 락에 대한 경쟁을 시도)
  - DB 커넥션 점유
  - 분산 시스템에 부적합

</br>

## Redis 락

```text
SET lock:order:123 value NX PX 3000
```

- Redis key 하나가 락의 개념을 가지고 있음
- TTL 처리 및 여러 서버 및 프로세스에서 접근이 가능함

</br>

## Redis 분산락 범위

- Redis 인스턴스(또는 클러스터) 단위
- MySQL 네임드 락보다 훨씬 글로벌로 사용

</br>

## Redis 분산락의 문제

- **락 경쟁 발생시 retry/spin lock**
- **TTL 만료 설계 및 락 선점 실패시 락 유실 및 중복처리 가능성 존재**

</br>

## Redis 분산락 특징

- 장점
  - DB 에 대한 부하가 없음
  - 분산 환경에 적합하며 빠르다, TTL 같은 안전장치가 존재한다
- 단점
  - 구현 복잡도가 있고 TTL 설정 실수 혹은 중복 락 선점등의 문제가 발생할 것을 고려해야한다
  - Redis 가 장애날 경우 대체방안을 고려해야한다
