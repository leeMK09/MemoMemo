## 몽고 DB 의 배열 필드의 멀티키 (multikey) 인덱스

- MongoDB 에서 어떤 필드에 인덱스를 만들었는데 해당 필드 값이 배열이라면 MongoDB 는 해당 인덱스를 자동으로 멀티 키 인덱스로 취급한다
- 즉 문서 하나가 `tags: ["a", "b", "c"]` 처럼 여러 값을 가지면 MongoDB는 한 문서에 대해 인덱스 엔트리를 배열 원소 개수만큼 만들어서 저장한다
    - 배열 값을 담는 필드에 인덱스를 만들면 MongoDB 가 자동으로 multikey 를 설정한다
- 이 구조를 역인덱스(inverted index) 라고 부른다 - 값(토큰) → 그 값을 가진 문서 ID 로 빠르게 매핑을 수행하는 인덱스 테이블

예시)

| 토큰(token) | 도큐먼트 id |
| ----------- | ----------- |
| Apple       | [1, 2, 3]   |
| 2025        | [1]         |
| 맥북        | [1]         |
| 에어        | [2]         |
| 13          | [3]         |
| M4          | [3]         |

- 중요한 건 배열의 각 원소를 인덱스 키로 쪼개서 문서를 가리키는 엔트리를 여러 개 만든다는 점이다
- 그래서 결과적으로 원소 값 하나로 해당 원소를 포함한 문서들을 빠르게 찾는 패턴이 가능해진다
- 또한 배열이 스칼라 배열이든(문자/숫자), 임베디드 도큐먼트 배열이든 멀티키 인덱스를 만들 수 있고 배열 안에 같은 값이 여러 번 반복되면 인덱스에는 그 값 엔트리를 중복으로 넣지 않는다고 설명한다

**중첩 (배열 안의 배열) 과 데이터가 큰 경우 멀티키에 문제가 되는 이유**

- 멀티 키의 핵심 비용은 인덱스 엔트리 수가 문서 수가 아닌 배열 원소 수에 비례해서 커진다는 점이다
- 문서가 1천만 건이어도 배열이 평균 3개면 인덱스 엔트리가 대략 3천만 개가 되고 평균 100개면 10억 개로 증가한다
- 이렇게 되면 인덱스 저장 공간이 커지고 해당 인덱스를 효율적으로 쓰려면 작업 집합이 메모리에 더 많이 올라와야 하므로 캐시 미스가 증가하고 지연이 커질 수 있다
- 그리고 쓰기 비용이 커진다.
    - 문서 한 건 insert/update 가 배열 원소 개수만큼 인덱스 구조를 갱신해야 하므로 배열이 큰 문서는 쓰기 비용이 커진다
- 특정 쿼리는 인덱스로 후보를 찾는 것까지만 빨라지고 최종적으로 도큐먼트를 가져와 추가 필터링을 해야 하면서 병목이 남을 수 있다
    - 예를 들어 배열 전체가 정확히 같은지 비교하는 쿼리는 인덱스로는 배열의 첫 요소를 포함한 후보를 찾고 나머지는 도큐먼트를 읽어 필터링한다고 되어있다
- 중첩을 실무에서 조심해야 하는 이유는 배열의 원소 수가 늘어나면 인덱스 엔트리 폭증이 더 쉽게 발생하고 쿼리 플랜이 인덱스를 타더라도 결과적으로 너무 많은 후보를 만들기 쉬워서 성능이 불안정해지기 때문이다
- 설계적으로 배열을 크게 만들지 말고 질의 패턴에 맞춰 분리 및 정규화하여 컬렉션으로 분할하는 모델링 선택지도 존재한다

**복합 인덱스에서 두 개의 배열 필드를 같이 인덱싱하지 않는 이유**

- MongoDB 는 복합키 인덱스(compound multikey index)에서 인덱스에 포함된 필드들 중 배열이 될 수 있는 필드는 문서당 최대 1개만 허용된다
- 따라서 인덱스 스펙에 배열 필드가 2개 이상이면 복합 멀티키 인덱스를 만들 수 없다
- 이유는 복합 인덱스는 일반적으로 `(A, B)` 형태로 정렬된 키 공간을 만든다
- 그런데 A도 배열이고 B도 배열이면 문서 하나가 사실상 `(a1, b1) (a1, b2) ... (a2, b1) ...` 처럼 카다시안 곱 형태로 엄청난 조합을 만들어낼 수 있고 그렇게 되면 인덱스 엔트리 폭증이 통제 불가능해집니다
- MongoDB 는 이 폭발을 구조적으로 막기 위해 복합 인덱스 안에 배열 필드 2개를 금지한 것 이다
- 추가로 이미 그런 복합 멀티키 인덱스가 존재하는 상태에서 두 필드가 모두 배열이 되는 문서를 insert 하려고 하면 insert 자체가 실패한다
