## 직렬성 스냅숏 격리 (Serializable Snapshot Isolation, SSI)

- 간단히 정리하자면 낙관적 동시성 제어 메커니즘의 형태 → 스냅숏 격리를 기반으로 한다
- 트랜잭션이 데이터를 읽을 때, 다른 트랜잭션의 쓰기와 서로를 방해하지 않도록 설계된 격리 방식
- 이 방식에서 트랜잭션은 자신이 시작한 시점의 스냅숏을 기준으로 데이터를 읽으며 그 읽기 과정에서는 어떤 락도 획득하지 않는다
- 핵심 의도는 읽기 트랜잭션이 쓰기 트랜잭션을 기다리게 만들지 않고도 높은 동시성을 확보하자는 것에 있다
    - 트레이드 오프는 읽기가 락으로 보호되지 않는다는 것, 트랜잭션이 과거의 상태를 전제로 판단을 내리는 것
- SSI 의 문제는 단순히 데이터가 바뀌었다가 아닌 트랜잭션이 믿고 의사결정을 내린 전제가 트랜잭션이 커밋되는 시점에도 여전히 참인가를 판단해야 한다

</br>

### 오래된 MVCC 읽기 감지

- 트랜잭션이 스냅숏 격리 하에서 읽은 데이터가 읽는 시점에는 논리적으로 일관되어 있었지만 트랜잭션이 커밋되는 시점에는 더 이상 그 전제가 성립하지 않는 상황을 감지한다는 것을 의미한다
- 트랜잭션 A 가 시작되었을 때 데이터베이스는 특정 조건을 만족하는 데이터가 두 개 존재한다고 가정
    - 트랜잭션 A 는 이 사실을 스냅숏을 통해 읽고 그 결과를 기반으로 조건을 만족하는 데이터가 충분하므로 하나를 제거해도 된다라는 판단을 내림
    - 그러나 트랜잭션 A 가 아직 종료되지 않은 상태에서 트랜잭션 B가 동일한 조건을 기준으로 또 하나의 데이터를 제거하고 커밋해 버린다면, 트랜잭션 A가 믿고 있던 충분한 개수가 존재한다 는 전제는 더 이상 참이 아니게 된다
    - 중요한 것은 트랜잭션 A가 읽기를 수행하던 당시에는 이 문제를 감지할 방법이 전혀 없다는 것이다
    - 스냅숏 격리 하에서 읽기는 항상 일관된 과거를 보여주기 때문에 트랜잭션 A는 자신이 읽은 데이터가 곧 무효가 될 것이라는 사실을 알 수 없다
- 그래서 위 문제를 해결하기 위해 데이터베이스는 읽기 시점이 아니라 커밋 시점에 이 상황을 다시 돌아보며 트랜잭션 A가 의사결정을 내릴 때 사용한 읽기 결과가 현재의 데이터 상태와 양립 가능한지 검사한다
- **이 검사에서 트랜잭션 A가 읽은 전제가 이후의 쓰기들로 인해 깨졋다 라고 한다면 데이터베이스는 이를 오래된 MVCC 읽기로 판단하고 트랜잭션 A를 abort 시킨다**

</br>

### 과거의 읽기에 영향을 미치는 쓰기 감지

- 트랜잭션 A가 먼저 특정 조건을 만족하는 데이터 집합을 읽고, 그 결과를 바탕으로 판단을 내린 상태라고 가정
    - `SELECT ... WHERE shift_id = 1234 AND on_call = true;`
    - 이때 데이터베이스는 단순히 A가 어떤 행을 읽었다는 사실만 기억하지 않고 A가 어떤 조건을 기준으로 데이터를 읽었다는 사실을 내부적으로 기록한다 → 해당 트랜잭션은 `shift_id = 1234 AND on_call = true` 범위를 읽었다는 것을 내부적으로 기억함
    - 이후 트랜잭션 B가 실행되면서 트랜잭션 A가 읽었던 조건에 부합하는 데이터를 새로 삽입하거나 기존 데이터를 수정하려고 시도한다
    - 이 쓰기 작업은 단순히 새로운 데이터를 추가하는 행위처럼 보이지만 데이터베이스의 관점에서는 과거에 누군가가 이 조건을 전제로 판단을 내렸는데 그 판단의 결과를 바꿀 수 있는 쓰기로 해석하게 된다
    - 이 시점에서도 데이터베이스는 즉시 트랜잭션 B를 막지 않는다
    - SSI 의 철학은 읽기와 쓰기를 즉각적으로 차단하지 않는 것이며 대신 데이터베이스는 이 쓰기는 과거의 읽기와 충돌 가능성이 있다는 사실을 기록하게 된다
    - 이후 두 트랜잭션 중 하나가 커밋을 시도할 때 데이터베이스는 이 기록들을 종합하여 트랜잭션 간의 의존 관계를 분석한다
    - 그 결과 트랜잭션 B의 쓰기가 트랜잭션 A의 판단 전제를 무효화시키는 것으로 판명되면 데이터베이스는 직렬 실행으로는 이 결과를 설명할 수 없다고 판단하고 둘 중 하나를 abort 시킨다
- 이 과정을 설명할 때 사용하는 표현이 바로 과거의 읽기에 영향을 미치는 쓰기 감지이다

</br>

### 왜 이런 감지가 필요한가

- 이 두가지 감지가 필요한 이유는 스냅숏 격리가 기본적으로 쓰기 스큐를 허용하는 격리 수준이기 때문이다
- 쓰기 스큐란 서로 다른 데이터를 수정한 트랜잭션들이 각각은 올바른 판단을 했음에도 불구하고 전체 결과를 보면 비즈니스 규칙이나 불변 조건이 깨지는 현상을 의미한다
- SSI 는 쓰기 스큐를 허용하지 않기 위해 같은 데이터를 썻는가가 아니라 같은 전제를 공유했는가를 기준으로 트랜잭션을 검사한다
- 오래된 MVCC 읽기 감지와 과거의 읽기에 영향을 미치는 쓰기 감지는 바로 이 전제가 참인지를 판단하기 위한 장치이다

</br>

### 직렬성 스냅숏 격리(SSI)의 비용

- SSI 는 읽기 시점에 락을 사용하지 않기 때문에 읽기 트랜잭션이 많고 쓰기 충돌이 상대적으로 적은 환경에서는 매우 높은 성능과 확장성을 제공한다
- 특히 긴 읽기 트랜잭션이 많은 분석성 워크로드에서는 전통적인 2PL 기반 직렬화보다 훨씬 유리하다
- 그러나 SSI 는 모든 충돌을 사전에 막지 않고 사후에 감지하며 트랜잭션을 abort 시키는 방식을 택한다
- 이로 인해 트랜잭션이 오래 실행될수록 그리고 읽은 범위가 넓을수록 나중에 abort 될 가능성이 점점 커진다
- 즉 이미 많은 계산과 로직을 수행한 뒤에 커밋 단계에서 실패할 수 있다는 비용을 감수해야 한다
- SSI 의 성능 특성은 짧고 빠른 트랜잭션이 많을수록 유리하고 읽고 오래 고민한 뒤 쓰는 트랜잭션에는 불리하다
