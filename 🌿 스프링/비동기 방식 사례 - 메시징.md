## 비동기 → 메시징 방식

- 메시징 방식의 이점은 크게 두가지가 있다
- 첫 번째 이점은 두 시스템이 서로 영향을 주지 않는다는 점이다
  - A 시스템에서 B 시스템을 직접 연동했다면 A 시스템에 트래픽이 몰릴 경우 B 시스템의 처리량을 초과하는 문제가 발생하게 된다 → 시스템 B 에 성능 저하가 발생하고, 그 성능 저하는 다시 시스템 A 까지 영향을 미친다
  - 그러나 메시징 시스템을 사용하면 시스템 B 가 느려지더라도 시스템 A 는 영향을 받지 않는다
  - 메시징 시스템은 시스템 A 가 보낸 메시지를 일단 저장하고, 시스템 B 의 성능에 맞게 메시지를 전달한다
  - 즉, 메시징 시스템은 중간에서 메시지를 보관하는 버퍼 역할을 한다
  - 시스템 A 의 트래픽이 급증하더라도 시스템 B 는 자신의 용량에 맞게 메시징을 처리할 수 있다
  - 또한 시스템 B 의 성능이 저하되더라도 시스템 A 는 영향을 받지 않고 메시지는 메시징 시스템을 통해 전송된다
- 두 번째 이점은 확장이 용이하다는 점이다
  - 만약 시스템 A 가 시스템 C 에 직접 데이터를 전송했다면 시스템 A 에 새로운 코드를 추가해야 한다
  - 그러나 메시징 시스템을 사용하면 시스템 C 를 메시징 시스템에 연결하기만 하면 된다
- **카프카를 선택할 때 일반적으로 고려할 점들**
  - 높은 처리량을 자랑한다. 초당 백 만 개 이상의 메시지를 처리할 수 있다
  - 수평 확장이 용이하다. 서버(브로커), 파티션, 소비자를 늘리면 된다
  - 카프카는 메시지를 파일에 보관해서 메시지가 유실되지 않는다
  - 1 개의 토픽이 여러 파티션을 가질 수 있는데, 파티션 단위로 순서를 보장한다. 하지만 토픽 수준에서는 순서를 보장할 수 없다
  - 풀(pull) 모델을 사용한다. 소비자가 카프카 브로커에서 메시지를 읽어 가는 방식이다
- **래빗 MQ 를 선택할 때 일반적으로 고려할 점들**
  - 클러스터를 통해 처리량을 높일 수 있다. 단 카프카보다 더 많은 자원을 필요로 한다
  - 메모리에만 메시지를 보관하는 큐 설정을 사용하면 장애 상황 시 메시지가 유실될 수 있다
  - 메시지는 큐에 등록된 순서대로 소비자에 전송된다
  - 메시지가 소비자에 전달되었는지 확인하는 기능을 제공한다
  - 푸시(push) 모델을 사용한다. 래빗MQ 브로커가 소비자에 메시지를 전송한다. 소비자의 성능이 느려지면 큐에 과부하가 걸려 전반적으로 성능 저하가 발생할 수 있다
  - 다재 다능하다. AMQP, STOMP 등 여러 프로토콜을 지원하고 게시/구독 패턴 뿐만 아니라 요청/응답, 점대점(point-to-point) 패턴을 지원한다. 또한 우선순위를 지정해서 처리 순서를 변경할 수도 있다
- **래디스 pub/sub을 선택할 때 일반적으로 고려할 점들**
  - 메모리를 사용하므로 지연 시간이 짧고, 래빗 MQ 대비 처리량이 높다
  - 구독자가 없으면 메시지가 유실된다
  - 기본적으로 영구 메시지를 지원하지 않는다
  - 모델이 단순해서 사용하기 쉽다

</br>

> 메시징 시스템을 고를 때 사용할 수 있는 또 다른 기준은 조직의 경험이다
>
> 경험은 없지만 유행이나 호기심에 따라 기술을 선택할 때도 있다
> 기술에 호기심을 느끼는 개발자일수록 이런 선택을 하기 쉽다
> 하지만 기술을 선택할 때는 개인의 호기심이나 취향보다는 조직의 역량과 지속 가능성을 고려해야 한다
> 타당한 이유 없이 단순히 유행한다는 이유로 특정 기술을 선택했다가 유지보수에 어려움을 겪는 일이 발생할 수 있기 때문이다
