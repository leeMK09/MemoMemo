## 파일 다운로드 중 LAN 케이블을 분리했다가 다시 연결하면 TCP 연결은 어떻게 될까?

- 결론부터 말하자면 TCP 는 우리가 생각하는 것보다 훨씬 느리게 연결 종료를 판단한다 → 즉 분리된 시간에 따라 다르겠지만 다시 TCP 연결을 지속한다

**LAN 케이블을 뽑으면 TCP 연결은 즉시 끊어지는가?**

- 이 생각은 물리적인 연결 관점에서는 그렇게 보일 수 있지만 TCP 관점, 논리적 연결 지속성에서는 틀린 말이다
- LAN 케이블을 뽑는 순간 L1 에서는 네트워크 링크가 끊어지지만 L4 계층에서는 아무런 종료 신호도 받지 못한 상태이다
- 중요한 것은 TCP 는 케이블의 물리적인 연결 상태를 보고 판단하지 않는다는 것 이다
- TCP 가 신뢰하는 것은 ACK (확인 응답) 신호이다
- 즉 클라이언트가 FIN 패킷을 보내지 않았고 RST 패킷도 오지 않았다면 TCP 는 아직 응답이 없다는 것으로 판단하고 즉시 끊어지지 않는다

</br>

### TCP 는 어떻게 클라이언트가 살아있는지 판단하는가?

- TCP 는 자신이 보낸 데이터에 대한 ACK (확인 응답) 신호가 들어오는가를 지속적으로 요청한다
- ACK
  - TCP 에서 데이터를 보내면 상대방은 해당 데이터를 잘 받았다는 응답을 보낸다 → 해당 응답이 ACK (Acknowledgment)
- 문제는 LAN 케이블을 뽑았을 때 데이터도 수신되지 못하고 ACK 도 응답받지 못한다
- 이때 TCP 는 곧바로 요청을 끊지 않고 재전송 타이머(RTO) 를 사용한다

</br>

### RTO (Retransmission Time-Out)

- ACK 가 해당 시간내에 오지 않는다면 데이터가 유실된 것으로 판단하여 다시 데이터를 보낸다

**재전송 흐름 → 지수 백오프**

- 재전송은 아래처럼 진행된다
  - 1초 기다림 → ACK 없음 → 재전송
  - 2초 기다림 → ACK 없음 → 재전송
  - 4초 → ... → 8초 → ... → 16 초 ...
- 즉 재전송 간격이 두 배씩 늘어난다 → 지수 백오프 (exponential backoff) 형태
- 이 방식의 목적은 아래와 같다
  - 네트워크가 이미 문제 상황일 수 있으며 재전송을 너무 자주하면 오히려 혼잡 상황이 발생하므로 지수적으로 재전송 시간을 증가시킴

</br>

### TCP 가 결국 연결을 끊는 판단

- TCP 는 무한히 재전송하지 않는다
- 보통 운영체제 내부에서 아래와 같은 판단로직이 존재한다
  - 일정 횟수 이상 재전송했는데도 끝내 ACK 가 오지 않는다면 이 연결은 더 이상 유효하지 않는다고 판단
- 이 시점에 TCP 소켓은 에러 상태가 된다
- 연결을 끊는 판단은 OS 설정, 네트워크 환경, 상황에 따라 다르다

</br>

### 끊긴 것도 아니고 살아있는 것도 아닌 상태

- LAN 케이블을 뽑으면 다운로드가 멈추지만 바로 실패 메시지는 뜨지 않는다 → 한참 있다가 실패 or 다시 케이블을 꽂으면 다운로드가 이어진다
- 이 상태를 표현하자면 TCP 연결은 ESTABLISHED 상태로 남아있을 수 있으며 다만 데이터 흐름이 정지되어 있을 뿐 이다

> TCP 에는 기본적으로 하트비트가 없다
>
> 즉 TCP 자체에는 적극적인 생존 확인 메커니즘이 없다
> TCP Keepalive 는 운영 체제 커널 옵션을 의미하며 일정 시간 동안 트래픽이 없으면 하트비트형태의 probe 패킷을 보냄
> 하지만 기본 설정은 아주 느리며 실시간 서비스 요구사항에는 맞지 않는 경우가 있다
>
> 그래서 애플리케이션 레벨에서 직접 하트비트를 구현하는 방식이다
>
> - WebSocket ping/pong
> - gRPC keepalive
> - 주기적인 HTTP 요청
> - 커스텀 ping 메시지

</br>

### 크롬 파일 다운로드는 새로운 TCP 에서도 파일을 이어서 다운로드 받을 수 있는데 어떻게 가능한가?

- TCP 연결이 살아있기 때문에 이어받기가 되는거 아닌가? 라고 이해할 수 있는데 대부분의 경우 이 방식이 아닌 HTTP Range 요청을 통해 이어받는다
- 파일 다운로드는 보통 HTTP 위에서 이루어진다
- 처음 요청 후 50MB 까지 받다가 끊겼다면 다음과 같이 요청을 수행한다

```text
GET /bigfile.zip
Range: bytes=52428800-
```

- 서버가 이를 지원한다면 응답 코드(206 Partial Content) 를 보내며 50MB 이후 데이터만 다시 전송한다
- 해당 방식 덕분에 새로운 TCP 연결로도 파일 이어받기가 가능하다
- 즉 기존 TCP 가 죽고 새로운 TCP 연결이라고 하더라도 새로운 TCP 연결 + HTTP Range 요청을 수행하여 파일을 이어서 다운로드 받을 수 있다
