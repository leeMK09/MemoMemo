## 코틀린에 대해

- 코틀린은 정적 타입언어
  - 즉, 컴파일 시점에 타입을 알수있다는 뜻이다
- 코틀린은 별도의 지시자를 붙이지 않으면 기본적으로 `public final` 이다
- var → 가변
  - Variable
- val → 불변
  - Value
  - 초기화되지 않은 선에서 최조 한번은 값을 넣을 수 있다

> 코드를 클린하게 유지보수 용이하게 하려면 먼저 모든 변수를 val 로 한뒤 꼭 필요한 경우에 특정 변수만 var로 처리하자

</br>

- 자바에서는 Primitive Type 과 Reference Type 이 존재
  - 연산에서는 Reference Type 은 사용하지 않아야 함
  - 박싱과 언박싱이 들어가면서 불필요한 객체 생성이 이루어진다
- 코틀린에서는 이런 구분이 없다
  - 성능상에는 문제가 없을까?
  - 숫자, 문자, 불리언 같은 타입은 내부적으로 특별한 표현을 갖는다
  - 이 타입들은 실행시에 Primitive Value 표현되지만 코드에서는 평범한 클래스로 보인다
  - 즉, Long 타입같은 경우 코드상에서 모두 Long 타입으로 표현되지만 연산을 하게될 경우 내부적으로 Primitive Type 으로 변환해서 적절히 처리해준다
    - 프로그래머가 박싱 / 언박싱을 고려하지 않아도 되도록 알아서 처리해준다

</br>

- 자바에서는 연산시 암시적 타입 변환을 허용한다
  - 예를들어 `long + int` 연산의 경우 크기가 더 큰 long 타입으로 암시적 타입 변환을 한다
- 그러나 코틀린에서는 암시적 타입 변환을 하지 않고 컴파일 에러가 발생한다
  - 명시적 타입 변환만 허용
  - `toLong`, `toDouble`, `toString` 등을 사용해야 함

</br>
</br>

## Any

- Java 의 Object 역할을 한다
  - 모든 객체의 최상위 타입
- 모든 Primitive Type 의 최상위 타입도 Any 이다
- Any 자체로는 null 을 포함할 수 없어서 null 을 포함하고 싶다면 `Any?` 로 표현해야 한다
- Any 에 equals / hashCode / toString 메서드 존재
  - Java 의 Object 클래스와 비슷함

</br>
</br>

## Unit

- Java 의 void 와 동일한 역할
- void 와 Unit 은 다른점이 존재한다
  - Unit은 그 자체로 타입 인자 사용이 가능
  - 즉 제네릭에서 void 는 제네릭으로 사용하려면 직접 void 클래스가 따로 있어서 이 클래스를 사용해야 한다
    - void 가 아닌 Void
- 함수형 프로그래밍에서 Unit 은 단 하나의 인스턴스만 갖는 타입을 의미한다
  - 즉 코틀린의 Unit 은 실제 존재하는 타입이라는 것을 표현

</br>
</br>

## Nothing

- 함수가 정상적으로 끝나지 않았다는 사실을 표현하는 역할
- 무조건 예외를 반환하는 함수 혹은 무한루프 함수 등

</br>
</br>

## 연산자

**비교 연산자**

- <, >, <=, =>
- Java 와 다르게 객체를 비교할때 비교 연산자를 사용하면 자동으로 `compareTo` 를 호출해줍니다

</br>

**동등성, 동일성**

- 자바에서는 동일성은 `==` 를 사용, 동등성은 `equals` 를 직접 호출
- 코틀린에서는 동일성은 `===` 를 사용, 동등성에 `==`를 호출
  - `==`를 사용하면 간접적으로 equals 를 호출해준다

</br>

**in / !in**

- 컬렉션이나 범위에 포함되어 있다. or 포함되어 있지 않다

</br>

**a..b**

- a 부터 b 까지의 범위 객체를 생성한다
- Range 라는 실제 클래스가 존재
  - Progression 을 상속받고 있음
  - downTo, step 도 함수이다
    - 중위 함수 호출
    - 코틀린의 전통적인 for 문은 등차수열을 사용한다

</br>

**연산자 오버로딩**

- 코틀린에서는 객체마다 연산자를 직접 정의할 수 있다

</br>
</br>

## 논리식

- 자바에서 `if-else` 는 Statement 이지만 코틀린에서는 Expression 이다
- Statement : 프로그램의 문장, 하나의 값으로 되지 않는다
- Expression : 하나의 값으로 도출되는 문장
- `try-catch` 도 `Expression` 으로 평가된다

</br>
</br>

## 예외

- 코틀린은 `throws` 구문이 없다
- 코틀린에서는 체크 예외와 언체크 예외를 구분하지 않는다
- 모두 언체크 예외로 간주한다
- 코틀린에서는 `try with resource` 가 없다
  - 코틀린의 특성을 이용해 만든 확장함수 `use` 를 사용할 수 있다 → inline 확장함수

</br>
</br>

## 클래스

- 프로퍼티 : 필드 + getter + setter 를 의미함
- 코틀린에서는 필드만 선언해도 자동으로 getter, setter 를 만들어줌
- 생성자에서 프로퍼티를 선언할 수 있다
- 코틀린은 `.필드` 를 통해 getter, setter 를 바로 호출한다
  - 코틀린에서 자바 클래스를 사용할 수 있으며 이때도 자바 클래스에 대해서 `.필드` 로 getter, setter 를 사용한다

</br>

## init

- 초기화 블록
- 클래스가 초기화되는 시점에 한번 호출된다
- 검증 로직을 만들어 검증할 수 있다

</br>

## custom getter

- 프로퍼티를 선언 및 get() 을 통해 커스텀 getter 를 사용할 수 있다
- 자바로 컴파일시 메서드로 컴파일 된다
- 객체의 속성을 확인하는 것이라면 커스텀 getter 를 사용할 수 있다
  - 속성을 가공한 뒤 응답하는 것도 가능하다
  - 이 경우 생성자에서 프로퍼티를 선언하지 않고 필드로 처리해야 한다. 생성자로 하면 자동으로 getter, setter 를 만들어주기 때문에 사용할 수 없다
- 이때 만약 프로퍼티가 `name` 인 경우 커스텀 getter 에서는 name 을 사용하지 못하고 `field` 라는 키워드로 접근해야 한다
  - 이유는 name 으로 접근해서 가공할때 getter 를 호출하게 되는데 이때 호출되는 getter 는 커스텀 getter 이고 그 안에서 다시 name 으로 접근하므로 무한루프가 발생한다
  - 이러한 `field` 를 `backing field` 라고 부른다
    - 자기 자신을 가리키는 보이지 않는 field
- 프로퍼티를 override 할 경우 무조건 `open` 키워드를 붙여야 한다
- 인터페이스에서 인스턴스 변수를 선언하면 getter 를 오버라이드해서 구현해야 한다
  - 이를 `backing field`없는 프로퍼티라 한다
  - 하지만 값을 넣는건 불가능하다
- 상위 클래스에서 open 한 속성을 init 에서 접근시 초기값이 나온다
