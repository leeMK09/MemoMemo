`synchronized` 키워드는 Java 에서 **스레드 안전성** 을 보장하기 위해 사용되는 중요한 도구지만, 잘 못 사용하거나 과도하게 사용하면 **성능 저하** 를 일으킬 수 있습니다.

그 이유는 다음과 같습니다

</br>

## 1. 락 (Lock) 경쟁

`synchronized` 키워드는 메소드나 코드 블록에 대해 **락(Lock)** 을 설정하여, 해당 코드가 한 번에 하나의 스레드만 접근할 수 있도록 만듭니다.

즉, 공유 자원에 대한 **경쟁 조건(Race condition)** 을 방지하고 스레드 간의 동기화를 보장합니다

- 하지만, 여러 스레드가 동시에 `synchronized` 블록에 접근하려고 하면, **한 스레드가 락을 소유하는 동안 나머지 스레드들은 락을 얻기 위해 대기해야 합니다**
- 이러한 대기 시간이 길어질수록 매플리케이션의 응답성이 떨어지게 되고 이 현상을 **락 경합(lock contention)** 이라고 하며, 락 경합이 많을수록 성능이 저하됩니다
- 특히 다중 코어 시스템에서는 여러 스레드가 병렬로 작업을 수행할 수 있는 이점을 살리지 못하게 되며, 락이 걸려 있는 동안 **병렬 처리가 직렬 처리로 전환** 되어 성능 병목이 발생할 수 있습니다.

</br>

## 2. 컨텍스트 스위칭 비용

락이 걸린 상태에서 다른 스레드가 해당 락을 얻기 위해 대기하는 동안, 운영체제는 이 스레드들을 **컨텍스트 스위칭** 시켜야 합니다

이 작업에는 상당한 비용이 발생하며 특히 **락 경합이 심한 경우** 스레드들이 락을 얻기 위해 계속해서 대기와 스위칭을 반복하게 되며 이는 시스템의 성능을 크게 저하시킬 수 있습니다

</br>

## 3. 장기적인 락 유지 문제

`synchronized` 블록이나 메서드 내에서 **긴 시간이 소요되는 작업을 수행** 하게 되면 락을 오래 소유하게 됩니다

이로 인해 다른 스레드들이 락을 대기하는 시간이 길어지고 **병목 현상** 이 발생하게 됩니다.

</br>

## 4. 락 범위가 넓을 때

예를 들어 클래스의 전체 메소드에 `synchronized` 를 적용하게 되면 해당 메서드의 모든 코드가 락의 영향을 받게 됩니다

반면 필요한 최소한의 코드 부분에만 락을 걸어 락 범위를 좁히면 스레드 간의 경합을 줄일 수 있습니다

</br>

### 성능 저하를 최소화하기 위한 대안

- **ReentrantLock**
  - 비공정 락, 시간 대기 타임아웃
- **Shared Lock**
  - 분할 락

</br>

---

# 🤔 ReentrantLock, 비공정 (non-fair) 락, 분할 락 (Sharded lock) 이란 ?

## 1. ReentrantLock

`ReentrantLock` 은 Java 의 `java.util.concurrent.locks` 패키지에 포함된 클래스로, `synchronized` 키워드 대신 사용할 수 있는 **동기화 메커니즘** 입니다

더 정교한 락 제어를 제공하며 더 나은 성능과 유연성을 가지고 있습니다. 주요 특징은 다음과 같습니다

- **재진입성** : `ReentrantLock` 은 재진입이 가능합니다. 즉, 하나의 스레드가 이미 `ReentrantLock` 을 획득한 상태에서 동일한 락을 다시 획득하는 것이 허용됩니다
  - 이러한 재진입성은 재귀 메서드 호출이나, 동일한 스레드가 여러 개의 관련된 코드 블록을 락으로 보호해야 할 때 유용합니다
- **락 해제 제어** : `synchronized` 는 코드 블록이 종료될 때 자동으로 락을 해제하지만, `ReentrantLock` 은 **명시적으로 락을 획득(`lock()`) 하고 해제(`unlock()`)** 해야 합니다
  - 이는 락 해제를 더 유연하게 제어할 수 있도록 해줍니다.
  - 다만, 사용자가 명시적으로 해제하는 것을 잊으면 **데드락(deadlock)** 의 위험이 있을 수 있기 때문에 주의가 필요합니다
- **타임 아웃 기능** : `ReentrantLock` 은 락을 얻기 위해 **대기하는 시간을 지정할 수 있습니다.**
  - 예를 들어 `lock.tryLock(long timeout, TimeUnit unit)` 을 사용하면, 지정된 시간 동안만 락을 기다리게 하고, 락을 얻지 못하는 대기를 중단할 수 있습니다. 이를 통해 **락 경합으로 인한 무한 대기** 를 방지할 수 있습니다.
- **공정성(Fairness) 설정** : `ReentrantLock` 은 **공정성(Fairness)** 설정이 가능하며, 락을 대기하고 있는 스레드들 사이에서 **락 획득 순서를 제어할 수 있습니다**
  - 이를 통해 락을 먼저 요청한 스레드가 먼저 락을 획득하게 하여 우선순위 역전 을 방지할 수 있습니다.

</br>

## 2. 비공정(Non-fair) 락

**공정 락(Fair Lock)** 과 **비공정 락 (Unfair or Non-fair Lock)** 은 락을 대기하는 스레드들이 **락을 획득할 수 있는 순서** 에 대한 정책을 설명합니다

- **공정 락** : 공정 락은 `FIFO (First-In-First-Out)` 원칙을 따릅니다. 즉, 락을 대기 중인 스레드들 중에서 가장 먼저 락을 요청한 스레드가 락을 획득하도록 보장합니다.
  - 이렇게 하면 **락 경합** 이 공정하게 이루어지며 특정 스레드가 계속 대기 상태에 빠지는 문제가 방지됩니다. 하지만 공정 락은 **추가적인 오버헤드** 가 발생하여 성능이 떨어질 수 있습니다
- **비공정 락** : 비공정 락은 **현재 락을 해제할 때 가장 가까이 있는 스레드** 가 락을 획득할 수 있도록 하여, 대기 중인 스레드의 순서를 반드시 지키지 않습니다. 즉, 락을 해제하는 시점에서 락을 얻으려는 스레드가 **우연히 더 빠르게 락을 획득**할 수도 있습니다.
  - 비공정 락은 락 획득에 드는 시간을 줄여 성능을 높일 수 있지만, 특정 스레드가 계속해서 락을 얻지 못하는 **기아(starvation) 현상** 이 발생할 수 있습니다

```java
ReentrantLock fairLock = new ReentrantLock(true); // 공정 락
ReentrantLock unfairLock = new ReentrantLock(false); // 비공정 락 (기본값)
```

</br>

## 3. 분할 락 (Shared Lock)

**분할 락 (Sharded Lock)** 은 락의 **경합을 줄이고 성능을 향상**시키기 위해 **하나의 큰 락을 여러 개의 작은 락** 으로 분할하는 방식입니다.

이는 특히 **여러 개의 독립적인 데이터 조각**을 처리할 때 유용합니다

예를들어 여러 스레드가 서로 다른 데이터 파티션에 접근해야 하는 상황이라면 각 파티션마다 개별적으로 락을 설정하여 락 경쟁을 줄일 수 있습니다.
이를 통해 스레드들이 별렬로 서로 다른 파티션을 처리할 수 있게 되어 성능을 크게 개선할 수 있습니다

분할 락의 장점은 **락 경합을 줄이는** 것 입니다. 하나의 공유 자원에 대해 모든 스레드가 동일한 락을 사용한다면, 스레드들은 자주 경합하게 되어 성능이 저하됩니다 하지만 데이터가 독립적인 파티션으로 나뉘어져 있다면 각 파티션에 대해 개별적인 락을 사용하여 스레드들이 병렬로 접근할 수 있게 함으로써 동시성을 높일 수 있습니다.

```java
import java.util.concurrent.locks.ReentrantLock;

public class ShardedLockExample {
    private final ReentrantLock[] locks = {
        new ReentrantLock(),
        new ReentrantLock(),
        new ReentrantLock()
    };

    public void accessPartition(int partitionId) {
        ReentrantLock lock = locks[partitionId];
        lock.lock();  // 해당 파티션에 대한 락 획득

        try {
            System.out.println("파티션에 대한 작업 수행);
        } finally {
            lock.unlock();  // 락 해제
        }
    }
}
```

데이터 파티션을 나누고 각 파티션에 대해 개별적인 `ReentrantLock` 을 사용하여 스레드들이 병렬로 각 파티션을 접근할 수 있도록 처리

</br>

### 🌟 정리

- `ReentrantLock` : 더 정교한 동기화 제어를 위해 사용되는 락으로, 재진입 가능하며 명시적인 락 해제와 타임아웃 설정이 가능합니다
- **비공정 락** : 락을 요청한 순서를 지키지 않고 더 빠르게 락을 획득하려는 스레드에게 락을 허용하여 성능을 높일 수 있지만, 특정 스레드가 기아(starvation)에 빠질 수 있습니다
- \*\*분할 락(`Sharded Lock`) : 락 경합을 줄이고 성능을 개선하기 위해 하나의 큰 락을 여러 작은 락으로 나누는 방식으로 병렬 접근을 용이하게 합니다
