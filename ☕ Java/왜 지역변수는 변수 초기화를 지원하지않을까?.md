예제로 실펴보자

</br>

### 지역변수

```java
void test() {
    int a; // 선언만 함
    System.out.println(a); // 컴파일 에러! 초기화 안 됨
}
```

지역 변수는 명시적으로 초기화하지 않으면 컴파일 에러가 발생한다

왜? → 컴파일러는 메모리 상태를 **정확히 추적**할 수 없기 때문

</br>

---

</br>

### 멤버변수 (인스턴스 변수)

```java
class MyClass {
    int x; // 초기화 안 해도 OK

    void print() {
        System.out.println(x); // 0 출력됨
    }
}
```

멤버 변수는 초기화를 하지 않아도 기본값(0, false, null) 으로 자동 초기화된다

왜? → JVM이 객체를 생성할 때 **힙 영역**에 메모리를 할당하고 0으로 클리어하기 때문

</br>

---

</br>

### 왜 이렇게 만들었을까?

**지역 변수는 스택 메모리에 저장된다**

- 스택은 메모리 할당/해제가 빠르지만, **초기화 책임은 프로그래머에게 있다**
- 컴파일러가 모든 경로에서 "이 값이 무조건 초기화됐는가?"를 판단할 수 없으면, 컴파일 자체를 막는다

즉, 미정의 값 사용 = 위험

그래서 자바는 지역 변수에 대해 **엄격하게 초기화 검사**함

</br>

---

</br>

### 멤버변수는 힙 메모리에 저장

- 객체 생성 시 JVM이 책임지고 모든 필드에 기본값으로 초기화한다
  → int → 0, boolean → false, Object → null

안전하게 기본값으로 시작하게 하자는 철학

</br>

### static 변수는 메서드 영역에 저장

- 클래스가 로딩될 때 JVM이 자동으로 static 필드도 초기화된다

</br>
</br>

---

</br>

### 그러면 JVM 은 스택 메모리를 볼 수 없는건가? 컴파일러가 스택의 변수 초기화를 지원하지 않는 특별한 이유가 있는건가 ?

</br>

**자바에서 컴파일러 vs JVM 역할 차이**

| 항목           | 자바 컴파일러 (`javac`)               | JVM                                  |
| -------------- | ------------------------------------- | ------------------------------------ |
| 시점           | **컴파일 타임**                       | **런타임**                           |
| 역할           | 문법 검사, 타입 검사, 바이트코드 생성 | 코드 실행, 메모리 관리 (힙, 스택 등) |
| 메모리 추적    | **정적 분석만 가능**                  | **실제 메모리 할당 및 실행**         |
| 지역 변수 추적 | 제어 흐름 기반 분석 (정적 추론)       | X                                    |

</br>

**지역변수는 스택에 저장됨**

- 지역 변수는 **메서드 호출 시 스택 프레임**에 저장된다
- 스택은 실행 도중에 동적으로 할당/해제되는 구조
- 따라서 **JVM이 실행하면서 그 값을 읽고 쓰는건 문제가 없다**

### 하지만 !

**컴파일러는 스택 메모리를 볼 수 없다!**

- `javac` 컴파일러는 런타임 스택의 상태를 모른다
- 대신 코드 흐름 (제어 흐름) 만 분석하며 "이 변수가 사용되기 전에 반드시 초기화되는가?" 만 판단하려 한다

</br>

### 왜 자동 초기화를 해주지 않을까 ?

**이유 1 : 명확성과 버그 예방**

- 지역 변수는 사용 범위가 작고, 초기화 여부가 **코드 흐름에 따라 달라질 수 있다**

```java
void test(boolean flag) {
    int a;
    if (flag) {
        a = 10;
    }
    System.out.println(a); // flag 가 false 일 때 a 는 초기화 안됨 → 컴파일 에러 발생
}
```

이런 경우 컴파일러가 강제로 막아줘야 런타임 오류를 방지할 수 있다

</br>

**이유 2 : 의도하지 않은 동작을 방지**

```java
void test() {
    int a;                 // if) 자동으로 0이 들어간다면 ?
    System.out.println(a); // 버그 발생 시 발견이 어렵다
}
```

자동으로 0으로 초기화된다면 "초기화 안 된 실수"를 컴파일러가 잡아낼 수 없게된다

그래서 아예 명시적인 초기화를 **강제하게 된다**

</br>

**이유 3 : 성능 때문은 아니다**

- 성능이 아니라 **코드 안정성, 예측 가능한 동작, 명시성** 때문
- 오히려 자동 초기화 하려면 더 많은 오버헤드가 들어갈 수도 있다 (불필요한 값 설정 등)

</br>

**JVM은 스택을 알고있다**

- JVM은 **스택을 완벽히 관리합니다** (핵심 영역)
- 하지만 컴파일러(`javac`)는 **그걸 모릅니다**
- 그래서 **컴파일 시점에 지역 변수 초기화가 확실하지 않으면 컴파일 자체를 막는 것** 이다
