자바에서 인터페이스(Interface)와 추상 클래스(abstract class)는 둘 다 추상화(abstraction)을 위한 도구지만, 역할과 사용 목적에 차이가 있다

</br>

---

</br>

예제

**인터페이스**

```java
interface Animal {
    void makeSound(); // 추상 메서드
}

class Dog implements Animal {
    public void makeSound() {
        System.out.println("멍멍!");
    }
}
```

</br>

**추상클래스**

```java
abstract class Vehicle {
    int speed;

    abstract void move(); // 추상 메서드

    void stop() { // 일반 메서드
        System.out.println("멈춰");
    }
}

class Car extends Vehicle {
    void move() {
        System.out.println("나는 자동차, 나는 앞으로간다");
    }
}
```

</br>

**둘 다 언제 사용해야 하는 걸까?**

- 인터페이스

  - 여러 클래스가 공통 기능 없이 "기능만 선언" 해야할 때
  - 다형성을 극대화하고 싶을 때

- 추상클래스
  - 공통 필드나 로직이 있고, 기본 동작을 함께 공유해야 할 때
  - 계층적 구조로 코드를 정리하고 싶을 때

즉, 인터페이스는 "무엇을 할 수 있다" 를 약속하는 계약

추상클래스는 "어떤 공통적인 성격과 동작을 갖는다" 는 틀 이다

</br>
</br>

---

</br>

## 자바에서 인터페이스는 왜 필드로 상수(public static final) 만 가질 수 있는가?

이건 단순한 문법 제약이 아닌, 인터페이스의 철학과 구조적인 이유 때문이다

인터페이스에서 선언한 모든 필드는 자동으로 `public static final` 즉 상수이다

그리고 다른 접근제어자나 수정자(`private`, `non-final`, `non-static`)는 불가능합니다

</br>
</br>

**왜 상수만 가능할까?**

1. 인터페이스는 "기능계약서" 역할

   - 인터페이스는 "이 기능을 구현하겠다" 는 약속(계약)을 정의합니다
   - **상태(state)를 가지지 않아야** 하며 **동작(behavior) 중심**이어야 합니다
   - 그러므로 인스턴스 변수를 가질 수 없습니다 대신, 필요한 공용 상수(Constant)는 제공할 수 있습니다

2. 인터페이스는 다중 구현이 가능하기 때문
   - 자바는 클래스는 단일 상속, 인터페이스는 다중 구현이 가능하다
   - 만약 인터페이스에 일반 필드가 있다면, 다중 구현시 필드 충돌, 상태 충돌이 생길 수 있어서 안전하지 않다
   - `static final` 상수만 허용하면, 이런 충돌이 발생하지 않는다

</br>
</br>

**자바가 강제로 붙여주는 키워드**

```java
interface MyInterface {
    int A = 10;
}
```

위 코드는 다음과 같은 의미이다

```java
interface MyInterface {
    public static final int A = 10;
}
```

- 컴파일러가 자동으로 `public static final` 을 붙인다
- 따라서 인터페이스에서 필드는 **무조건 상수**이다

</br>
</br>

**불가능한 예시**

```java
interface MyInterface {
    private int x = 1; // X 컴파일 에러
    int y;             // X 초기화 안된 필드 → 에러
    int z = 10;        // 컴파일 시 자동으로 public static final 을 붙임
}
```

</br>
</br>

**만약 상태를 갖고 싶다면?**

- 추상 클래스 사용을 고려해보세요

```java
abstract class MyAbstract {
    protected int value = 10;
}
```

</br>
</br>

---

</br>

## Java8 부터 인터페이스에 default 메서드가 추가되었는데 "그럼 이제 추상클래스랑 뭐가 달라?"

먼저 `default` 메서드는 왜 추가되었을까 ?

- 기존 인터페이스에 기능을 추가하면서도, 구현체에 영향을 주지 않기 위해 !

자바 8 이전에는 인터페이스에 메서드를 추가하면...

```java
interface Printer {
    void print();
}

// 새로운 기능을 추가하고 싶다
interface Printer {
    void print();
    void log(); // → 이러면 기존 구현체 다 에러남!
}
```

모든 구현체가 `log()` 를 구현해야 해서 호환성이 깨진다

→ 해결책 `default` 메서드

```java
interface Printer {
    void print();

    default void log() {
        System.out.println("기본 로그");
    }
}
```

- 기존 구현체에 영향 없다
- 필요할 경우 `override` 하고 아니면 기본 동작을 수행
- 즉, 기존 인터페이스에 기능 추가 시 호환성을 유지하기 위한 목적으로 도입!

</br>
</br>

**그렇다면 이제 인터페이스와 추상클래스의 차이점은 없을까?**

아니요, 여전히 차이점은 존재한다!

`default` 메서드는 "기능 추가를 위한 호환성 유지 수단" 이지, 추상 클래스와 인터페이스의 **역할을 통합하려는 의도는 아니다!**

`default` 메서드 덕분에 인터페이스도 "약간의 구현"은 가능해졌지만, **상태를 가질 수 없고 다중 구현 가능하며 계약 중심 설계 라는 본질**은 변하지 않습니다

그래서 역할도 여전히 다르고 쓰임도 분명히 구분됩니다

</br>
</br>

**최신 자바에서 인터페이스 확장 사항**

- `private` 메서드도 인터페이스에 추가 가능
- `sealed interfaces`, `records`, `funtional interfaces` 등도 연계 가능
- **하지만 여전히 상태(state)는 가질 수 없다** → 이게 추상 클래스와의 가장 큰 차이점!

</br>
</br>

**실제 사용 전략**

| 상황                                                | 추천                        |
| --------------------------------------------------- | --------------------------- |
| 공통된 **상태와 구현** 공유                         | 추상 클래스                 |
| 다양한 클래스에 **기능 계약**만 적용                | 인터페이스                  |
| 여러 인터페이스에서 기능 조합 + 일부 공통 기능 제공 | 인터페이스 + default 메서드 |

</br>
</br>

## 정리 및 비교

| 항목       | 인터페이스 (Interface)                           | 추상 클래스 (Abstract Class)             |
| ---------- | ------------------------------------------------ | ---------------------------------------- |
| 상속       | 다중 구현 가능 (다중 상속 가능)                  | 단일 상속만 가능                         |
| 필드       | `public static final` 상수만 가능                | 일반 필드, 상수 모두 가능                |
| 메서드     | 기본은 추상 메서드, `default`/`static` 사용 가능 | 추상 메서드 + 일반 메서드 모두 가능      |
| 생성자     | 없음                                             | 생성자 가질 수 있음                      |
| 사용 목적  | "무엇을 할 수 있는가?" 기능 중심 계약            | "무엇인지?" 공통된 속성과 행위 정의 중심 |
| 접근제어자 | 모든 메서드는 암묵적으로 `public`                | 접근 제어자 자유롭게 사용 가능           |
