## 인터럽트와 인터럽트 처리시 고려할 점

인터럽트를 사용하면 `WAITING`, `TIMED_WAITING` 같은 대기 상태의 스레드를 직접 깨워서 작동하는 `RUNNABLE` 상태로 만들 수 있다

```java
public static void main(String[] args) {
    MyTask task = new MyTask();
    Thread thread = new Thread(task, "work");
    thread.start();

    thread.interrupt();
}
```

- 특정 스레드의 인스턴스에 `interrupt()` 메서드를 호출하면 해당 스레드에 인터럽트가 발생한다
- 인터럽트가 발생하면 해당 스레드에 `InterruptedException` 이 발생한다
  - 이때 인터럽트를 받은 스레드는 대기 상태에서 깨어나 `RUNNABLE` 상태가 되고, 코드를 정상 수행한다
  - 이때 `InterruptedException` 을 `catch` 로 잡아서 정상 흐름으로 변경하면 된다
- **참고로 `interrupt()` 를 호출했다고 해서 즉각 `InterruptedException` 이 발생하는 것은 아니다**
  - 오직 `InterruptedException` 을 던지는 메서드를 호출하거나 또는 호출 중일때 예외가 발생한다
  - `Thread.sleep()` 처럼 `InterruptedException` 을 던지는 메서드를 호출하거나 또는 호출하며 대기중일때 예외가 발생한다
  - 참고로 스레드가 `RUNNABLE` 상태이어야지만 `catch` 의 예외 코드도 실행될 수 있다

```java
static class MyTask implements Runnable {
    @Override
    public void run() {
        while (true) {
            // 작업중 → 이때는 thread.interrupt() 를 실행해도 예외를 캐치하지 못함
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            // 예외처리
        }
    }
}
```

- 스레드가 인터럽트 상태일 때는 `Thread.sleep()` 처럼 `InterruptedException` 이 발생하는 메서드를 호출하거나 또는 이미 호출하고 대기 중이라면 `InterruptedException` 이 발생한다
- 이때 2가지 일이 발생한다
  - 스레드는 `TIMED_WAITING` 상태에서 `RUNNABLE` 상태로 변경되고, `InterruptedException` 예외를 처리하면서 반복문을 탈출한다
  - `MyTask` 는 인터럽트 상태이며 인터럽트 예외가 발생한다
  - 인터럽트 상태에서 인터럽트 예외가 발생하면 `MyTask` 스레드는 다시 작동하는 상태가 된다. 따라서 `MyTask` 스레드의 인터럽트 상태는 종료된다
    - `MyTask` 스레드의 인터럽트 상태는 `false` 로 변경된다
- 인터럽트가 적용되고 인터럽트 예외가 발생하면 해당 스레드는 실행 가능 상태가 되고, 인터럽트 발생 상태도 정상으로 돌아온다
- 인터럽트를 사용하면 대기중인 스레드를 바로 깨워서 실행 가능한 상태로 바꿀 수 있다

**그런데 앞선 예시 코드에서 한가지 아쉬운 부분이 있다**

```java
while (true) {
  // 작업중 → 인터럽트 체크 안함
  Thread.sleep(3000); // 여기서만 인터럽트 발생
}
```

여기서 `while (true)` 부분은 인터럽트를 체크하지 않는다는 점이다

인터럽트가 발생해도 이 부분은 항상 `true` 이기 때문에 다음 코드로 넘어간다

그리고 `Thread.sleep()` 을 호출하고 나서야 인터럽트가 발생하는 것 이다

**한가지 방법은 반복문 조건에 현재 작업이 인터럽트 상태인지 체크하는 처리를 하는 것 이다**

```java
while (!Thread.currentThread().isInterrupted()) { // 현재 작업의 인터럽트 상태 확인
    // 작업중
    Thread.sleep(3000);
}
```

- `isInterrupted()` 를 사용하면 스레드가 인터럽트 상태인지 확인할 수 있다

**실행 순서**

1. `main` 스레드는 `interrupt()` 메서드를 사용해서, `MyTask` 스레드에 인터럽트를 건다
2. `MyTask` 스레드는 인터럽트 상태이다. `isInterrupted() == true` 가 된다
3. 이때 while 조건이 `false` 가 되면서 `while` 문을 탈출한다

**하지만 이 코드에는 심각한 문제가 있다**

**바로 `MyTask` 스레드의 인터럽트 상태가 `true` 로 계속 유지된다는 점이다**

앞서 인터럽트 예외가 발생한 경우 스레드의 인터럽트 상태는 `false` 가 된다

(인터럽트에 반응하게 되면 인터럽트 상태는 `false` 로 변경된다)

**반면 `isInterrupted()` 메서드는 인터럽트 상태를 변경하지 않는다. 단순히 인터럽트의 상태를 확인만 한다**

**`MyTask` 스레드는 이후에 자원을 정리하는 코드를 실행할 경우 이때도 인터럽트 상태는 계속 `true` 로 유지된다**

**이때 만약 인터럽트가 발생하는 코드를 수행한다면 해당 코드에서 인터럽트 예외가 발생하게 된다**

**즉, 자원 정리를 위해 실행한 코드에서 아직까지도 인터럽트 상태가 `true` 이므로 자원 정리에 실패하게 된다**

**이후 인터럽트에 반응 (`catch (InterruptedException e) {...}`) 하므로 인터럽트 상태가 `false` 로 변경된다**

우리가 기대한 것은 반목문을 탈출하기 위해 딱 한 번만 인터럽트를 사용하는 것이지, 다른곳에서도 계속해서 인터럽트가 발생하는 것이 아니다

결과적으로 자원 정리를 하는 도중에 인터럽트가 발생한다면 자원 정리에 실패한다

**자바에서 인터럽트 예외가 한 번 발생하면, 스레드의 인터럽트 상태를 다시 정상(`false`)으로 돌리는 것은 이런 이유 때문이다**

**스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생하게 된다**

**인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 한다**

</br>
</br>

## Thread.interrupted()

스레드의 인터럽트 상태를 단순히 확인만 하는 용도라면 `isInterrupted()` 를 사용하면 된다

하지만 직접 체크해서 사용할 때는 `Thread.interrupted()` 를 사용해야 한다

이 메서드는 다음과 같이 동작한다

- 스레드가 인터럽트 상태라면 `true` 를 반환하고, 해당 스레드의 인터럽트 상태를 `false` 로 변경한다
- 스레드가 인터럽트 상태가 아니라면 `false` 를 반환하고, 해당 스레드의 인터럽트 상태를 변경하지 않는다

```java
static class MyTask implements Runnable {
    @Override
    public void run() {
        while (!Thread.interrupted()) {
            // 작업중
        }

        try {
            // 자원정리 시도
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            // 예외처리 - 자원정리 실패
        }
    }
}
```

주요 코드

```java
while (!Thread.interrupted()) { // 인터럽트 상태 변경 O
    // 작업중
}
```

**주요 실행 순서**

1. `main` 스레드는 `interrupt()` 메서드를 사용해서, `MyTask` 스레드에 인터럽트를 건다
2. `MyTask` 스레드는 인터럽트 상태이다. `Thread.interrupted()` 의 결과는 `true` 가 된다
   - `Thread.interrupted()` 는 이때 `MyTask` 스레드의 인터럽트 상태를 정상(`false`) 로 변경한다
3. 이때 다음과 같이 `while` 조건이 `false` 가 되면서 반복문을 탈출한다

`Thread.interrupted()` 를 호출했을 때 스레드가 인터럽트 상태가 `true` 라면 `true` 를 반환하고, 해당 스레드의 인터럽트 상태를 `false` 로 변경한다

결과적으로 반복문을 탈출하는 시점에 스레드의 인터럽트 상태도 `false` 로 변경된다

`MyTask` 스레드는 이후 자원을 정리하는 코드를 실행하는 데, 이때 인터럽트의 상태는 `false` 이므로 인터럽트가 발생하는 코드를 수행해도 인터럽트가 발생하지 않는다

이후에 자원을 정상적으로 처리한다

**자바는 인터럽트 예외가 한 번 발생하면 스레드의 인터럽트 상태를 다시 정상(`false`)로 돌린다**

**스레드의 인터럽트 상태를 정상으로 돌리지 않으면 이후에도 계속 인터럽트가 발생하게 된다**

**인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상으로 돌려두어야 한다**

인터럽트 상태를 직접 체크해서 사용하는 경우 `Thread.interrupted()` 를 사용하면 이런 부분을 해결할 수 있다

참고로 `isInterrupted()` 는 특정 스레드의 상태를 변경하지 않고 확인할 때 사용된다

물론 이것이 정답은 아니다, 예를들어 너무 긴급한 상황에서 자원정리도 하지 않고 빨리 스레드를 종료해야 한다면 해당 스레드를 다시 인터럽트 상태로 변경하는 것도 방법이다

</br>
</br>

### 정리

"왜 인터럽트 상태를 다시 false 로 바꿔야 하는가?" → 자바에서 인터럽트가 신호로 동작하기 때문

**`thread.interrupt()` 를 호출하면**

"이제 멈출 준비해" 라는 신호를 준다

> 이 신호는 `Thread` 객체에 플래그로 기록된다
>
> 이 플래그를 확인하는 것이 `isInterrupted()` 또는 `Thread.interrupted()` 이다

이후 **예외가 발생하면 신호(flag)는 자동으로 꺼진다**

```java
try {
    Thread.sleep(3000); // 여기서 인터럽트 신호를 감지
} catch (InterruptedException e) {
    // 여기 들어오면 플래그는 자동으로 false 로 초기화된다 !
}
```

- 이미 예외를 통해 인터럽트에 반응했으므로 "이제 신호 꺼도 됨" 이라고 보는 것

**그런데 `isInterrupted()` 는 신호를 끄지 않는다!**

해당 메서드는 "그냥 지금 인터럽트 상태인가요?" 라는 확인만하고 상태를 유지한다

이렇게 하면 신호가 꺼지지 않으므로

- 이후 다른 코드(예: 자원 정리 로직) 에서 또 `InterruptedException` 이 발생할 수 있다
  - 이것이 문제

**그래서 `Thread.interrupted()` 를 사용하면 확인도 하면서 신호도 자동으로 끈다!**

이 코드는

1. 인터럽트 상태일 경우 `true` 반환
2. 그리고 **자동으로 신호(flag)를 꺼줌**

그래서 이후 반복문은 인터럽트 신호를 감지하고 정상 탈출

자원 정리나 이후 로직에서도 방해받지 않는다

</br>

### Thread.sleep() 은 InterruptedException 을 던지는 메서드이다

메서드 시그니처에 `throws InterruptedException` 이 포함되어 있다

```java
public static native void sleep(long millis) throws InterruptedException;
```

**왜 `InterruptedException` 을 던질까?**

`Thread.sleep()` 은 현재 스레드를 `TIMED_WAITING` 상태로 만든다

그 시간 동안 다른 스레드가 `interrupt()` 를 호출하면 즉시 깨어나고 예외를 던진다

해당 예외는 **대기 중인 스레드에 인터럽트가 발생했을 때 깨어나도록 설계된 예외**이다

**자바는 차단(`blocking`) 상태인 메서드들을 인터럽트로 깨어날 수 있도록 하기 위해 `InterruptedException` 을 도입한 것 이다**

> 참고로 아래 메서드들도 `InterruptedException` 을 던진다
>
> - Thread.sleep() : 일정 시간 대기
> - Object.wait() : 모니터 락 대기
> - Thread.join() : 다른 스레드 종료 대기
> - BlockingQueue.take() : 큐에서 요소 꺼낼 때까지 대기
> - CountDownLatch.await() : latch 카운트 대기
> - Condition.await() : 락의 조건 대기
