`StringBuilder` 와 `StringBuffer` 는 둘 다 Java에서 문자열을 다루기 위해 사용되는 클래스이지만, 주요 차이점은 동기화(synchronization) 와 성능에 있습니다

</br>
</br>

## 동기화 여부

- `StringBuffer` 는 **스레드 안전(thread-safe)** 하도록 설계되어 있습니다. 모든 메서드가 `synchronized` 로 구현되어 있기 때문에 여러 스레드가 동시에 접근해도 안전하게 사용할 수 있습니다
- `StringBuilder` 는 **동기화되지 않은 클래스**입니다. 즉, 멀티 스레드 환경에서 안전하지 않지만 동기화 처리가 없어 성능이 더 빠릅니다

</br>

> 스레드 안전 (thread-safe) 하다는 ?
>
> 여러 개의 스레드가 동시에 어떤 코드나 객체에 접근하더라도 잘못된 동작이나 예기치 않은 경과가 발생하지 않도록 안전하게 설계되었다는 의미
>
> 1. 공유자원에 대한 동시 접근을 해도 문제가 없다
>
> - 예시) 여러 스레드가 같은 리스트에 값을 추가하거나 제거할 때, 값이 유실되거나 중복되지 않도록 보장한다
>
> 2. 데이터 경쟁 (Race Condition)이 발생하지 않는다
>
> - 스레드 간의 실행 순서에 따라 결과가 달라지지 않도록 안전하게 제어한다
>
> 3. 원자성, 가시성, 순서성 같은 문제들을 잘 처리하고 있다
>
> - 예시) `synchronized`, `ReentrantLock`, `AtomicInteger` 등

</br>
</br>

## 성능

- `StringBuffer` 는 동기화로 인해 성능이 다소 떨어질 수 있습니다. 따라서 멀티 스레드 환경에서 사용하는 것이 적합합니다
- `StringBuilder` 는 동기화가 없기 때문에 싱글 스레드 환경에서 더 빠른 성능을 제공합니다

</br>
</br>

## 사용 상황

- 멀티 스레드 환경에서는 `StringBuffer` 를 사용하여 안전하게 문자열을 수정하는 것이 좋습니다
- 싱글 스레드 환경이나 성능이 중요한 경우에는 `StringBuilder` 를 사용하는 것이 더 적합합니다

</br>

- `StringBuffer` : 스레드 안전, 동기화 처리, 상대적으로 느리다
- `StringBuilder` : 스레드 안전하지 않음, 동기화 없음, 성능이 빠르다

대부분의 경우 멀티 스레드 환경이 아닌 경우에는 성능상의 이유로 `StringBuilder`를 사용하는 것이 좋습니다

</br>
</br>

## 왜 동기화(synchronized)가 걸려있으면 느린걸까요?

- 동기화(`synchronized`)가 걸려 있으면 성능이 느려지는 이유는 동기화에 따른 주기적인 오버헤드 때문입니다. 이를 좀 더 자세히 설명하면 다음과 같습니다

**1. 스레드 안전을 위한 잠금(Lock) 처리**

동기화가 걸려 있는 메서드나 블록은 한 번에 하나의 스레드만 해당 메서드나 블록에 접근할 수 있습니다. 즉, 여러 스레드가 동시에 접근하려고 하면 다른 스레드는 현재 스레드가 실행을 완료할 때까지 대기 상태에 있어야 합니다

동기화는 이처럼 임계 구역에 대한 잠금(Lock) 과 해제(UnLock) 작업을 추가로 수행하게 되며, 이로 인해 시간이 더 걸리게 됩니다. 특히 많은 스레드가 같은 자원을 접근하려고 할 때, 대기 시간이 길어지면서 성능이 떨어집니다

</br>

**2. 컨텍스트 스위칭 비용**

동기화가 필요한 경우, 스레드들은 자원을 확보하기 위해 서로 경쟁하게 됩니다. 이 과정에서 자원을 사용할 수 없는 스레드는 대기 상태로 들어가고, 대기 중인 다른 스레드가 CPU에 의해 활성화될 때 컨텍스트 스위칭이 발생합니다.

이 컨텍스트 스위칭은 스레드의 실행 상태를 저장하고 다른 스레드를 실행하기 위한 비용이 수반됩니다

</br>

**3. 캐시 일관성 문제**

멀티 스레드 환경에서 각 스레드는 프로세서의 캐시 메모리를 사용해 작업합니다. 동기화된 자원은 여러 스레드에 의해 공유되기 때문에, 자원이 변경될 때마다 캐시 일관성을 유지하기 위한 추가 작업이 필요하다

이는 자원 접근 속도를 느리게 만들 수 있습니다

</br>

동기화(`synchronized`) 는 멀티 스레드 환경에서 데이터 일관성과 스레드 안전성을 보장하기 위해 사용되지만, 이로 인해 잠금과 해제 과정, 대기 시간, 캐시 일관성 유지 등으로 추가적인 오버헤드가 발생해 성능이 느려지게 됩니다

</br>
</br>

## 싱글 스레드로 접근한다는 가정하에선 "StringBuilder" 와 "StringBuffer" 의 성능이 똑같을까요?

**싱글 스레드 환경**에서 `StringBuilder` 와 `StringBuffer` 의 성능에 대해

- `StringBuffer` 와 `StringBuilder` 는 둘 다 Java에서 문자열을 조작하는 데 사용되는 클래스지만, 주요 차이점은 `StringBuffer` 가 동기화를 통해 스레드 안전성을 제공하는 반면, `StringBuilder` 는 동기화되지 않은 비스레드 안전 클래스입니다

</br>

**성능비교**

싱글 스레드 환경에서의 성능은 일반적으로 `StringBuilder` 가 더 빠릅니다

그 이유는 `StringBuffer` 는 모든 메서드에 대해 동기화된 블록을 사용하여 스레드 안전성을 보장하기 때문에 추가적인 동기화 비용이 발생합니다

반면 `StringBuilder` 는 이러한 동기화가 없기 때문에 상대적으로 더 빠르게 동작합니다

</br>

**결과**

일반적으로 벤치마크 실험에서 싱글 스레드 환경의 문자열 조작 속도를 비교해 보면, `StringBuilder` 가 `StringBuffer` 보다 빠르게 나옵니다

그 이유는 `StringBuffer` 의 메서드가 **락 획득 및 해제 작업**을 수행해야 하기 때문에 약간의 오버헤드가 존재하기 때문입니다

따라서 싱글 스레드 환경에서만 사용한다고 가정할 때는 `StringBuilder` 를 사요하는 것이 더 효율적입니다. 다만 성능 차이가 미세할 수 있기 대문에 작은 코드에서는 눈에 띄지 않을 수도 있습니다

</br>
</br>

**결론**

- 싱글 스레드 환경에서는 `StringBuilder` 가 성능 면에서 더 유리합니다
- 멀티 스레드 환경에서는 `StirngBuffer` 가 안전하며, 동기화를 통한 안정성 때문에 `StringBuilder` 보다 느리다
- 동기화 오버헤드는 스레드 간의 경합이 없더라도 여전히 존재하므로 싱글 스레드 환경에서 성능 최적화를 위해서는 `StringBuilder` 를 사용하는 것이 좋습니다

</br>

StringBuilder vs StringBuffer

- `StringBuilder` 와 똑같은 기능을 수행하는 `StringBuffer` 클래스도 있다
- `StringBuffer` 는 내부에 동기화가 되어 있어서, 멀티 스레드 상황에 안전하지만 동기화 오버헤드로 인한 성능이 느리다
- `StringBuilder` 는 멀티 스레드 상황에 안전하지 않지만, 동기화 오버헤드가 없으므로 속도가 빠르다.
