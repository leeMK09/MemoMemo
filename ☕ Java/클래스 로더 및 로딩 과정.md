## 클래스 로더 및 로딩 과정

### 클래스 로더 

- 이름을 알고 있는 특정 클래스에 대한 정의 (`Byte Stream`)를 가져오는 역할을 수행 
- 부트스트랩 클래스 로더 
    - JVM 에서 라이브러리로 취급 (`rt.jar`, `tools.jar`) 되는 것들을 로드 (핫스팟에서는 C++ 로 구현)
    - JVM 또한 머신이기 때문에 BIOS 라는 개념의 부트스트랩 로더가 필요하다
    - 첫번째 OS 코드를 실행한다는 개념이다 
    - 하드웨어의 부트 개념이다 
- 플랫폼 클래스 로더 (기존 확장 클래스 로더)
    - 클래스 라이브러리 로드 
    - OS 의 커널 같은 개념이다 
- 애플리케이션 클래스 로더 
    - sum.misc.Launcher$AppClassLoader 를 의미 
    - 유저 모드 애플리케이션에서의 시작 지점 개념이다

</br>

### Java 클래스 로딩 

- 클래스 로딩 및 링킹 과정이 모두 런타임에 이루어진다 
    - 컴파일 → 실행 (링킹 + 런타임)
    - 실행 성능이 일부 저하될 수 있으나 높은 확장성과 유연성을 제공하는 근간이 된다 
        - 인터페이스만 맞으면 Runtime 에 구현 클래스를 결정하지 않을 수 있다 
        - 클래스 로더는 실행할 프로그램 코드를 네트워크로 수신하는 것도 가능하다 
- 검증(Verification) / 준비(Preparation) / 해석(Resolution) → 사용에 대한 준비 단계 (JVM 내에서 처리)
- Using → 사용하는 단계 즉 인스턴스를 만듦 (new 연산 실행)
- Unloading → JVM 내에서 처리 
- 해석(Resolution) 단계는 동적 바인딩 (혹은 늦은 바인딩) 을 지원할 목적으로 초기화 후로 지연될 수 있다 

</br>

### 클래스 검증 (Verification)

- JVM 명세가 정하는 규칙과 제약을 만족하는지 확인해야 한다 
    - 파일 형식 (.class)
    - 메타데이터
    - 바이트 코드 
    - 심벌 참조 
- 보안위협에 대한 검증 포함 
    - 바이트 코드 검증 시 함께 확인 

</br>

### 준비 및 해석 

- java.lang.Class 인스턴스 (메타데이터) 가 Heap 영역에 생성되고 클래스 변수 (정적 멤버) 메모리를 0 으로 초기화한다 
    - 로드되는 클래스의 인스턴스는 Using 단계에서 Heap 을 사용 
    - final 선언된 변수는 코드에서 정의한 초기값으로 정의 (0이 아닐 수 있음) → static final 
- 생성자 호출 전 상태 (new 연산 전)
    - 필드 (인스턴스 변수) 초기값은 생성자 호출 시 정의된다 
    - 정적 필드에 초기값 할당 
- 해석은 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정 

</br>

### Heap 영역에 객체 생성 

- JVM 은 객체 저장을 위한 메모리 공간을 확보 후 0 으로 초기화 (단, 객체 헤더 제외)
- 객체 초기화를 위한 구성설정 실시 
    - 클래스 이름 및 메타 정보 확인 방법 
    - 객체에 대한 해시코드 
    - GC 세대 나이 
    - Klass word 를 따라가면 클래스의 메타데이터를 확인할 수 있다 
- 생성자 호출 


