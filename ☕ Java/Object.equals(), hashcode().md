배열의 비교와 출력

- `toString()`
  - `toString()` 은 일차원 배열에만 사용할 수 있으므로 다차원 배열에는 `deepToString()`을 사용해야 합니다.
- `equals()`
  - `equals()` 도 일차원 배열에만 사용 가능하므로, 다차원 배열의 비교에는 `deepEquals()`를 사용해야 합니다

</br>
</br>

## equals()

- `equals()` 메서드는 두 객체가 논리적으로 동등한지를 비교합니다.
  - `boolean equals(Object obj)` 로 정의된 `equals` 메서드는 기본적으로 2개의 객체가 동일한지 검사하기 위해 사용합니다.
  ```java
  public boolean equals(Object obj) {
      return (this == obj);
  }
  ```
- 하지만 프로그래밍을 하다보면 동일한 객체가 메모리 상에 여러개 띄워져 있는 경우가 있습니다.
  - 해당 객체는 서로 다른 메모리에 띄워져있으므로 동일한(Identity) 객체가 아닙니다.
  - 하지만 프로그래밍 상으로는 같은 값을 지니므로 같은 객체로 인식되어야 하는데, 이러한 동등성 (`Equality`)를 위해 우리는 값으로 객체를 비교하도록 `equals()` 메서드를 오버라이딩해주는 것 입니다.

> 동일성
>
> 두 변수가 "같은 존재인지" 확인하는 것, 즉 두 객체가 같은 인스턴스를 참조하는지 동일성 (Identity)를 비교하는 것
>
> 동등성
>
> 두 변수가 "같은 값으로 평가되는지" 확인하는 것

</br>
</br>

## hashCode()

- `hashCode()` 메서드는 객체의 해시 코드 값을 반환합니다
  - 이는 주로 해시 기반 컬렉션(`HashMap`, `HashSet`, `HashTable` 등)에서 사용됩니다
  - `hashCode()` 는 객체를 해시 테이블의 특정 위치에 저장하거나 검색할 때 사용되는 값으로 객체의 고유한 정수값을 제공합니다

</br>
</br>

## Object 클래스의 `hashCode()` 기본 구현

- Java의 `Object` 클래스에서 `hashCode()` 메서드는 객체의 **메모리 주소를 기반으로 정수 값**을 반환합니다
  - 엄밀히 말하자면, JVM 구현에 따라 이 메모리 주소가 직접 사용되거나, 주소에 대한 특정 연산을 통해 해시 코드가 생성됩니다
- 따라서 `Object` 클래스의 기본 `hashCode()` 는 **객체가 힙 메모리에 저장된 위치를 이용하여 해당 객체의 유일성을 나타내는 값**을 생성하는 것 입니다
  - 이로인해, 두 객체가 서로 다른 메모리 주소를 갖고 있다면, 이 두 객체는 `hashCode()`는 서로 다른 값을 가지게 됩니다

</br>

### 해시 코드의 고유성

- 기본 `hashCode()` 구현의 목표는 객체의 고유성을 표현하는 값, 즉 **서로 다른 객체는 서로 다른 해시 코드를** 가지도록 하는 것 입니다
  - 이 값은 객체의 메모리 주소를 바탕으로 생성되기 때문에, 두 객체가 동일한 인스턴스가 아닌 한 기본적으로 다른 `hashCode()` 값을 가지게 됩니다
- 하지만 이 "고유성"은 자바의 `Object` 에서 기본으로 제공하는 것일 뿐, **커스텀 객체의 속성 값을 기반으로 동일한 논리적 의미**를 갖도록 재정의될 수 있습니다
  - 즉, 객체의 속성 값이 같다면 동일한 해시 코드가 반환되도록 `hashCode()` 를 재정의하는 것이 일반적입니다
  - 이를 통해 같은 논리적 데이터를 가진 객체들이 해시 기반 자료구조에서 같은 위치에 저장되거나 검색될 수 있게 만듭니다

</br>
</br>

## hashCode() 의 역할과 중요성

`hashCode()` 는 해시 기반 자료구조 (예시: `HashMap`, `HashSet`)에서 **매우 중요한 역할**을 합니다 해시 테이블에서 객체를 저장하고 검색하는 과정은 크게 두 단계로 이루어집니다

1. **해시 코드 계산** : 먼저 객체의 `hashCode()` 를 호출하여 **버킷(bucket)**이라고 불리는 특정 메모리 슬롯을 결정합니다. 같은 해시 코드를 가지는 객체들은 동일한 버킷에 위치하게 됩니다
2. **동등성 확인** : 같은 버킷에 저장된 객체들 중에서 **실제 값이 동일한지 확인**하기 위해 `equals()`를 호출합니다. 이를 통해 충돌이 발생한 객체들을 구분하거나, 특정 객체를 검색하는 데 사용합니다

따라서 `hashCode()` 와 `equals()` 는 서로 연관되어 사용되며, 둘 다 제대로 정의해야 해시 기반 자료구조에서 객체를 올바르게 저장하고 검색할 수 있습니다

**특히 `equals()` 가 `true`를 반환하는 객체는 반드시 동일한 `hashCode()` 를 반환**해야 합니다
그렇지 않으면, 논리적으로 동일한 객체가 해시 테이블의 서로 다른 위치에 저장되어 검색되지 않을 수 있습니다

</br>

### [ equals 와 hashCode 의 관계 ]

- 동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미한다. 즉, 동일한 객체는 동일한 해시코드를 가져야 합니다
  - 그렇기 때문에 우리가 `equals()` 메서드를 오버라이드 한다면, `hashCode()` 메서드도 오버라이드 되어야 합니다.
- 두 객체가 `equals()` 에 의해 동일하다면, 두 객체의 `hashCode()` 값도 일치해야 합니다.
- 두 객체가 `equals()` 에 의해 동일하지 않다면, 두 객체의 `hashCode()` 값은 일치하지 않아도 됩니다.

</br>
</br>

## 그럼 우리가 "hashCode"를 오버라이드 했을 때 메모리 주소를 리턴하게 할 수 있을까? 자바에서는 개발자가 직접 메모리에 접근할 수 있나요?

- `hashCode()` 메서드를 오버라이딩하여 다른 값을 반환하도록 저장하더라고, 실제로 그 주소로 메모리에 접근하거나 이동하는 것이 아닙니다.
  - `hashCode()` 메서드는 단순히 **객체를 고유하게 식별하기 위한 정수 값**을 반환하며, 이는 주로 **해시 기반 자료구조 (HashMap, HashSet 등)** 에서 사용되기 때문에, 해시 코드를 잘못 오버라이딩하면 특정 기능에 문제가 생길 수 있습니다
- Java 는 객체가 힙 메모리에 저장되더라도 해당 객체의 메모리 주소를 **개발자가 직접 얻어낼 수 있는 기능을 제공하지 않습니다**
  - 모든 객체는 JVM이 관리하며, 개발자는 객체의 레퍼런스를 통해 객체에 접근할 수 있지만, 메모리의 실제 주로를 알 수는 없습니다
  - 이러한 설계는 **메모리 안정성**과 **Garbage Collection (GC)**을 통해 불필요한 메모리 관리를 자동으로 처리함으로써 **메모리 누구나 잘못된 포인터 접근** 등의 문제를 방지하기 위한 것 입니다

</br>
</br>

## "hashCode" 를 잘못 오버라이딩 하면 "HashMap" 등 Hash컬렉션의 성능이 떨어질 수 있을까요? 어떤 케이스일 때 그럴 수 있나요?

1. 모든 객체에 동일한 해시 코드 반환

```java
@Override
public int hashCode() {
    return 1;
}
```

- 문제 : 모든 객체가 동일한 해시 코드를 가지게 되면, 해시 기반 컬렉션(예시: `HashMap`, `HashSet`) 에서 모든 요소가 동일한 버킷(bucket)에 저장됩니다.
- 결과 : 해시 테이블의 장점은 **빠른 검색**입니다. 이상적으로 각 요소가 서로 다른 버킷에 균일하게 분포될 때 검색 속도가 O(1)이 됩니다.
  - 그러나 모든 객체가 동일한 해시 코드를 가지게 되면, 해시 충돌로 인해 모든 요소가 하나의 버킷에 저장됩니다.
  - 이렇게 되면 각 버킷은 리스트로 관리되고, 검색/삽입/삭제의 시간 복잡도는 O(n)으로 증가하게 된다. 따라서 성능이 급격히 저하될 수 있습니다.

2. 해시 코드가 매우 빈번하게 충돌하는 경우

```java
@Override
public int hashCode() {
    return (int) (this.field % 10); // 해시 코드가 한정된 값으로 반환된다
}
```

- 문제 : 만약 특정 필드(`field`)의 값이 매우 제한적이라면, 해시 코드의 결과 값이 자주 겹칠 가능성이 크다
  - 예를 들어, 위에 예에서 해시 코드가 `0` 부터 `9` 까지의 값을 가질 수밖에 없다고 한다면 많은 객체들이 동일한 해시 코드를 가질 수 있습니다.
- 결과 : 이러한 충돌은 `HashMap` 이나 `HashSet` 에서 여러 객체가 동일한 버킷에 저장되는 결과를 초래하며, 이는 검색 시 **버킷 내의 객체들을 일일이 확인**해야 하므로 O(n)의 성능을 갖게 됩니다.
  - 특히 객체의 수가 많아질수록 성능 저하가 심각해 집니다.

3. 해시 코드 계산의 비효율성

```java
@Override
public int hashCode() {
    int result = 17;
    for (int i = 0; i < list.size(); i++) {
        result = 31 * result + list.get(i).hashCode();
    }
    return result;
}
```

- 문제 : 해시 코드를 계산할 때, 객체의 모든 속성을 사용하거나, 특히 크기가 큰 컬렉션을 반복해서 해시 코드를 생성하는 경우가 있습니다.
  - 이럴 경우 해시 코드 계산 자체가 비용이 많이 들게 됩니다.
- 결과 : 해시 코드를 자주 계산하는 상황에서 성능에 영향을 줄 수 있다. 예를들어 `HashMap` 에서 키를 통해 값을 검색할 때 마다 `hashCode()` 가 호출되므로 해시 코드 계산이 매우 비효율적이면 해시 테이블의 전체적인 성능이 떨어질 수 있습니다.

4. 동일한 객체 값이라도 다른 해시 코드 반환

```java
@Override
public int hashCode() {
    return (int) System.currentTimeMillis(); // 시간에 의존하는 해시 코드
}
```

- 문제 : 해시 코드가 일정하지 않고 매번 호출할 때마다 다른 값을 반환하도록 오버라이딩된 경우입니다. 예를 들어, `System.currentTimeMillis()` 와 같은 값을 사용하여 해시 코드를 반환하게 되면, 동일한 객체임에도 불구하고 매번 다른 해시 코드가 생성됩니다
- 결과 : `HashMap` 과 같은 해시 기반 컬렉션은 해시 코드가 동일해야 동일한 버킷에 접근합니다. 그러나 같은 객체가 매번 다른 해시 코드를 가지면 검색 시 원하는 버킷을 찾지 못하게 되어 **정확한 검색이 불가능하고 해시 테이블의 효율성을 잃게**됩니다

</br>
</br>

## 이상적인 hashCode 오버라이딩 원칙

1. 균일한 분포 : 해시 코드는 가능한 **서로 다른 객체들이 다른 값을 가질 수 있도록 설계**되어야 합니다. 이로 인해 객체들이 해시 테이블에서 고르게 분포될 수 있습니다
2. 성능 고려 : 해시 코드 계산은 가능한 **가벼워야** 하며, 복잡한 연산이나 큰 컬렉션을 반복하지 않아야 합니다
3. 일관성 유지 : 두 객체가 `equals()` 로 동일한 객체라면, 반드시 동일한 `hashCode()` 값을 반환해야 합니다. 이를 통해 해시 기반 컬렉션에서 동일한 객체가 동일한 버킷에 저장될 수 있습니다

</br>
</br>

## "HashMap"은 내부적으로 어떻게 구현되어있길래 그렇게 빨리 값을 탐색할 수 있을까요?

- `HashMap` 은 데이터를 빠르게 저장하고 검색하기 위해 해시 테이블을 기반으로 구현되어 있으며, 특정 키에 대해 빠르게 값을 찾아낼 수 있도록 해시 함수와 효율적인 충돌 처리 방법을 사용합니다

</br>

### HashMap 의 기본 구조

- `HashMap` 은 **배열 + 연결 리스트 (Java 8 이후 배열 + 연결리스트 + 트리 구조)**의 형태로 구현되어 있습니다
- 배열 : 가장 기본적으로 해시 테이블 역할을 하는 버킷(bucket) 배열이 존재합니다. 각 버킷은 데이터를 저장할 수 있는 공간이며, 해시 코드를 통해 키-값 쌍이 저장될 위치를 결정합니다
- 해시 함수 : 저장할 데이터의 키를 해시 함수에 넣어 해시 코드를 생성합니다. 이 해시 코드는 버킷 배열의 인덱스를 계산하는 데 사용됩니다. 이를 통해 O(1) 시간에 원하는 버킷으로 접근할 수 있게 됩니다
