## 문자열 풀 (String Pool)

- `String str3 = "hello"` 와 같이 문자열 리터럴을 사용하는 경우 자바는 메모리 효율성과 성능 최적화를 위해 문자열 풀을 사용한다
- 자바가 실행되는 시점에 클래스에 문자열 리터럴이 있으면 문자열 풀에 `String` 인스턴스를 미리 만들어둔다.
  - 이때 같은 문자열이 있으면 만들지 않는다
- `String str3 = "hello"` 와 같은 문자열 리터럴을 사용하면 문자열 풀에서 `"hello"` 라는 문자를 가진 `String` 인스턴스를 찾는다.
  - 그리고 찾은 인스턴스의 참조(`x003`)를 반환한다
- `String str4 = "hello"` 의 경우 `"hello"` 문자열 리터럴을 사용하므로 문자열 풀에서 `str3` 과 같은 `x003` 참조를 사용한다
- 문자열 풀 덕분에 같은 문자를 사용하는 경우 메모리 사용을 줄이고 문자를 만드는 시간도 줄어들기 때문에 성능도 최적화할 수 있다

따라서 문자열 리터럴을 사용하는 경우 → 같은 참조값을 가지므로 `==` 비교에 성공한다

</br>
</br>

## 처리순서

1. 문자 리터럴을 사용하면 문자열 풀에 만듦
2. 클래스 정보를 읽고 클래스가 로딩됨 → 이때 문자열 풀을 만듦
   - `"hello"` 라는 리터럴이 두 개라면 맨 처음에는 문자열 풀에 만들고 이후 같은 리터럴은 만들지 않음
     (= 두 리터럴은 같은 참조값을 가지는 `String` 객체가 변수에 저장됨 → `==` 비교 성공)
3. 로딩이 완료된 후 실제 프로그램이 실행될 때 문자열 풀에 있는 것을 찾아와서 변수에 넣어줌

</br>

자바에서는 char 배열이 아닌 String 클래스를 이용해서 문자열을 처리하는 이유는 String 클래스가 char 배열에 여러 가지 기능을 추가하여 확장한 것이기 때문이다

→ 객체지향의 개념을 추가함, char 배열과 그와 관련된 기능들을 함께 묶음

</br>

```java
String str = "Java";
str = str + "8";
System.out.println(str);
```

- 위 문장에서 문자열 `str` 의 내용이 변경된 것 같아보이지만, 문자열은 변경할 수 없으므로 "새로운 내용의 문자열이 생성" 된다
- 변경 가능한 문자열을 다루려면 `StringBuffer` 클래스를 사용하면 된다
- 커맨드 라인을 통해 입력된 문자열은 `String` 배열에 담겨 `Main` 클래스의 main 메서드의 매개변수 (`args`)에 전달된다
  - 커맨드 라인에서 숫자를 입력해도 숫자가 아닌 문자열로 처리된다
  - 공백문자를 포함하려면 "" 로 처리해야 한다

참고) [StringBuilder vs StringBuffer](https://github.com/leeMK09/MemoMemo/blob/main/%E2%98%95%20Java/StringBuilder%20vs%20StringBuffer.md)

</br>
</br>

---

</br>

문제

```java
public class StringEqualsMain1 {
    public static void main(String[] args) {
        String str1 = new String("hello");
        String str2 = new String("hello");
        System.out.println("new String() == 비교: " + (str1 == str2));
        System.out.println("new String() equals 비교: " + (str1.equals(str2)));

        String str3 = "hello";
        String str4 = "hello";
        System.out.println("리터럴 == 비교: " + (str3 == str4));
        System.out.println("리터럴 equals 비교: " + (str3.equals(str4)));
    }
}
```

결과

```bash
new String() == 비교: false
new String() equals 비교: true
리터럴 == 비교: true
리터럴 equals 비교: true
```

</br>
</br>

## new String 의 동일성과 동등성

- `str1` 과 `str2` 는 `new String()` 을 사용해서 각각 인스턴스를 생성했다. 서로 다른 인스턴스이므로 동일성 (`==`) 비교에 실패한다
- 둘은 내부에 같은 `"hello"` 값을 가지고 있기 때문에 논리적으로 같다.
  - 따라서 동등성 (`equals()`) 비교에 성공한다
  - 참고로 `String` 클래스는 내부 문자열 값을 비교하도록 `equals()` 메서드를 재정의 해두었다

</br>
</br>

## 리터럴의 동일성과 동등성

- `String str3 = "hello"` 와 같이 문자열 리터럴을 사용하는 경우 자바는 메모리 효율성과 성능 최적화를 위해 문자열 풀을 사용한다
- 자바가 실행되는 시점에 클래스에 문자열 리터럴이 있으면 문자열 풀에 `hello` 라는 문자를 가진 `String` 인스턴스를 찾는다
  - 그리고 찾은 인스턴스의 참조(`x003`)을 반환한다 → 동일성이 성공하는 이유
- `String str4 = "hello"` 의 경우 `hello` 문자열 리터럴을 사용하므로 문자열 풀에서 `str3` 과 같은 `x003` 참조를 사용한다

따라서 문자열 리터럴을 사용하는 경우 같은 참조값을 가지므로 `==` 비교에 성공한다

</br>
</br>

## 문자열 풀 장점

- 문자열 풀 덕분에 같은 문자를 사용하는 경우 메모리 사용을 줄이고 문자를 만드는 시간도 줄어들기 때문에 성능도 최적화할 수 있다
- 여러 곳에서 함께 사용할 수 있는 객체를 필요할 때 마다 생성하고, 제거하는 것은 비효율적이므로 대신 이렇게 문자열 풀에 필요한 `String` 인스턴스를 미리 만들어두고 여러 곳에서 재사용할 수 있다면 성능과 메모리를 더 최적화할 수 있다

</br>
</br>

**참고**

- 문자열 풀은 힙 영역을 사용한다
- 그리고 문자열 풀에서 문자를 찾을 때는 해시 알고리즘을 사용하기 때문에 매우 빠른 속도로 원하는 `String` 인스턴스를 찾을 수 있다

그렇다면 문자열 리터럴을 사용하면 `==` 비교를 하고, `new String()` 을 직접 사용하는 경우에만 `equals()` 비교를 사용하면 되지 않을까 ?

만약 `main` 메서드를 만드는 개발자와 `isSame()` 이라는 문자열 동등성 비교 메서드를 만드는 개발자가 다르다고 가정해보자

`isSame()` 의 경우 매개변수로 넘어오는 `String` 인스턴스가 `new String()` 으로 만들어진 것 인지, 문자열 리터럴로 만들어 진 것 인지 확인할 수 있는 방법이 없다

따라서 문자열 비교는 항상 `equals()` 를 사용해서 동등성 비교를 해야 한다
