지역 변수는 메서드가 끝나면 사라진다

이를 위해 `final` 을 사용하면 컴파일 되며 사용할 수 있게되는데 왜 괜찮은걸까? 접근을 막는게 아닌 오히려 허용하는 이유가 궁금하다

</br>
</br>

## 용어 정리

- 지역 변수 (Local Variable) : 메서드 블록 안에서 선언된 변수, 메서드가 끝나면 사라진다 (스택에 저장된다)
- 지역 내부 클래스 (Local Inner Class) : 메서드 안에서 정의된 클래스

</br>

### 왜 지역 변수는 그냥 접근이 안될까?

```java
void run() {
    int num = 10; // 지역 변수

    class MyInner {
        void print() {
            System.out.println(num); // 접근이 가능할까 ??
        }
    }

    MyInner inner = new MyInner();
    inner.print();
}
```

이 코드는 **Java 8 이전**이라면 **컴파일 에러**가 발생한다

Java 8 이후라면 컴파일은 되지만, `num` 은 **사실상 final (effectively final)** 이어야 한다

</br>
</br>

### 그럼 진짜 이유 → 왜 final 이어야만 허용될까?

→ 지역 변수는 메서드가 끝나면 사라지지만, 지역 내부 클래스는 메서드 바깥에서도 살아남을 수 있기 때문이다

- 자바에서 지역 내부 클래스는 클래스이기 때문에 힙에 올라간다
- 그런데 지역 변수는 스택에 올라가서 메서드가 끝나면 사라진다

즉, 지역 내부 클래스가 지역 변수를 직접 **참조(reference)** 하면 나중에 해당 변수의 메모리 주소를 따라가 봐도 없다 → 런타임 오류

그런데 `final` 이면 왜 괜찮을까 ?

여기서 중요한 건 자바는 final 지역 변수를 참조할 때 "값을 복삭" 해서 내부 클래스 안에 숨겨둡니다

```java
int num = 10;

class MyInner {
    void print() {
        System.out.println(num); // 사실은 복사본을 보고 있음
    }
}
```

컴파일러는 내부적으로 다음과 같은 동작을 수행합니다

- `num` 이 `final` 이면 변경될 일이 없으므로 내부 클래스 생성 시점에 해당 값을 복사해서 내부 클래스의 필드에 저장한다

```java
class MyInner {
    private final int copiedNum = 10;

    void print() {
        System.out.println(copiedNum);
    }
}
```

즉, 지역변수 `num` 이 사라져도, 내부 클래스는 복사된 값을 안전하게 사용할 수 있다

</br>

### 그런데 final 이 아니라면 ?

- `num` 이 변경될 수 있다면, 복사해도 그 값이 최신값인지 보장할 수 없다
- 그런데 스택이 있는 원래 `num`은 사라질 수 있다
- 즉, 참조는 남아있는데 실제 값은 없다 는 상태가 되어버린다 → 위험, undefined behavior

자바는 이걸 원천 차단하려고 "변경될 수 있는 값은 지역 내부 클래스에 참조하지 못한다" 라고 막아버린 것 이다

</br>
</br>

## 그래서 Java8 부터는?

- `final` 키워드 없어도 된다
- 단, `effectively final` (사실상 final) 조건이 필요하다

```java
void run() {
    int num = 10; // 변경 안 했으니 사실상 final

    Runnable r = () -> System.out.println(num); // 가능!
}
```

변경만 안 했으면 final 처럼 간주해서 컴파일을 허용한다

하지만 중간에 `num = 20;` 으로 값을 변경할 경우 컴파일 에러 발생 !

</br>
</br>

## 정리

왜 final 이어야 접근 가능한가 ?

- 그래야만 자바 컴파일러가 "복사해서 안전하게 가지고 있겠다" 라고 판단할 수 있기 때문입니다
- 변경 가능한 값을 참조하게 허용하면, 나중에 사라진 메모리를 참조하는 오류가 생길 수 있어 위험하기 때문이에요

| 조건                            | 허용 여부 | 이유                                                     |
| ------------------------------- | --------- | -------------------------------------------------------- |
| `final` 지역 변수               | 접근 가능 | 값을 복사해서 내부 클래스가 보관 가능                    |
| 변경 가능한 지역 변수           | 접근 불가 | 값이 바뀔 수 있고, 원본은 메서드 종료 시 사라지므로 위험 |
| Java 8 이후 `effectively final` | 접근 가능 | 변경하지 않으면 `final`로 간주됨                         |
