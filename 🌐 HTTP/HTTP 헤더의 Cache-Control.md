일반 헤더 (General Header) 

- 요청 과 응답 두 헤더에 공통으로 들어가 있으며 종류는 아래
    - Cache-Control

</br>

## Cache-Control

- 캐시를 지정된 디렉티브 (명령어) 를 통해 동작를 지정함

### 캐시 Request 디렉티브

- `no-cache` : 무조건 오리진 서버에 데이터 재검증 요청 (강제적인 재검증)
- `no-store` : 리퀘스트, 리스폰스의 데이터를 보존해서는 안됨 (저장 하지않음)
- `max-state` : 확인이 필요하나 의미는 아래와 같음
    - 서버로부터 수신된 리스폰스가 만료된 이후에도 얼마 동안 캐시된 응답을 사용할 수 있는지 
    예를 들어, 클라이언트가 네트워크 연결이 불안정하거나 혹은 서버가 불안정할 경우 응답이 만료된 이후
    에도 일정 시간 동안 캐시된 응답을 사용할 수 있게 하여 시스템 가용성을 높이는데 사용함
- `min-fresh` : 클라이언트에서 응답을 받을 때 해당 데이터는 “최소 이 시간 만큼은 데이터가 신선해야 한다” 라는 것을 요구한다 라는 의미이다
    - 예를들어, `min-fresh=600` 이라면 클라이언트는 캐시된 응답이 최소 10분 (600초) 동안은 신선해야 한다는 조건
    - 만약, 10분의 신선도를 요구했지만 캐시된 응답이 그 요구를 충족하지 않는다면 그 응답은 클라이언트에서 사용하지 않음 → 클라이언트는 이러한 조건을 만족하는 새로운 응답을 서버로부터 요청하게 됨
        - 즉, `min-fresh` 조건을 만족하지 않는 캐시된 응답은 그대로 사용되지 않고, 항상 서버로부터 새롭고 신선한 응답을 얻으려 시도하게 됨
- `no-transform` : 프록시는 미디어 타입을 변환해서는 안됨 (`Content-Type`)
- `only-if-cached` : 캐시에서 리소스 취득
    - 클라이언트가 캐시된 응답이 있는 경우에만 응답을 받아오도록 요청
    - 캐시가 없거나 만료된 경우에는 `504 Gateway Timeout` 오류를 반환함
- `max-age` : 리스폰스의 최대 age 값
    - 리퀘스트로 `max-age` 디렉티브가 사용되었다면 저장되었던 값보다 새로운 경우에는 캐시되었던 리소스를 받아들일 수 있다 또한 지정한 값이 0 이면 캐시 서버는 리퀘스트를 항상 오리진 서버에 넘길 필요가 있다
    - 리스폰스로 `max-age` 디렉티브가 사용되었다면 캐시 서버가 유효성의 재확인을 하지 않고 리소스를 캐시에 보존해 주는 최대 시간을 나타냄, HTTP/1.1 캐시 서버는 동시에 `Expires` 헤더 필드가 달린 경우에는 `max-age` 디렉티브의 지정을 우선시 하고 `Expires` 헤더 필드는 무시함
        - HTTP/1.0 캐시 서버는 반대로 `max-age` 디렉티브가 무시됨

</br>

### 캐시 Response 디렉티브

- `public` : 리스폰스 캐시 가능
- `private`  : 특정 유저에 대해서만 리스폰스 캐시 가능
- `no-cache` : 리퀘스트로 `no-cache` 디렉티브가 사용된 경우, 캐시된 리스폰스를 클라이언트가 받아 들이지 않음을 의미함
    - 즉, 중간 캐시 서버가 오리진 서버까지 리퀘스트를 전송함
    - 서버 리스폰스에 `no-cache` 디렉티브가 사용된 경우, 캐시 서버는 리소스를 저장할 수 없으며 오리진 서버는 캐시 서버가 이후의 리퀘스트에서 리소스의 유효성을 재확인하지 않고는 그 리스폰스를 사용하지 못하도록 함
    - `Cache-Control: no-cache=Location`
        - 서버의 리스폰스로 `no-cache` 의 필드 값에 헤더 필드 명이 지정된 경우에는 이 지정된 헤더 필드만 캐시할 수 없으며 지정된 헤더 필드 이외에는 캐시하는 것이 가능하다
        - 이 파라미터는 리스폰스 디렉티브에서만 사용가능하다
- `no-store` : 캐시는 리퀘스트, 리스폰스의 일부분을 보존해서는 안됨
- `no-transform`  : 프록시는 미디어 타입을 변경해서는 안됨
    - 이 디렉티브의 목적은 주로 데이터의 일관성과 정합성을 유지하기 위해 사용됨
    - 이미지 같은 바이너리 데이터가 전송되는 경우 압축을 하지 않게됨
        - 압축을 하지 않으면 네트워크 리소스를 더 많이 사용하게 되어 성능이 저하될 수 있지만, 데이터의 정확성과 일관성을 보장하는 것이 더 중요한 경우에 적절한 디렉티브
- `must-revalidate` : 캐시 가능하지만 오리진 서버에 리소스의 재확인을 요구
    - 캐시된 응답이 유효할 때는 사용할 수 있지만, 만료되었을 경우에는 반드시 오리진 서버와 재검증을 거쳐야 함
    - 서버에서 응답이 업데이트되었는지 확인하지 않고 오래된 데이터를 제공하는 것을 방지 → 데이터의 정확성 보장
    - 캐시는 오리진 서버와 연결이 끊긴 상황에서도 응답을 제공할 수 있지만 `must-revalidate` 가 설정되어 있으면 서버에 재검증이 불가능할 때 캐시된 응답을 사용할 수 없으며, `504 Gateway Timeout` 오류를 발생시킨다 → 네트워크 연결시
        - 즉, 리퀘스트에 `max-stale` 디렉티브를 사용하고 있더라도 무시하게 됨 (효과를 없앰)
- `s-maxage` : 공유 캐시 (예: CDN 이나 프록시 캐시) 에서 응답을 얼마나 오래 저장할 수 있는지를 지정할 수 있음
    - 일반적으로 공유 캐시에서만 적용되며, 개인 브라우저 캐시는 이 값을 무시하게 됨
    - 공유 캐시 (예: CDN) 는 `s-maxage` 에 설정된 시간 동안 응답을 캐시하고 사용할 수 있음, 이 디렉티브는 `max-age` 또는 `Expires` 헤더의 값을 덮어쓰며 설정된 시간이 지나기 전까지는 캐시된 데이터를 이사용하게 됨
    - `s-maxage` 는 공유 캐시에서만 작동하며 개인 캐시는 무시됨, 즉 브라우저 캐시와 같은 개인 캐시는 이 설정에 영향을 받지 않고 `max-age` 등의 다른 지시에 따르게 됨
    - 공유 캐시의 효율성을 높이고 서버 부하를 줄일때, 특히 대규모 트래픽을 처리할 때 유용한 설정
    - `s-maxage` 의 `s` 는 ***shared*** 를 의미함

</br>
</br>

> 참고 
>
> - 브라우저에서 파일 다운로드는 어떻게 동작하는가 ?
>    - 브라우저 마다 약간씩은 다르겠지만 동작 원리는 비슷하다, 크롬 브라우저를 예시로 설명해보겠다
>    - 파일 다운로드 요청을 하게되면 브라우저는 시스템 콜을 통해 운영체제와 상호작용하며 파일 시스템에 데이터를 기록하게 된다
>    - Chrome 은 로컬 다운로드 폴더 (지정된 폴더) 에 `.crdownload`  라는 확장자를 가진 파일을 생성한다
>    - 이때, 해당 파일은 다운로드 중에만 임시로 만들어내는 파일이며 확장자는 크롬을 예시로 든다
>    - 브라우저 다운로드 관리자는 진행 상황을 실시간으로 업데이트 한다
>    - 만약, 중간에 끊고 다시 이어서 다운로드 하려고 한다면
>    - `.crdownload` 파일에 이미 저장된 데이터를 기반으로 브라우저는 다운로드를 재개할 수 있다
>    - HTTP 의 `Range` 헤더를 사용하여 중단된 부분부터 이어서 다운로드하게끔 요청을 하게된다
>    - 이후 다운로드가 완료되면 Chrome 은 파일 무결성을 확인한 후, `.crdownload` 파일의 확장자를 최종 파일 형식으로 변경하여 사용자에게 완성된 파일을 제공하게 된다