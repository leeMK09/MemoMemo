## HTTP/1.0 (1996)

- 특징
  - 기본적으로 요청 1개 = TCP 연결 1개
  - 매 요청마다 TCP 연결을 새로 맺음 (비효율적)
  - Keep-Alive 가 표준이 아님 (일부 서버만 확장 헤더로 지원)
  - 헤더에 메타데이터를 담지만, 헤더 중복/비효율이 많음
- 문제점
  - 연결/해제 반복으로 TCP 핸드세이트 비용 증가
  - 네트워크 지연이 큼

</br>
</br>

## HTTP/1.1 (1997)

- 주요 개선점
  - Persistent Connection (기본)
    - `Connection: keep-alive` 를 통해 하나의 TCP 연결로 여러 요청+응답 가능
  - 파이프라이닝 도입
    - 여러 요청을 순차적 응답 없이 연속 전송 가능 → 하지만 HOL 문제로 거의 쓰지 안음
  - Host 헤더 필수 → 가상 호스트 지원
- 문제점
  - 요청은 순서대로 응답해야 해서 HOL(Head-of-line) 문제가 존재
  - 하나의 TCP 연결로도 다중화가 어려움

</br>

### HOL (Head-of-Line) 블로킹이란?

앞에 하나의 작업(헤드)이 막히면, 뒤에 있는 다른 작업들이 줄줄이 대기해야 하는 상황이 발생

HTTP 에서의 예시

- HTTP/1.1 에서 한 TCP 연결에 여러 요청을 파이프라이닝으로 보낼 수 있지만
- 응답은 순서대로 와야함 → 앞 요청이 오래 걸리면 뒤의 요청들도 대기
  - 뒤의 요청들이 블로킹되는 상황 = HOL Bloking

TCP 에서의 예시

- HTTP/2 는 다중 스트림으로 개선했지만, 여전히 TCP 기반이라서
- 한 패킷 손실 발생 시 → TCP 는 순서 보장을 위해 그 패킷이 재전송될 때까지 뒤쪽 데이터도 못 넘김
  - 결국 뒤의 스트림들도 대기 → HOL Bloking 발생

**HTTP/3 에서는 QUIC 덕분에 스트림이 독립적으로 처리되므로 HOL 문제를 근본적으로 없앰**

</br>
</br>

## HTTP/2.0 (2015)

- 주요 개선점
  - 하나의 TCP 연결에서 다중 스트림 처리 (Multiplexing)
    - 병렬로 요청+응답을 처리 → HOL 문제 상당 부분 완화
  - 바이너리 프레임 사용 → 헤더 압축(HPACK) / 헤더 오버헤드 감소
  - 서버 푸시(Server Push) 지원 → 클라이언트가 요청하지 않아도 필요한 리소스 선전송 가능
- 장점
  - 단일 연결로 여러 요청을 병렬 처리 → 성능 개선
  - 헤더 압축으로 트래픽 절감
- 한계
  - 여전히 TCP 기반 → 패킷 손실 시 TCP 레벨에서 HOL 발생 가능

</br>
</br>

## HTTP/3.0 (2022, QUIC 기반)

- 주요 개선점
  - TCP 대신 UDP 기반의 QUIC 프로토콜 사용
  - QUIC은 전송 계층에서 멀티플렉싱 지원 → 패킷 손실 시에도 다른 스트림 영향 없음
  - 0-RTT 핸드셰이크 → 연결 수립 지연 감소
  - TLS 1.3 내장 → 보안 기본 제공
- 장점
  - TCP 의 HOL 문제 근본 해결
  - 더 빠른 연결 수립 (모바일 환경, 빈번한 네트워크 전환에 강함)
- 단점
  - UDP 기반이라 방화벽/네트워크 환경에 따라 제한적일 수 있음

</br>

### 왜 HTTP/2 까지는 HOL 문제가 남아있을까?

- HTTP/2 는 하나의 TCP 연결 위에서 여러 요청(스트림)을 다중화(Multiplexing) 해서 보내는 기능을 제공
- 하지만 TCP 는 신뢰성을 위해 패킷 순서를 보장해야 함
  - 어떤 패킷 하나라도 손실되면 그 패킷이 재전송되어 올 때까지 뒤에 있는 패킷들은 애플리케이션에 전달하지 않음
- 즉, HTTP/2 에서 스트림은 논리적으로 독립이지만, 물리적으로 TCP의 순서보장 때문에 하나의 스트림이 막히면 다른 스트림까지 대기해야 함

</br>

### QUIC에서 어떻게 달라지는가?

- QUIC 는 TCP 대신 UDP 기반으로, 그 위에 전송계층을 직접 구현함
  - 덕분에 스트림 관리 방식을 새로 설계할 수 있었음
- QUIC 내부는 하나의 연결(connection) 안에 여러 개의 스트림을 가질 수 있음
- 각 스트림이 개별적으로 패킷을 관리하고, 순서도 스트림 단위로만 보장함
- 그래서
  - 스트림 A 의 패킷이 손실되어 재전송을 기다린다고 해도
  - 스트림 B,C 는 전혀 영향을 받지 않고 계속 데이터 전송/수신이 가능함

즉

- TCP
  - 한 줄로 세워둔 택배 상자들
- QUIC
  - 상자를 구분해서 각 줄로 따로따로 관리
