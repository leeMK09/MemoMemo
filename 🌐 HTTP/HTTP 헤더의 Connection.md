HTTP 요청 및 응답에서 사용되는 헤더로 네트워크 연결이 현재 HTTP 트랜잭션이 완료된 후에도 유지될 것인지 여부를 제어할 수 있다

</br>

주로 역할은 연결을 닫을 지(`Connection: close`) 또는 유지할지 (`Connection: keep-alive`) 를 지정하며, 같은 서버에 대한 이후의 요청을 위해 TCP 연결을 재사용할 수 있도록 하는 것 이다

</br>

## 접속관리

- `keep-alive`
  - 연결을 유지하여 동일한 TCP 연결을 여러 HTTP 요청과 응답에 재사용한다
  - 연결을 반복적으로 열고 닫는 오버헤드를 줄일 수 있다
  - `keep-alive` 를 통해 다수의 요청이 있을 때 성능을 크게 개선할 수 있다

HTTP/1.1 이전 버전의 HTTP 에서는 지속적 접속이 기본 설정이 아니었다

그렇기 때문에 오래된 버전의 HTTP 에서 지속적 접속을 하고 싶은 경우 `Connection` 헤더 필드에 `Keep-Alive` 라고 지정해야 한다

```text
1. 클라이언트에서

GET /HTTP/1.1
Connection: Keep-Alive

같은 요청을 보낸 경우

2. 서버에서는

HTTP/1.1 200 OK
Keep-Alive: timeout=10, max=500
Connection: Keep-Alive

같이 Keep-Alive 헤더 필드와 Connection 헤더 필드를 붙여서 응답한다

예시)
HTTP/1.1 200 OK
...
Keep-Alive: timeout=10, max=500
Connection: Keep-Alive
...
```

</br>

## `close`

- 현재 HTTP 트랜잭션이 완료되면 연결을 닫는다
- 이는 단일 요청에 대해서만 연결을 열어두는 방식

`Connection: close`

- HTTP/1.1 에서는 지속적 접근이 기본 설정으로 되어있다
- 그래서 요청을 송신했던 클라이언트는 접속이 계속 유지되면서 추가 요청을 송신하도록 한다
- 서버에서는 명시적으로 접속을 끊고 싶을 경우에 `Connection` 헤더 필드에 `close` 라고 지정 한다

</br>

## 중간 프록시 서버와의 상호작용

- `Connection` 헤더는 프록시 서버가 전달하지 않도록 명시된 헤더이다
- 즉, 프록시 서버는 `Connection` 헤더를 제거하고 이를 연결된 클라이언트와 서버 간의 직접적인 연결에서만 사용하도록 한다
- 클라이언트의 요청 혹은 서버의 응답에서 `Connection` 헤더 필드를 사용하며 프록시 서버에 더 이상 전송하지 않을 헤더 필드를 지정할 수 있다
- 요청이나 응답에 프록시나 중간 서버가 특정 헤더 필드를 다음 단계로 전송하지 않도록 지정 (`hob-by-hob` 헤더)

`Connection` 헤더를 사용하면 지정한 헤더 필드는 프록시를 통과할 때 제거되며, `Connection` 헤더가 언급한 필드들만 해당된다

이로인해 `Connection` 헤더는 `hob-by-hob` 특성을 가지며, 중간 서버와의 통신을 최적화하고 불필요한 헤더를 제거하여 데이터 처리 효율성을 높인다

예시)

```text
GET /HTTP/1.1
Upgrade: HTTP/1.1
Connection: Upgrade, Keep-Alive

위 예시에서 Connection 헤더는 Keep-Alive 와 Upgrade 헤더가 프록시를 넘어 다음 단계로 전달되지 않도록 지정

이러한 방식은 특히 웹소켓 업그레이드 요청이나 특정 연결 유지 관리에서 중요한 역할을 한다

Connection 헤더가 없는 경우, 기본적으로 중간 서버들은 모든 헤더를 다음 서버로 전달한다
```

> 참고
> 트랜잭션이라는 개념
>
> HTTP 와 DB 모두에서 사용되며, 각각의 기술적 특성에 맞게 동작하지만 "원자성" 이라는 공통된 개념을 공유한다
>
> HTTP 트랜잭션
> 클라이언트의 하나의 요청과 이에 대한 서버의 응답으로 이루어진 한 묶음을 의미한다
> 여기서 중요한 점은 요청과 응답이 함께 처리되어야 하는 논리적 단위라는 점이다

</br>

## Hob-by-hob, End-to-end 헤더

전송 경로의 특정 구간에서만 의미를 가지는지 아니면 전체 경로에서 의미를 가지는지에 따라 구분한다

**Hob-by-hob 헤더**

- 각 전송 경로 (노드) 사이의 개별적인 연결에서만 의미가 있으며, 중간 프록시 서버에 의해 전달되지 않는다
- 이러한 헤더는 반드시 해당 연결이 끝날 때까지만 유효하며, 중간 프록시가 다음 단계로 전달하지 않도록 설계되어 있다
- 예) `Connection`, `Keep-Alive`, `Proxy-Authenticate`, `Transfer-Encoding` 등은 해당 특징을 가지는 헤더

</br>

**End-to-end 헤더**

- 요청이 시작된 클라이언트부터 최종 서버 또는 최종 클라이언트까지 전체 경로를 따라 전달한다
- 이 헤더들은 프록시 서버를 거쳐도 수정 없이 그대로 전달되며, 캐시에도 저장될 수 있다
- 예) `Cache-Control`, `Authorication`, `Content-Type` 의 헤더가 해당된다
