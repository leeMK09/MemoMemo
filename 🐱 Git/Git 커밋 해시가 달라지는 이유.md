## 커밋 해시는 단순한 ID 가 아니다

- Git 의 커밋 해시는 다음 정보를 기반으로 생성된다
  - `Tree` : 파일 내용 + 파일 이름 상태
  - `Parent` : 부모 커밋 해시 (히스토리)
  - `Author / Commiter` : 이름, 이메일 시간
  - `Message` : 커밋 메시지

→ **이 중 하나라도 바뀌면 해시가 달라짐**

</br>

## 커밋 해시가 바뀌는 대표적인 경우

- `git commit --amed` : 메시지, 파일 변경
- `rebase` , `cherry-pick` : 부모 커밋이 달라짐
- `--author` 변경 : 작성자 정보 달라짐
- 파일 수정 : `Tree` 객체 변경
- 커밋 시간 차이 : 시간도 해시에 반영됨

</br>

## PR 이 이미 머지된 커밋이 다시 뜨는 이유

예시 상황

1. `release/2025-01-01` ← 과거 dev 브랜치 기준으로 분기
2. `main` 에 핫픽스 머지
3. `main` → `tb` → `dev` 로 `rebase` 진행
4. 이로 인해 `releaes` 브랜치에서 PR 을 올리면
   - 기준이 과거 dev 라서 Git 이 **공통 조상이 다르다고 판단**
   - 이미 병합된 커밋들이 **새 커밋처럼 다시 PR에 포함됨**

</br>

## 핵심 원인 → `rebase` 는 커밋 복제

- `rebase` 는 과거 커밋을 새로운 부모 위에 "복붙"
- 커밋 해시는 모두 새로 생성됨
- Git 은 기존 커밋과 새 커밋을 완전히 별개로 인식

```bash
# 기존 히스토리
A - B - C (dev)
     ↑
     release/2025-01-01

# rebase 이후
A - D (main)
     \
      B' - C' (dev)
```

- B, C → B', C'로 변경됨
- rebase 는 B, C 를 기준으로 삼기 때문에 → PR 시 B', C' 가 새 커밋처럼 뜬다

</br>

## 해결 방법

1. cherry-pick 으로 필요한 커밋만 선별 (단점: 번거로움)
2. merge 전략 변경 (`merge --no-ff`) 사용
   - `rebase` 대신 `merge --no-ff` 를 사용하면 커밋 해시는 유지되고
   - 병합 커밋 하나(M)만 추가됨

```bash
      B - C
     /
A - D --- M    ← merge commit
```

- 기존 커밋 (B, C) 은 변경되지 않음
- Git은 중복된 커밋이 아니라고 인식하지 않음 → PR 충돌없음

</br>

## 정리

- `rebase` 는 커밋을 새로 생성한다 → 해시 변경 → Git이 다른 커밋으로 인식
- `merge --no-ff` 는 기존 커밋은 그대로 두고 병합 커밋만 만든다 → 해시 유지
- PR 중복 이슈를 막고 싶다면 **병합 전략을 명확히 정의할 필요가 있다**
